//
// KT-20 Microcode originally created by Digital Equipment Corporation (DEC).
//  This code was archived (with no copyright notice attached) on:
//  <http://bitsavers.org/pdf/dec/pdp10/KT20_Minnow/minnow_uCodeSrc.pdf>
//
// Microcode changes to the original are Copyright 2009 by Rob Doyle
//

.DEBUG/0

.TITLE "KT-20 MICROCODE"
.TOC "Conditional Compiles"

;
;   DEBUG2   - UCODE ERR
;   DEBUG3   - POOP FLAG
;   DEBUGPF  - Debug Page Faults
;   DEBUGTTY - Replaces RDIOB instruction with RDTTY instruction (73510)
;   FAST     -
;   FTADRB   - installs address breakpoint
;   FTAGEPF  - Page Fault Aging?
;   FTBB     -
;   FTCKBP   - Check Bus Parity
;   FTCRC    - Adds CRC Calculation
;   FTCTLR   - Adds ^R Console Command
;   FTDDTM   - DDT Mode
;   FTFCSL   - Engineering Console Commands
;   FTFP     - Adds Floating Point
;   FTDIAG   - Diagnostics
;   FTLDIAG  - Long Diagnosics
;   FTMBZ    - Enforces "Must be zero" in instructions.
;   FTPFRMER - Something to do with page fail and memory errors
;   FTTTYF   -
;   FTTTYR   - TTY Line Reset when ??? occurs
;   FTTTYSB  - TTY Something about stop on buffer
;   FTSM     - Add SM Engineering Console Command
;   FTSMER   - Something to do with Memory Errors
;   FTZM     - Add ZM Engineering Console Command
;   FT7PI    - MUUO if try to set PI to 1
;   SILLY    -
;   SH_N_TL  - Show and Tell
;
; Instruction Set Options
;   FT10PAG  - Include TOP10 Instructions
;   FT20PAG  - Include TOP20 Instructions
;   FTEXTEND - Include Extend Instructions
;   FTBYTE   - Include Byte Instructions
;   FTCIS    - Include CIS Instructions
;

.SET/DEBUG2 = 1
.SET/DEBUG3 = 1
.SET/DEBUGPF = 1
.SET/DEBUGTTY = 1
.SET/FAST = 1
.SET/FTADRB = 1
.SET/FTAGEPF = 1
.SET/FTBB = 1
.SET/FTCKBP = 1
.SET/FTCRC = 0
.SET/FTCTLR = 1
.SET/FTDDTM = 1
.SET/FTFCSL = 1
.SET/FTFP = 1
.SET/FTDIAG = 1
.SET/FTLDIAG = 1
.SET/FTMBZ = 1
.SET/FTPFRMER = 1
.SET/FTTTYF = 1
.SET/FTTTYR = 1
.SET/FTTTYSB = 1
.SET/FTSM = 1
.SET/FTSMER = 1
.SET/FTZM = 1
.SET/FT7PI = 1
.SET/SILLY = 1
.SET/SH_N_TL = 1
.SET/FT10PAG = 1
.SET/FT20PAG = 1
.SET/FTEXTEND = 1
.SET/FTBYTE = 1
.SET/FTCIS = 1

.TOC "UPT Format"

;                    TOPS10                                        TOPS20
;       +-----------------------------------+      +-----------------------------------+
;     0 | Reserved                          |      | User pg 0,,User pg 1              |
;   377 |                                   |      | User pg 776,,User pg 777          |
;       +-----------------------------------+      +-----------------------------------+
;   400 | Reserved                          |      | Exec pg 340,,Exec pg 341          |
;   417 |                                   |      | Exec pg 376,,Exec pg 377          |
;       +-----------------------------------+      +-----------------------------------+
;   420 | Adr of LUUO block                 |
;       +-----------------------------------+
;   421 | User arith overflow trap ins      |
;       +-----------------------------------+
;   422 | User stack overflow trap ins      |
;       +-----------------------------------+
;   423 | User trap 3 ins                   |
;       +--------------------+--------------+
;   424 | MUUO flags         | MUUO op code |
;       +--------------------+--------------+
;   425 | MUUO old PC                       |
;       +-----------------------------------+
;   426 | E of MUUO                         |
;       +-----------------------------------+
;   427 | MUUO process context word         |
;       +-----------------------------------+
;   430 | Exec no trap MUUO new PC          |
;       +-----------------------------------+
;   430 | Reserved                          |
;   433 |                                   |
;       +-----------------------------------+
;   434 | User no trap MUUO new PC          |
;       +-----------------------------------+
;   435 | Reserved                          |
;   477 |                                   |
;       +-----------------------------------+
;   500 | Page fail word                    |
;       +-----------------------------------+      +-----------------------------------+
;   501 | Page fail flags                   |      | Page fail old flags,,PC           |
;       +-----------------------------------+      +-----------------------------------+
;   502 | Page fail old PC                  |      | Page fail new PC                  |
;       +-----------------------------------+      +-----------------------------------+
;   503 | Page fail new PC                  |      | Reserved                          |
;       +-----------------------------------+      +-----------------------------------+
;   504 | Reserved                          |
;   537 |                                   |
;       +-----------------------------------+
;   540 | User section 0                    |
;   500 |   ...                             |
;   577 | User section 37                   |
;       +-----------------------------------+
;   600 | Reserved                          |
;   777 |                                   |
;       +-----------------------------------+

.TOC "Register Usage"

;               EXT     INT
;     Reg 0     W1      PC FLAGS
;     Reg 1     W2      AC-OP+1
;     Reg 2     W3      MEM-OP+1
;     Reg 3     W4      EPT
;     Reg 4     W5      UPT
;     Reg 5     W6      SPT
;     Reg 6     IR      PMA
;     Reg 7     PC      TIME
;     Reg 10    E       PI REG(loads 2914 status reg)
;     Reg 11    MB      BIT4(first part done)
;     Reg 12    AC-OP   BIT12
;     Reg 13    MEM-OP  BIT17
;     Reg 14    PXCT    CO!C1
;     Reg 15    K 77    K 7777.-1
;     Reg 16    K 777   K 407777.0
;     Reg 17    K -1.0  K -1

.UCODE
.LTOR                                   ;Assume MIN6 CRM 00 to be leftmost bit.

.TOC 1, "CROM Field Definitions"
.TOC 2, "CROM Field - ALU"

;
; ALU Functons
;

ALU/=<0:8>                       	;AM2903 OP[8:0]

;
; ALU Special Functions
;

.TOC 3, "CROM Field - ALU, Subfield - ALU SP FUN"
ALU SP FUN/=<0:8>                       ;AM2903 OP[8:0]
        MUL=0000                        ;or 040, unsigned multiply
        TCM=0100                        ;or 140, Twos complement multiply
        S+1+C_B=0200                    ;increment by one or two
        SM=0240                         ;sign/magnitude twos complement
        TCM COR=0300                    ;or 340, twos complement multiply correction
        SLN=0400                        ;or 440, single length normalize
        DLN=0500                        ;or 540, double length normalize and first divide op
        TCDIV=0600                      ;or 640, twos complement divide
        TCDIV COR=0700                  ;or 740, twos complement divide correction and remainder

;
; ALU OP 0
;

.TOC 3, "CROM Field - ALU, Subfield - ALU OP 0"
ALU OP 0/=<0>                           ;AM2903 OP[8]

;
; ALU Shift (and Destination) Functions
;

.TOC 3, "CROM Field - ALU, Subfield - ALU SHIFT"
ALU SHIFT/=<0:3>,.DEFAULT=014           ;AM2903 OP[8:5] - This controls the destination (w/shift)
        ASR F_B                         "ALU SHIFT/000,ALU_Y/YES"                          ;ASR F_Y Q_Q WRITE=0
        LRS F_B                         "ALU SHIFT/001,ALU_Y/YES"                          ;LRS R_Y Q_Q WRITE=1
        F_LRS Y_B                       "ALU SHIFT/001,ALU_Y/NO"                           ;LRS R_Y Q_Q WRITE=1
        (MC F)RS_[]                     "MC_SION SIO0_QION,LRS F_B,B SEL/@1"               ;
        (MN F)RS_[]                     "MN_SION SIO0_QION,LRS F_B,B SEL/@1"               ;
        ASRC_B                          "ALU SHIFT/002,ALU_Y/YES"                          ;F3_Y3;Y2 FQ/2_BQ
        LSRC_B                          "ALU SHIFT/003,ALU_Y/YES"                          ;LRS F_Y LRS Q_Q WRITE=3
        Y_[] QRS_Q                      "ALU SHIFT/003,ALU_Y/NO,B SEL/@1"                  ;LRS F_LRS Q_Q WRITE=3
        F_B                             "ALU SHIFT/004,ALU_Y/YES"                          ;F_Y Q_Q WRITE=4
        Y_B                             "ALU SHIFT/004,ALU_Y/NO"                           ;F_Y Q_Q WRITE=4
        F_Y QRS_Q                       "ALU SHIFT/005,ALU_Y/YES"                          ;F_Y LRS Q_Q=5
        F_Q                             "ALU SHIFT/006,ALU_Y/NO"                           ;F_Y F_Q=6
        F_Q_Y                           "ALU SHIFT/006,ALU_Y/YES"                          ;F_Y F_Q=6
        F_Q_B                           "ALU SHIFT/007,ALU_Y/YES"                          ;F_Y F_Q WRITE=7
        Y_B F_Q                         "ALU SHIFT/007,ALU_Y/NO"                           ;F_Y F_Q WRITE=7
        ALS F_[]                        "ALU SHIFT/010,ALU_Y/YES,#0_SIO0 #0_QIO0,B SEL/@1" ;ALS F_Y
        LLS F_B                         "ALU SHIFT/011,ALU_Y/YES"                          ;
        F_LSZ Y_[]                      "ALU SHIFT/011,ALU_Y/NO,#0_SIO0 #0_QIO0,B SEL/@1"  ;LLS F_Y
        ALSC_B                          "ALU SHIFT/012,ALU_Y/YES"                          ;ALS F_Y LLS Q_Q WRITE=012
        LLSC_B                          "ALU SHIFT/013,ALU_Y/YES"                          ;LLS F_Y LLS Q_Q WRITE=013
        Y_[] QLS_Q                      "ALU SHIFT/013,ALU_Y/NO,B SEL/@1"                  ;LLS F_Y LLS Q_Q WRITE=013
        F_Y                             "ALU SHIFT/014,ALU_Y/YES"                          ;F_Y Q_Q=014
        QLS_Q                           "ALU SHIFT/015"                                    ;F_Y LLS Q_Q=015
        F_Y QLS_Q                       "ALU SHIFT/015,ALU_Y/YES"                          ;F_Y LLS Q_Q=015
                                        ;SIO0_Y Q_Q WRITE=016              
                                        ;F_Y    Q_Q WRITE=017
;
; ALU Operations
;


.TOC 3, "CROM Field - ALU, Subfield - ALU OP"
ALU OP/=<4:7>,.DEFAULT=010              ;AM2903 OP[4:1]
        S-R-1+C=001
        R-S-1+C=002
        R+S+C=003
        S+C=004
        SBAR+C=005
        R+C=006
        RBAR+C=007
        LOW=010
        RBAR.AND.S=011
        R.XNOR.S=012
        R.XOR.S=013
        R.AND.S=014
        R.NOR.S=015
        R.NAND.S=016
        R.OR.S=017

;.TOC 3, "CROM Field - ALU, Subfield - ALU OP"
;ALU OP/=<4:8>,.DEFAULT=020              ;AM2903 OP[4:1]
;        HIGH=001
;        S-R-1+C=002
;        R-S-1+C=004
;        R+S+C=006
;        S+C=010
;        SBAR+C=012
;        R+C=015
;        RBAR+C=017
;        LOW=021
;        RBAR.AND.S=022
;        R.XNOR.S=024
;        R.XOR.S=026
;        R.AND.S=030
;        R.NOR.S=032
;        R.NAND.S=034
;        R.OR.S=036

.TOC 3, "CROM Field - ALU, Subfield - ALU 10"

;
; ALU OP LSB.  Shared with AM2904 OP[10]
; This selects either B RAM or Q Reg as the S input to the ALU.
;

ALU 10/=<8:8>,.DEFAULT=<B_S>            ;AM2903 OP[0]
	B_S=0                           ;S source is B RAM
	Q_S=1                           ;S source is Q reg

.TOC 2, "CROM Field - R SEL"
R SEL/=<9:14>,.DEFAULT=00
        REG-EXT=002
         W1=002
         W2=006
         W3=012
         W4=016
         W5=022
         W6=026
         IR=032
         PC=036
         E=042
         MB=046
         AC-OP=052
         MEM-OP=056
         PXCT=062
         K 77=066
         K 777=072
         K -1.0=076
        REG-INT=003
         PC FLAGS=003
         AC-OP+1=007
         MEM-OP+1=013
         EPT=017
         UPT=023
         SPT=027
         PMA=033
         TIME=037
         PI REG=043
         BIT4=047
         BIT12=053
         BIT17=057
         C0!C1=063
         K 7777.-1=067
         K 407777.0=073
         K -1=077

.TOC 3, "CROM Field - R SEL, Subfield - R SEL TYP"

R SEL TYP/=<13:14>                      ;R_SEL[4:5]
        RESERVED=00
	LINE=01
        REG EXT=02
        REG INT=03
        LINE #_[]                       "R SEL TYP/LINE,ALU OP/R+C,ALU 10/Q_S,#0_CO,F_[@1]"

.TOC 2, "CROM Field - B SEL"
B SEL/=<15:20>,.DEFAULT=00
        REG-EXT=00
         W1=000
         W2=004          
         W3=010
         W4=014
         W5=020
         W6=024
         IR=030
         PC=034
         E=040
         MB=044
         AC-OP=050
         MEM-OP=054
         PXCT=060
         K 77=064
         K 777=070
         K -1.0=074
        REG-EXT-LH=01
         W1 LH=001
         W2 LH=005
         W3 LH=011
         W4 LH=015
         W5 LH=021
         W6 LH=025
         IR LH=031
         PC LH=035
         E LH=041
         MB LH=045
         AC-OP LH=051
         MEM-OP LH=055
         PXCT LH=061
         K 77 LH=065
         K 777 LH=071
         K -1.0 LH=075
        REG-EXT-RH=02
         W1 RH=002
         W2 RH=006
         W3 RH=012
         W4 RH=016
         W5 RH=022
         W6 RH=026
         IR RH=032
         PC RH=036
         E RH=042
         MB RH=046
         AC-OP RH=052
         MEM-OP RH=056
         PXCT RH=062
         K 77 RH=066
         K 777 RH=072
         K -1.0 RH=076
        REG-INT=03
         PC FLAGS=003
         AC-OP+1=007
         MEM-OP+1=013
         EPT=017
         UPT=023
         SPT=027
         PMA=033
         TIME=037
         PI REG=043
         BIT4=047
         BIT12=053
         BIT17=057
         C0!C1=063
         K 7777.-1=067
         K 407777.0=073
         K -1=077

.TOC 3, "CROM Field - B SEL, Subfield - B SEL TYP"

B SEL TYP/=<19:20>                      ;B_SEL[4:5]
        REG EXT=00
        REG EXT LH=01
        REG EXT RH=02
        REG INT=03

        S SEL[]                         "B SEL/@1,ALU 10/B_S"

.TOC 2, "CROM Field - CARRY OP"

CARRY OP/=<21:22>,.DEFAULT=0            ;AM2904 OP[12:11]
        #0_CO                           "CARRY OP/00"
        #1_CO                           "CARRY OP/01"
        CX_CO                           "CARRY OP/02"  ;This is Z for ALU SP FUN stuff

SHARED OP/=<23:28>,.DEFAULT=00
SET FLAG/=<23:28>                       ;with shared op4.5=00
        CLEAR LOCAL                     "SET FLAG/010"
        SET GLOBAL                      "CLEAR LOCAL"
        SET LOCAL                       "SET FLAG/014"
        CLEAR USER                      "SET FLAG/020"
        SET EXEC                        "CLEAR USER"
        SET USER                        "SET FLAG/024"
        CLEAR PAGED                     "SET FLAG/030"
        SET PAGED                       "SET FLAG/034"
        CLEAR RUN                       "SET FLAG/040"
        SET RUN                         "SET FLAG/044"
        CLEAR TOPS20                    "SET FLAG/050"
        SET TOPS20                      "SET FLAG/054"
        CLEAR PXCT                      "SET FLAG/060"
        SET PXCT                        "SET FLAG/064"
        CLEAR TRAP                      "SET FLAG/070"
        SET TRAP                        "SET FLAG/074"

SHIFT OP/=<23:28>                       ;with shared op4,5=01
                                        ;AM2904 OP[9:6] Shift linkage mux
                                        ;AM2904 OP[10] comes from AM2903 OP[8]
        #0_SION #0_QION                 "SHIFT OP/001,ALU OP 0/0"
        #1_SION #1_QION                 "SHIFT OP/005,ALU OP 0/0"
        #0_SION SIO0_MC MN_QION         "SHIFT OP/011,ALU OP 0/0"
        #1_SION SIO0_QION               "SHIFT OP/015,ALU OP 0/0"
        MC_SION SIO0_QION               "SHIFT OP/021,ALU OP 0/0"
        MN_SION SIO0_QION               "SHIFT OP/025,ALU OP 0/0"
        #0_SION SIO0_QION               "SHIFT OP/031,ALU OP 0/0"
        SIO0_SION QIO0_QION             "SHIFT OP/051,ALU OP 0/0"
        QIO0_SION SIO0_QION             "SHIFT OP/075,ALU OP 0/0"

        SION_MC #0_SIO0 #0_QIO0         "SHIFT OP/001,ALU OP 0/1"
        #0_SIO0 #0_QIO0                 "SHIFT OP/011,ALU OP 0/1"
        #1_SIO0 #1_QIO0                 "SHIFT OP/015,ALU OP 0/1"
        SION_MC QION_SIO0 #0_QIO0       "SHIFT OP/021,ALU OP 0/1"
        QION_SIO0 #0_QIO0               "SHIFT OP/031,ALU OP 0/1"
        SION_SIO0 QION_QIO0             "SHIFT OP/051,ALU OP 0/1"
        SION_QIO0 QION_SIO0             "SHIFT OP/075,ALU OP 0/1"


INT OP/=<23:28>                         ;with shared opt4,5=10 2904 Instruction
        MASTER CLEAR=002
        CLEAR ALL INTS=006
        CLEAR INTS FROM Y-BUS=012
        CLEAR INTS FROM MASK REGISTER=016
        CLEAR INT LAST VECTOR READ=022
        GRANT INTERRUPT                 "INT OP/026"
        #2914 STATUS_Y                  "INT OP/032"
        #2914 MASK_Y                    "INT OP/036"
        #377_2914 MASK                  "INT OP/042"
        Y_2914 STATUS                   "INT OP/046"
        ;BIT CLEAR MASK REG=052
        ;BIT SET MASK REG=056
        #000_2914 MASK                  "INT OP/062"
        ;DISABLE INT REQ=066
        Y_2914 MASK                     "INT OP/072"
        ;ENABLE INT REQ=076

SPEC SEL/=<23:28>                       ;with shared op4,5=11 Load Ram/PCI adr
        Y=003                           ;Low order 12 bits of Y bus are Ramfile adr
                                        ; If this is an I/O adr = PCI
                                        ;   Y31 is 2651 A1
                                        ;   Y32 is 2651 A0
                                        ;   Y33-35 are line number

        VMA=023                         ;Uses low order bits from previous spec sel/page table entry
        AC+N=027
        XR=033
        PAGE TABLE ENTRY=077
        IW=053                          ; If bits 0,1 = 11 set ILLEGAL IW else clear ILLEGAL IW.
                                        ; If section 0 or if bits 0,1=10 set NOT GLOBAL, else CLEAR LOCAL.
                                        ; If GLOBAL load I and index reg from 1-5, else load from 13-17.
        SEL AC+[]                       "SPEC SEL/027,J.AC/@1"
        Y_RAMFILE ADR                   "SPEC SEL/Y"
        Y_TTY ADR                       "Y_RAMFILE ADR"

AMD2904 I5-I4/=<29:30>                  ;AM2904 OP[5:4]
        MX_Y                            "AMD2904 I5-I4/2,STATUS_Y,ALU_Y/NO"
        MX_[]                           "MX_Y,Y_[@1]"
        F_Q MX_[]                       "AMD2904 I5-I4/2,STATUS_Y,F_Q Y_[@1]"
        UX_[]                           "STATUS OP/001,STATUS_Y,Y_[@1]"

.TOC 2, "CROM Field - STATUS OP"
STATUS OP/=<29:34>,.DEFAULT=020         ;AM2904 OP[5:0]
        Y_MX                            "STATUS OP/000,M STATUS ENAB/YES"	; YX -> MX
        #1_UX                           "STATUS OP/001,U STATUS ENAB/YES"	; 1  -> UX
        #1_MX                           "STATUS OP/001,M STATUS ENAB/YES"	; 1  -> MX
        MX_UX                           "STATUS OP/002,U STATUS ENAB/YES"	; MX -> UX
        UX_MX                           "STATUS OP/002,M STATUS ENAB/YES"	; UX -> MX
        MX_UX UX_MX                     "STATUS OP/002,M STATUS ENAB/YES,U STATUS ENAB/YES"	; MX <-> UX
        #0_UX                           "STATUS OP/003,U STATUS ENAB/YES"	; 0  -> UX
        #0_MX                           "STATUS OP/003,M STATUS ENAB/YES"	; 0  -> MX
        IX!UOVR_UX                      "STATUS OP/006,U STATUS ENAB/YES"	;
        IX!MOVR_MX                      "STATUS OP/006,M STATUS ENAB/YES"	;

        #0_UZ                           "STATUS OP/010,U STATUS ENAB/YES"	;Reset zero bit
        #1_UZ                           "STATUS OP/011,U STATUS ENAB/YES"	;Set zero bit
        #0_UC                           "STATUS OP/012,U STATUS ENAB/YES"	;Reset carry bit
        #1_UC                           "STATUS OP/013,U STATUS ENAB/YES"	;Set carry bit
        #0_UN                           "STATUS OP/014,U STATUS ENAB/YES"	;Reset sign bit
        #1_UN                           "STATUS OP/015,U STATUS ENAB/YES"	;Set sign bit
        #0_UOVR                         "STATUS OP/016,U STATUS ENAB/YES"	;Reset overflow bit
        #1_UOVR                         "STATUS OP/017,U STATUS ENAB/YES"	;Set overflow bit


        IX_UX                           "STATUS OP/020,U STATUS ENAB/YES"	;
        IX_MX                           "STATUS OP/020,M STATUS ENAB/YES"	;
        IX ICBAR_UX                     "STATUS OP/030,U STATUS ENAB/YES"	;
        IX ICBAR_MX                     "STATUS OP/030,M STATUS ENAB/YES"	;

        MX_UX Y_MX                      "Y_MX,U STATUS ENAB/YES"		;
        #0_UC IX_MX                     "#0_UC,M STATUS ENAB/YES"		;
        #1_UC IX_MX                     "#1_UC,M STATUS ENAB/YES"		;

;Carry operation
        MC_C                            "CARRY OP/003,STATUS OP/047"
        UC_C                            "CARRY OP/003,STATUS OP/000"

;Test conditions
; U - micro status
; M - macros tatus
; I - current status (I bus)
; Z - zero;
; N - negative;
; OVR - overflow
; C - carry
; ! - inclusive or
; X - xor
; & - and
; E - xnor = equivalence

        UZ                              "STATUS OP/024"          		; Micro Zero
        MZ                              "STATUS OP/044"          		; Macro Zero
        IZ                              "STATUS OP/064"          		; I-bus Zero
        NOT UZ                          "STATUS OP/025"          		; Micro Not-Zero
        NOT MZ                          "STATUS OP/045"          		; Macro Not-Zero
        NOT IZ                          "STATUS OP/065"          		; I-bus Not-Zero
        UOVR                            "STATUS OP/026"          		; Micro Overflow
        MOVR                            "STATUS OP/046"          		; Macro Overflow
        IOVR                            "STATUS OP/066"          		; I-bus Overflow
        NOT UOVR                        "STATUS OP/027"          		; Micro Not-Overflow
        NOT MOVR                        "STATUS OP/047"          		; Macro Not-Overflow
        NOT IOVR                        "STATUS OP/067"          		; I-bus Not-Overflow
        UC                              "STATUS OP/032"				; Micro Carry
        MC                              "STATUS OP/052"				; Macro Carry
        IC                              "STATUS OP/072"				; I-bus Carry
        NOT UC                          "STATUS OP/033"                         ; Micro Not-Carry
        NOT MC                          "STATUS OP/053"				; Macro Not-Carry
        NOT IC                          "STATUS OP/073"				; I-bus Not-Carry
        UN                              "STATUS OP/036"          		; Micro Negative
        MN                              "STATUS OP/056"				; Macro Negative
        IN                              "STATUS OP/076"				; I-bus Negative
        NOT UN                          "STATUS OP/037"				; Micro Not-Negative
        NOT MN                          "STATUS OP/057"				; Macro Not-Negative
        NOT IN                          "STATUS OP/077"				; I-bus Not-Negative
        (UNxUOVR)!UZ                    "STATUS OP/020"				; (UNxUOVR)!UZ
        (MNxMOVR)!MZ                    "STATUS OP/040"				; (MNxMOVR)!MZ
        (INxIOVR)!IZ                    "STATUS OP/060"				; (INxIOVR)!IZ

        INxorMN                         "STATUS OP/016"				; INxorMN
        MNxMOVR                         "STATUS OP/042"				; MNxMOVR


        MC_C IX_MX                      "MC,M STATUS ENAB/YES"
        MC_C IX_UX                      "MC,U STATUS ENAB/YES"
        UZ IX_MX                        "UZ,M STATUS ENAB/YES"
        UZ UX_MX                        "UZ,U STATUS ENAB/YES"
        MZ IX_MX                        "MZ,M STATUS ENAB/YES"
        MZ IX_UX                        "MZ,U STATUS ENAB/YES"
        IZ IX_UX                        "IZ,M STATUS ENAB/YES"
        IZ IX_MX                        "IZ,U STATUS ENAB/YES"
        UOVR IX_MX                      "UOVR,M STATUS ENAB/YES"
        IOVR IX_MX                      "IOVR,M STATUS ENAB/YES"
	NOT IOVR IX_MX			"NOT IOVR,M STATUS ENAB/YES"
        UN IX_MX                        "UN,M STATUS ENAB/YES"
        UN IX_UX                        "UN,U STATUS ENAB/YES"
        MN IX_MX                        "MN,M STATUS ENAB/YES"
        MN IX_UX                        "MN,U STATUS ENAB/YES"
        IN IX_MX                        "IN,M STATUS ENAB/YES"
        IN IX_UX                        "IN,U STATUS ENAB/YES"
        (MNxMOVR)!MZ IX_MX              "(MNxMOVR)!MZ,M STATUS ENAB/YES"
        (MNxMOVR)!MZ IX_UX              "(MNxMOVR)!MZ,U STATUS ENAB/YES"

.TOC 2, "CROM Field - U STATUS ENAB"
U STATUS ENAB/=<35:35>,.DEFAULT=<NO>
        YES=0
        NO=1

.TOC 2, "CROM Field - M STATUS ENAB"
M STATUS ENAB/=<36:36>,.DEFAULT=<NO>
        YES=0
        NO=1

.TOC 2, "CROM Field - ALU_Y"
ALU_Y/=<37:37>,.DEFAULT=<NO>            ;2903
        NO=0
        YES=1

;
; This field controls the AM2910 controller op code.
;

.TOC 2, "CROM Field - U PROG OP"
U PROG OP/=<38:41>,.DEFAULT=<CONT>      ;AM2910 OP[3:0]
        JZ=000                                  ; Jump to address zero (not used)
        CJS=001                                 ; Conditional Jump Subroutine (address from Pipeline)
        JMAP=002                                ; Jump MAP (not used)
        CJP=003                                 ; Conditional Jump to address from Pipeline
        PUSH=004                                ; Push /Conditional Load Register
        JSRP=005                                ; Conditional Jump Subroutine to Register address or Pipeline address
        CJV=006                                 ; Conditional Jump to address from Vector (Dispatch ROMS)
        JRP=007                                 ; Conditional Jump to Register address or Pipeline address (not used)
        RFCT=010                                ; Repeat Loop until Counter = 0, Start Address is TOS
        RPCT=011                                ; Repeat Loop until Counter = 0, Start Address is Pipeline
        CRTN=012                                ; Conditional Return from Subroutine
        CJPP=013                                ; Conditional Jump to Pipeline and Pop.  Exit loop which uses stack.
        LDCT=014                                ; Load Counter and Continue
        TEOL=015                                ; Test End-Of-Loop
        CONT=016                                ; Continue
        TWB=017                                 ; Three Way Branch  (not used)

.TOC 2, "CROM Field - TEST SEL"
TEST SEL/=<42:47>,.DEFAULT=<NEVER>
        NEVER=000
        ALWAYS=001
        CT=002                                  ;2904 CT =0 MIN1 STATUS TEST
        NOT CT=003
        NOT INDEXED=004
        INDEXED=005
        AC.EQ.0=006
        AC.NE.0=007
        INDIRECT=010
        NOT INDIRECT=011
        NOT (I OR XR)=012
        I OR XR=013
        ILLEGAL IW=014                          ;Signal from SPEC SEL/IW =<not section 0> and <bit0,bit1=11)
        NOT ILLEGAL IW=015
        GLOBAL IW=016                           ;Signal from SPEC SEL/IW
        LOCAL IW=017                            ; <not section 0> and <bit0=1>
        NO PI REQ=020                           ;i.e. something wants to interrupt
        PI REQ=021
        NOT AC REF=022
        AC REF=023
        LEGAL SECTION=024
        ILLEGAL SECTION=025
        NOT SECTION 0=026
        SECTION 0=027
        CONTEXT MATCH=030                       ;i.e. no match, AC ref, or not paged
        NOT CONTEXT MATCH=031
        NOT MEM FAULT=032
        MEM FAULT=033
        LOCAL=034
        GLOBAL=035
        USER=036
        EXEC=037                                ;Not exec
        PAGED=040                               ;PAGED and NOT AC REF
        NOT PAGED=041                           ;AC REF or NOT PAGED
        RUN=042
        NOT RUN=043
        TOPS20=044
        TOPS10=045
        PXCT=046
        NOT PXCT=047
        B BIT 3=050                             ;i.e. bit 3 on B port register is set
        NOT B BIT 3=051
        ;B BIT 4=052                            ;i.e. bit 4 on B port register is set
        ;NOT B BIT 4=053
        B BIT 9=054
        NOT B BIT 9=055
        B BIT 18=056                            ;i.e. bit 18 on B port register is set
        NOT B BIT 18=057
        ANY BUS ERROR=060
        NO BUS ERROR=061
        NOT AC LOW=062
        AC LOW=063
        LOCK=064
        NOT LOCK=065
        TRAP=066
        NOT TRAP=067
        MEM EXISTS=070
        NOT MEM EXISTS=071
        UNPAGED OR AC=072
        NOT UNPAGED OR AC=073
        NOT TIMER FLAG=074
        TIMER FLAG=075
        SPARE=076
        NOT SPARE=077
        NOT MF & NOT PXCT=062

.TOC 2, "CROM Field - J"
J.AC/=<52:55>                                   ;4 bits in J field for AC+[]
J/=<48:59>,.ADDRESS,.DEFAULT=0
        U-CODE VERSION=04002                    ;Version of u-code
   ;EPT offsets
        PFW=00500                               ;Page fail word
        ESECT=00540                             ;Section pointers
   ;UPT offsets
   ;Console error codes
        ERR.URC=00001                           ;Unrecognized command
        ERR.NWR=00002                           ;Not while machine is running
        ERR.NEA=00003                           ;Not enough arguments
        ERR.NXA=00004                           ;Non existent address
        ERR.MER=00005                           ;Memory error
    ;PCI hdw bits
        A0=00010                                ;PCI adr for read status or write syn/syn/dle
        A1=00020                                ;PCI adr for MR1/MR2
        A1!A0=00030                             ;PCI adr for CR
        TXEN=00001                              ;Transmitter enable in CR
        RXEN=00004                              ;Receiver enable in CR

;Ramfile offsets
        BYTE MASK=00000                         ;Following are "byte masks"
        PAGE # MASK=00011                       ;bits 23-35 (9 bits)
        #10B MASK=00012                         ;10 bits
        #12B MASK=00014
        SECTION # MASK=00014                    ;bits 24-35 (12 bits)
        #13E MASK=00015
        #22B MASK=00026
        #23B MASK=00027
        #24B MASK=00030
        #27B MASK=00033
        #30B MASK=00036
        #32B MASK=00040
        JFCL MASK=00040                         ;bits 4-35
        #33B MASK=00041
;locations 45-77 contain -1

;Set of sliding bits
        BIT0=00100
         OVERFLOW=00100
        BIT1=00101
         CARRY 0=00101
        BIT2=00102
         CARRY 1=00102
        BIT3=00103
         FLOATING OVERFLOW=00103
        BIT4=00104
         FIRST PART DONE=00104
        BIT5=00105
         USER=00105
        BIT6=00106
         USER IO=00106
         PCU=00106                              ;Previous context user
        BIT7=00107
         PUBLIC=00107
        BIT8=00110
         ADDRESS FAILURE INHIBIT=00110
        BIT9=00111
         TRAP 2=00111
        BIT10=00112
         TRAP 1=00112
        BIT11=00113
         FLOATING UNDERFLOW=00113
        BIT12=00114
         NO DIVIDE=00114
        BIT13=00115
        BIT14=00116
        BIT15=00117
        BIT16=00120
        BIT17=00121
        BIT18=00122
        BIT19=00123
        BIT20=00124
        BIT21=00125
        BIT22=00126
        BIT23=00127
        BIT24=00130
        BIT25=00131
        BIT26=00132
        BIT27=00133
        BIT28=00134
        BIT29=00135
        BIT30=00136
        BIT31=00137
        BIT32=00140
        BIT33=00141
        BIT34=00142
        BIT35=00143
        BIT36=00144                             ;Phoney location
        PUSHJ FLAGS=00145                       ;Flags to clear on a PUSHJ =021600,,0
        ;UNUSED=00146
        ;MASK12-22=00147

        ME RCOVR=00150                          ;Memory error recovery routine adr
        HALT CODE=00151                         ;Halt code
                                                ; -1 = do a console command
                HALT INS=00001                  ; ISP JRST 4,
                HALT CONSOLE=00002              ;Console command
                HALT SI=00003                   ;Single instruction
                HALT PFMER=00004                ;Memory errors, while handling page fault
                HALT HSBMER=00005               ;Memory error while writing HSB
                HALT ADRBRK=00010               ;Address break

                HALT IOPF=00100                 ;IO Page failure
                HALT III=00101                  ;Illegal interrupt instruction
                HALT DSP=01000                  ;Illegal u-code dispatch
                                                ; Or GLOBAL at IFETCH
                HALT HME=01001                  ;Hard memory error
                HALT SUP=01005                  ;Startup check
        HME STS=00152                           ;Hard memory error status
                                                ; lh 2=Bus fault line,
                                                ;  3-Bus parity error into CPU
                                                ; rh is status from memory
                                                ;Hard memory error address
                                                ;Hard memory error data
        NXM STS=00155                           ;NXM memory error status
                                                ; lh=.,,rh is status from memory
                                                ;Soft memory error address (ECC correctable)
                                                ;Soft memory error data

        SME STS=00160                           ;Soft memory error status
                                                ;lh=2,,rh is status from memory
                                                ;Soft memory error address (ECC correctable)
                                                ;Soft memory error data
        INT RCOVR=00163                         ;Where to go if interrupted while not running
        PF RCOVR=00164                          ;Routine to go to if encounter page fail

        TTYRCV BITS=00177                       ;Bit for each receiver which has gone off
;Here begins line block for line 0
; See PCI section for pictures

        LNOSW=00200                             ;Line 0 status word
                LS.PI=07                        ;Mask for PI channel
                LS.CLS=010                      ;Close receive buffer
                LS.XOFF=020                     ;Xoff flag
                LS.XOFF.ENAB=040                ;Xoff enable
                LS.RGO=0100                     ;Receiver go
                LS.RDN=0200                     ;Receiver done
                LS.REN=0400                     ;Receiver enable
                ;LS.XGO=01000                   ;Transmitter go
                LS.XDN=02000                    ;Transmitter done
                LS.XEN=04000                    ;Transmitter enable
                LS.RESET=010000                 ;Reset line
                LS.DSCHG=020000                 ;Dataset change
                LS.DSENB=040000                 ;Dataset enable
                LS.RMER=0100000                 ;Receiver nxm or memory err
                LS.XMER=0200000                 ;Transmitter nxm or memory err
        LNOMDW=0201                             ;Mode word for CTY
          LNXMDW=001                            ;Offset for mode word
          LNXSYN=002                            ;Offset for synch word
          LNXCRC=003                            ;Offset for CRC word
                                                ; 2-17 =0 xmt crc calculation
                                                ; 20-35 =0 rcv crc calculation
          LNXXHD=004                            ;Offset for adr of transmit header
          LNXXCHR=005                           ;Offset for (DDT mode) transmit char
                                                ; non DDT mode
                                                ; 0-11 count of bytes left
                                                ; 12-13, byte number in word
                                                ; 14-35 current word physical adr
          LNXRHD=006                            ;Offset for adr of receive header
          LNXRCHR=007                           ;Offset for (DDT mode) receive char
;Here begins line block for line 1
        LN1SW=00210                             ;Line 1 status word
;Here begins line block for line 2
        LN2SW=00220                             ;Line 2 status word
;Here begins line block for line 3
        LN3SW=00230                             ;Line 3 status word
;Here begins line block for line 4
        LN4SW=00240                             ;Line 4 status word
;Here begins line block for line 5
        LN5SW=00250                             ;Line 5 status word
;Here begins line block for line 6
        LN6SW=00260                             ;Line 6 status word
;Here begins line block for line 7
        LN7SW=00270                             ;Line 7 status word
        LNZSW=00300                             ; End of line block

        CMDFLG=00300                            ;Flags for CTY/KLINIK line
           F.O=01                               ;^O has been typed
           F.S=02                               ; Xoff has been typed
           F.O!F.S=03

        ; F.USR=BIT4                            ;
        CMDRPT=00301                            ; Repeat Counter
        CMRPTR=00302                            ; Putter for command response buffer
                                                ; Byte pointer format
                                                ;  bits 0-17 byte number
                                                ;  bits 18-35 ramfile adr
                                                ; ramfile word adr
                                                ;  bit 0      unused
                                                ;  bits 1-7   1st byte = 4
                                                ;  bits 8-14  2nd byte =3
                                                ;  bits 15-21 3rd byte = 2
                                                ;  bits 22-28 4th byte = 1
                                                ;  bits 29-35 5th byte = 0
        CMRTKR=00303                            ;Taker for command response buffer
                                                ; Format same as C~RPTR
        CMRBUF=00304                            ;Command response buffer
        CMRBUF-1=00303
        CMRBUF END=00337                        ;End of command response buffer
        CMDPTR=00340                            ;Pointer to put command characters into buffer
                                                ; Format same as CMRPTR
        CMDTKR=00341                            ;Pointer to take command characters from buffer
                                                ; Format same as CMRPTR
                                                ; Only nonzero if a break has been typed
        CMDBUF=00342                            ;Command buffer
        CMDBUF-1=00341
        CMDBUF END=00407
        MB REFIL=00441                          ;Save MB here for a page refill

.IF/FTADRB
        AB IF=00442                             ;Address break instruction fetch
        AB WR=00443                             ;Address break write
        AB RD=00444                             ;Address break read
.ENDIF/FTADRB

        EXM ADR=00445                           ;Last memory adr examined or deposited
        EIS W1=00446                            ;Extend instruction saves W1 here
        EIS W2=00447                            ;Extend instruction saves W2 here
        EIS W3=00450                            ;Extend instruction saves W3 here
        EIS W4=00451                            ;Extend instruction saves W4 here
        EIS W5=00452                            ;Extend instruction saves W5 here
        EIS W6=00453                            ;Extend instruction saves W6 here
        NBBYTE1=00454                           ;Bits 0-8
        NBBYTE3=00455                           ;Bits 18-26

        X1=00454                                ;Temporary location
        X2=00455
.IF/DEBUG3
        POOP FLAG=00520
.ENDIF/DEBUG3
        CLK W2=00535
        CLK W3=00536
        ME W1=00537                             ;Save W1 here on memory error
        ME W2=00540                             ;Save W2 here on memory error
        WRIO TMP=00541                          ;Temporary location for WRIO
        HSB=00553                               ;Address of halt status block
        HSB MB=00554                            ;Save MB here when writing HSB
        HSB PMA=00555                           ;Save PMA here when writing HS8
        APR FLAGS=00556                         ;Bits 6-13 are flags which are enabled
                                                ; bits 24-31 are flags which are set
                                                ; bits 33-35 is APR PI level
        PI IN PROG=00557                        ;Interrupts in progress in bits 29-35
        PI SFT REQ=00560                        ;Software PI requests
                                                ; Bits 28-35 are software requests
                                                ; bits 10-17 are tty/apr requests
        PI LVL REG=00561                        ;bit 0 is PI system on/off flag
                                                ; bits 29-35 are levels on
        PROC REG=00562                          ;Processor register
                                                ; For picture see SET PROC REG
        RF PROC REG=00563                       ;Last word we wrote in hdw PROC REG
        TIME INTERVAL=00564                     ;Time interval
        INTERVAL COUNTER=00565                  ;Count it here
        TIME BASE=00566                         ;Two words of time (kept in u-sec)
        TIME BASE+1=00567                       ;Low order word of time
        CST=00571
        CSTMASK=00572
        CSTDATA=00573
        AC BLOCK=00574                          ;Current AC block
        P AC BLOCK=00575                        ;Previous context AC block
        PCS=00576                               ;Previous context section
        AC 0 0=00600
        AC 1 0=00620
        AC 2 0=00640
        AC 3 0=00660
        AC 4 0=00700
        AC 5 0=00720
        AC 6 0=00740
        AC 7 0=00760
        PAGE TABLE-1=00777
        PAGE TABLE=01000

.TOC 2, "CROM Field - MAP SEL"
MAP SEL/=<48:51>
        DISPATCH 1=010
         OPERAND FETCH=010
        DISPATCH 2=011
         INST EXCT=011
        DISPATCH 3=012
         OPERAND STORE=012
        DISPATCH 4=013
        ;DISPATCH 5=014
        ;DISPATCH 6=015
        ;DISPATCH 7=016
         IO 0=016
        ;DISPATCH 8=017
         MISC=017

.TOC 2, "CROM Field - MEM OP"
MEM OP/=<60:62>,.DEFAULT=07
        MEM HOLD                "MEM OP/00"                                             ;Do not release memory
        MEM START READ          "MEM OP/01,XFER MEM,#1_SION #1_QION,ALU_Y/YES"          ;Start memory with from ...
        MEM START WRITE         "MEM OP/02,XFER MEM,#1_SION #1_QION,ALU_Y/YES"          ;Start memory with adr from...
        START IO READ           "MEM OP/03,XFER MEM,#1_SION #1_QION,ALU_Y/YES"          ;Start IO read with adr from...
        START IO WRITE          "MEM OP/04,XFER MEM,#1_SION #1_QION,ALU_Y/YES"          ;Start IO write with adr from...
        IO TRANSFER             "MEM OP/05,XFER MEM"                                    ;Transfer IO (on MEM bus)
         IO_[]                  "Y_[@1],ALU_Y/NO,IO TRANSFER,XFER MEM,IX_MX"
         ALU_IO                 "ALU_Y/YES,IO TRANSFER,XFER MEM,#1_SION #1_QION,IX_MX"
        MEM TRANSFER            "MEM OP/05,XFER MEM"                                    ;Transfer MEM
         ALU_MEM                "ALU_Y/YES,MEM TRANSFER,XFER MEM,#1_SION #1_QION,IX_MX"
         []_MEM                 "[@1]_[@1],ALU_MEM"
         MEM_[]                 "Y_[@1],ALU_Y/NO,MEM TRANSFER,XFER MEM,IX_MX"
         MEM_IR_[]              "Y_[@1],ALU_Y/NO,MEM OP/05,LOAD IR,IX_MX"
        ;                       "MEM OP/06"                                             ;Reserved
        ALLOW DCH               "MEM OP/07"                                             ;Allow data channels

.TOC 2, "CROM Field - Y SEL"
Y SEL/=<63:66>,.DEFAULT=0
        XFER PIPELINE           "Y SEL/01"
         J[]_Y24-Y35            "J/@1,XFER PIPELINE,ALU_Y/NO"
         FJ[]_[]                "J[@1]_Y24-Y35,Y_[@2]"                          ;bits 0-23 from F, bits 24-35 from J
         F_Q FJ[]_[]            "J[@1]_Y24-Y35,F_Q Y_[@2]"                      ;bits 0-23 from F, bits 24-35 from J
         J[]_[]                 "ZERO_F,FJ[@1]_[@2]"
         JS[]_[]                "ZERO_F,J[@1]_Y24-Y35,B SEL/@2,#1_SION #1_QION,F_LRS Y_B" ;Bit 0 or J_[]
         JN[]_[]                "ONES_F,FJ[@1]_[@2]"                            ;bits 0-23 or J[]_[]
         []J[]_[]               "[@1]_F,J[@2]_Y24-Y35,Y_[@3]"                   ;bits 0-23 from R-SEL, bits 24-35
         ALU_CTR                "ALU_Y/YES,XFER PIPELINE"                       ;do not need U PROG OP
         J[]_CTR                "J/@1,U PROG OP/LDCT"                           ;Load 2910 counter from J field
         DISP []_Y              "XFER PIPELINE,ALU_Y/NO,MAP SEL/@1,U PROG OP/CJV,TEST SEL/NEVER"
        XFER MEM                "Y SEL/02"                                      ;Enable MEM bus transceivers
        ALU_PCI                 "ALU_Y/YES,Y SEL/03"
        PCI_ALU                 "ALU_Y/NO,Y SEL/03"
        ALU_RAMFILE             "ALU_Y/YES,Y SEL/04"
        []_RAMFILE              "[K -1]&[@1]_Y,ALU_RAMFILE"
        RAMFILE_Y               "ALU_Y/NO,Y SEL/04"
         RAMFILE_[]             "RAMFILE_Y,Y_[@1]"
        ALU_MR2                 "Y SEL/05,ALU_Y/YES"
        STATUS_Y                "Y SEL/06"
        SWAPPER_Y               "R SEL TYP/REG EXT,ALU_Y/NO,Y SEL/07"           ;A bus swapped goes to Y
         SWAP []_[]             "SWAPPER_Y,R SEL/@1,Y_[@2]"
         SWAP []_[] F_Q         "SWAPPER_Y,R SEL/@1,Y_[@2] F_Q"
        ALU_PROC REG            "Y SEL/010,ALU_Y/YES"
        LOAD IR                 "Y SEL/011"                                     ;This implies transfer mem

T/=<67:69>,.DEFAULT=0                           ;Time
MARK1/=<70>,.DEFAULT=0
MARK2/=<71>,.DEFAULT=0


.TOC    "Instruction Macros"

        NOOP                    "U PROG OP/CONT"
        J[]_D                   "J/@1"
        GOTO Y                  "XFER PIPELINE,ALU_Y/YES,U PROG OP/CJP,TEST SEL/ALWAYS"
        CALL Y                  "XFER PIPELINE,ALU_Y/YES,U PROG OP/CJS,TEST SEL/ALWAYS"
        GOTO []                 "TEST SEL/ALWAYS,U PROG OP/CJP,J[@1]_D"
        GOTOP []                "TEST SEL/ALWAYS,U PROG OP/CJPP,J[@1]_D" ;Goto and pop stack
        POP                     "TEST SEL/ALWAYS,U PROG OP/TEOL"

        CALL []                 "TEST SEL/ALWAYS,U PROG OP/CJS,J[@1]_D"
        RETURN                  "TEST SEL/ALWAYS,U PROG OP/CRTN"

        RFCT                    "U PROG OP/RFCT"
        LOOP []                 "J[@1]_D,U PROG OP/RPCT"
        TWB [] []               "@1,J[@2]_D,U PROG OP/TWB"
        PUSH                    "TEST SEL/NEVER,U PROG OP/PUSH"
        PUSH J[]_CTR            "TEST SEL/ALWAYS,U PROG OP/PUSH,J[@1]_D"

        IF [] THEN []           "TEST SEL/@1,U PROG OP/CJP,J[@2]_D"
        IF [] THENP []          "TEST SEL/@1,U PROG OP/CJPP,J[@2]_D"                            ;If branch also pop
        IF [] THEN Y            "TEST SEL/@1,U PROG OP/CJP,XFER PIPELINE,ALU_Y/YES"
        IF [] CALL []           "TEST SEL/@1,U PROG OP/CJS,J[@2]_D"
        IF [] JSRP []           "TEST SEL/@1,U PROG OP/JSRP,J[@2]_D"
        IF [] D []              "TEST SEL/@1,DISP [@2]"
        IF [] RETURN            "TEST SEL/@1,U PROG OP/CRTN"

        IF CT [] THEN []        "TEST SEL/CT,@1,U PROG OP/CJP,J[@2]_D"   ;CT is 2904 STATUS TEST
        IF CT [] THENP []       "TEST SEL/CT,@1,U PROG OP/CJPP,J[@2]_D"
        IF CT [] THEN Y         "TEST SEL/CT,@1,U PROG OP/CJP,XFER PIPELINE,ALU_Y/YES"
        IF CT [] CALL []        "TEST SEL/CT,@1,U PROG OP/CJS,J[@2]_D"
        IF CT [] JSRP []        "TEST SEL/CT,@1,U PROG OP/JSRP,J[@2]_D"
        IF CT [] RETURN         "TEST SEL/CT,@1,U PROG OP/CRTN"
        IF CT [] D []           "TEST SEL/CT,@1,DISP [@2]"
        IF NOT CT [] THEN []    "TEST SEL/NOT CT,@1,U PROG OP/CJP,J[@2]_D"
        IF NOT CT [] THENP []   "TEST SEL/NOT CT,@1,U PROG OP/CJPP,J[@2]_D"
        IF NOT CT [] THEN Y     "TEST SEL/NOT CT,@1,U PROG OP/CJP,XFER PIPELINE,ALU_Y/YES"
        IF NOT CT [] CALL []    "TEST SEL/NOT CT,@1,U PROG OP/CJS,J[@2]_D"
        IF NOT CT [] JSRP []    "TEST SEL/NOT CT,@1,U PROG OP/JSRP,J[@2]_D"
        IF NOT CT [] RETURN     "TEST SEL/NOT CT,@1,U PROG OP/CRTN"
        IF NOT CT [] D []       "TEST SEL/NOT CT,@1,DISP [@2]"

        DISP []                 "MAP SEL/@1,U PROG OP/CJV"
        DISPATCH []             "TEST SEL/ALWAYS,DISP [@1]"

        J[]_RAMFILE ADR         "J[@1]_Y24-Y35,ALU_Y/NO,Y_RAMFILE ADR"

        Y_[]                    "B SEL/@1,Y_B"
        Y_[] F_Q                "B SEL/@1,Y_B F_Q"
        F_Q Y_[]                "B SEL/@1,Y_B F_Q"
        F_[]                    "B SEL/@1,F_B"
        F_Q RAMFILE_[]          "F_Q Y_[@1],RAMFILE_Y"
        F_Q_[]                  "B SEL/@1,F_Q_B"
        ROR F_[]                "LRS F_B,SIO0_SION QIO0_QION,B SEL/@1"  ;ROR F_Q_Q WRITE=01

        F_ROR Y_[]              "F_LRS Y_B,SIO0_SION QIO0_QION,B SEL/@1" ;ROR F_Q_Q WRITE=01
        F_Y LSRQ_Q              "F_Y QRS_Q,#0_SION #0_QION"             ;Right shift Q, shift in 0
        F_Y RORQ_Q              "F_Y QRS_Q,SIO0_SION QIO0_QION"         ;Right shift Q, shift in 0
        LSZ F_B                 "LLS F_B,#0_SIO0 #0_QIO0"
        LSZ F_[]                "LSZ F_B,B SEL/@1"
        ROL F_B                 "LLS F_B,SION_SIO0 QION_QIO0"           ;LLS F_Y Q_Q WRITE=011
        ROL F_[]                "ROL  F_B,B SEL/@1"                     ;LLS F_Y Q_Q WRITE=011

        ZERO_F                  "ALU OP/LOW,ALU 10/Q_S"
        ZERO_Y                  "ZERO_F,F_Y"
        ZERO_[]                 "ZERO_F,F_[@1]"

        ONES_F                  "ALU OP/0,ALU 10/Q_S"
        ONES_[]                 "ONES_F,F_[@1]"

        BIT0_[]                 "ZERO_F,LRS F_B,#1_SION #1_QION,B SEL/@1"

        Q+C_F                   "ALU 10/Q_S,ALU OP/R+C"
        Q+1_F                   "#1_CO,Q+C_F"
        Q_F                     "Q&[K -1]_F"
        Q_Y                     "Q_F,F_Y"
        Q_[]                    "Q_F,F_[@1]"

        []+C_F                  "R SEL/@1,ALU OP/R+C,ALU 10/Q_S"
        []_F                    "[@1]+C_F,#0_CO"
        []_Y                    "[@1]+C_F,F_Y"
        []_Q                    "[@1]+C_F,F_Q"
        []_Q RAMFILE_[]         "[@1]+C_F,F_Q Y_[@2],RAMFILE_Y"
        []_[]                   "[@1]_F,F_[@2]"
        []_Q_[]                 "[@1]_F,F_Q_[@2]"

        B[]_F                   "S SEL[@1],#0_CO,ALU OP/S+C"

        #2*Q_Q                   "QLS_Q,#0_SIO0 #0_QIO0"
        #2*Q_[]                  "Q_F,LSZ F_[@1]"
        #2*[]_Q                  "R SEL/@1,S SEL[@1],#0_CO,ALU OP/R+S+C,F_Q"
        #2*[]_[]                 "[@1]_F,LSZ F_[@2]"
        #2*([]+[])_B             "[@1]+[@2]_F,LSZ F_B"
        #4*[]_B                  "#2*([@1]+[@1])_B"

        COMPLEMENT []_F         "R SEL/@1,ALU OP/RBAR+C,#0_CO"
        COMPLEMENT Q_F          "ALU 10/Q_S,ALU OP/SBAR+C,#0_CO"

        ASR []_[]               "[@1]_F,B SEL/@2,LRS F_B,MN_SION SIO0_QION"       ;Right shift,
        ASR []_[] MC            "[@1]_F,B SEL/@2,LRS F_B,#0_SION SIO0_MC MN_QION"  ;Right shift,
        ASRC []_[]              "[@1]_F,B SEL/@2,ASRC_B,MN_SION SIO0_QION"
        ROR []_[]               "[@1]_F,B SEL/@2,LRS F_B,SIO0_SION QIO0_QION"
        ROR F_B ROR Q_Q         "LSRC_B,SIO0_SION QIO0_QION"
        F LRS_[]                "B SEL/@1,LRS F_B,#0_SION #0_QION"
        F LRS_[] SIO0_MC        "B SEL/@1,LRS F_B,#0_SION SIO0_MC MN_QION"

        LRS []_[]               "[@1]_F,F LRS_[@2]"
        RORC []_[]              "[@1]_F,B SEL/@2,LSRC_B,QIO0_SION SIO0_QION"
        LSRC []_[]              "[@1]_F,B SEL/@2,LSRC_B,#0_SION SIO0_QION"
        ROL []_[]               "[@1]_F,B SEL/@2,ROL F_B"

        ROL []_[] ROL Q_Q       "[@1]_F,B SEL/@2,LLSC_B,SION_SIO0 QION_QIO0"
        LLS []                  "[@1]_F,LSZ F_[@2]"
        LLS []_[] LLS Q_Q       "[@1]_F,B SEL/@2,LLSC_B,#0_SIO0 #0_QIO0"
        ROLC []_[]              "[@1]_F,B SEL/@2,LLSC_B,SION_QIO0 QION_SIO0"
        LLSC []_[]              "[@1]_F,B SEL/@2,LLSC_B,QION_SIO0 #0_QIO0"

        NEGATE Q_F              "ALU 10/Q_S,#1_CO,ALU OP/SBAR+C"

        []BAR+C_F               "R SEL/@1,ALU OP/RBAR+C,ALU 10/Q_S"
        NEGATE []_F             "[@1]BAR+C_F,#1_CO"

        []+1_F                  "[@1]+C_F,#1_CO"
        []+1_Y                  "[@1]+1_F,F_Y"
        []+1_Q                  "[@1]+1_F,F_Q"
        []+1_Q RAMFILE_[]       "[@1]+1_F,Y_B,F_Q,RAMFILE_Y,B SEL/@2"
        []+1_[]                 "[@1]+1_F,F_[@2]"
        []+1_Q_[]               "[@1]+1_F,F_Q_[@2]"
        []+2_B                  "S SEL[@1],#1_CO,ALU SP FUN/S+1+C_B,ALU_Y/YES"

        Q+[]+C_F                "R SEL/@1,ALU 10/Q_S,ALU OP/R+S+C"
        Q+[]+1_F                "Q+[@1]+C_F,#1_CO"
        Q+[]_F                  "Q+[@1]+C_F,#0_CO"
        Q+[]_Y                  "Q+[@1]_F,F_Y"
        Q+[]_Q                  "Q+[@1]_F,F_Q"
        Q+[]_[]                 "Q+[@1]_F,F_[@2]"
        []+[]+C_F               "R SEL/@1,S SEL[@2],ALU OP/R+S+C"
        []+[]+C_B               "[@1]+[@2]+C_F,F_B"
        []+[]_F                 "[@1]+[@2]+C_F,#0_CO"
        []+[]_Y                 "[@1]+[@2]_F,F_Y"
        []+[]_Q                 "[@1]+[@2]_F,F_Q"
        []+[]_B                 "[@1]+[@2]_F,F_B"
        []+[]+1_F               "[@1]+[@2]+C_F,#1_CO"
        []+[]+1_Y               "[@1]+[@2]+C_F,F_Y,#1_CO"               ; Doyle added this

        Q-[]_F                  "R SEL/@1,ALU 10/Q_S,#1_CO,ALU OP/S-R-1+C"
        Q-[]_Y                  "Q-[@1]_F,F_Y"
        []-Q_F                  "R SEL/@1,ALU 10/Q_S,#1_CO,ALU OP/R-S-1+C"
        []-[]-1+C_F             "R SEL/@1,S SEL[@2],ALU OP/R-S-1+C"
        []-[]-1_F               "[@1]-[@2]-1+C_F,#0_CO"
        []-[]_F                 "[@1]-[@2]-1+C_F,#1_CO"
        []-[]_Y                 "[@1]-[@2]-1_F,F_Y"
        []-[]_Q                 "[@1]-[@2]-1_F,F_Q"
        []-[]_B                 "[@1]-[@2]-1_F,F_B"
        []-[]-1+C_A             "R SEL/@2,S SEL[@1],ALU OP/S-R-1+C,F_B"
        []-[]-1_A               "[@1]-[@2]-1+C_A,#0_CO"
        []-[]_A                 "[@1]-[@2]-1+C_A,#1_CO"

        SM []_B                 "S SEL[@1],CX_CO,ALU SP FUN/SM,ALU_Y/YES"       ;Sign/magnitude, twos complement
        MUL [] []               "R SEL/@1,S SEL[@2],#0_CO,ALU SP FUN/MUL,#0_SION SIO0_QION,ALU_Y/YES"
        TCM [] []               "R SEL/@1,S SEL[@2],#0_CO,ALU SP FUN/TCM,#0_SION SIO0_QION,ALU_Y/YES"
        TCM COR [] []           "R SEL/@1,S SEL[@2],CX_CO,ALU SP FUN/TCM COR,#0_SION SIO0_QION,ALU_Y/YES"
        TCDIV [] []_B           "R SEL/@1,S SEL[@2],CX_CO,ALU SP FUN/TCDIV,SION_QIO0 QION_SIO0,ALU_Y/YES"
        TCDIV COR [] []_B       "R SEL/@1,S SEL[@2],CX_CO,ALU SP FUN/TCDIV COR,#1_SIO0 #1_QIO0,ALU_Y/YES"

        Q&[]_F                  "R SEL/@1,ALU 10/Q_S,ALU OP/R.AND.S"
        Q&[]_Y                  "Q&[@1]_F,F_Y"
        Q&[]_Q                  "Q&[@1]_F,F_Q"
        Q&[]_Q RAMFILE_[]       "Q&[@1]_F,F_Q,Y_[@2],RAMFILE_Y"
        Q&[]_[]                 "Q&[@1]_F,F_[@2]"
        []&[]_F                 "R SEL/@1,S SEL[@2],ALU OP/R.AND.S"
        []&[]_Y                 "[@1]&[@2]_F,F_Y"
        []&[]_Q                 "[@1]&[@2]_F,F_Q"
        []&[]_B                 "[@1]&[@2]_F,F_B"

        []BAR&Q_F               "R SEL/@1,ALU 10/Q_S,ALU OP/RBAR.AND.S"
        []BAR&Q_Y               "[@1]BAR&Q_F,F_Y"
        []BAR&[]_F              "R SEL/@1,S SEL[@2],ALU OP/RBAR.AND.S"
        []BAR&[]_Y              "[@1]BAR&[@2]_F,F_Y"
        []BAR&[]_Q              "[@1]BAR&[@2]_F,F_Q"
        []BAR&[]_B              "[@1]BAR&[@2]_F,F_B"


        Q.OR.[]_F               "R SEL/@1,ALU 10/Q_S,ALU OP/R.OR.S"
        Q.OR.[]_Y               "Q.OR.[@1]_F,F_Y"
        Q.OR.[]_Q               "Q.OR.[@1]_F,F_Q"
        Q.OR.[]_[]              "Q.OR.[@1]_F,F_[@2]"
        [].OR.[]_F              "R SEL/@1,S SEL[@2],ALU OP/R.OR.S"
        [].OR.[]_Y              "[@1].OR.[@2]_F,F_Y"
        [].OR.[]_Q              "[@1].OR.[@2]_F,F_Q"
        [].OR.[]_B              "[@1].OR.[@2]_F,F_B"
        Q.XOR.[]_F              "R SEL/@1,ALU 10/Q_S,ALU OP/R.XOR.S"
        [].XOR.[]_F             "R SEL/@1,S SEL[@2],ALU OP/R.XOR.S"
        [].XOR.[]_Y             "[@1].XOR.[@2]_F,F_Y"

        Q.XNOR.[]_F             "R SEL/@1,ALU 10/Q_S,ALU OP/R.XNOR.S"
        [].XNOR.[]_F            "R SEL/@1,S SEL[@2],ALU OP/R.XNOR.S"

        READ []                 "[@1]_Q_[E],SPEC SEL/PAGE TABLE ENTRY,CALL [MEMORY READ]"
        WRITE []                "[@1]_Q_[E],SPEC SEL/PAGE TABLE ENTRY,CALL [MEM WRITE 1]"

        CHECK INTERRUPTS        "IF [PI REQ] CALL [CHK INT]"

        SECTION SELECT          "SPEC SEL/PAGE TABLE ENTRY"

        LIGHTS []               "J[@1]_[PXCT]"          ; Things to fix !!!

;
; Execution begins here
;
; Note:
;     The first few (6) instructions pop am2910 stack to ensure that
;     the stack is empty.
;

0:
BEGIN:  J[06000]_[W1],POP                       ;Will become 30000 next
        ;J[02515]_Y24-Y35,[W1]+[W1]_F,          ;300 baud
        ;J[05115]_Y24-Y35,[W1]+[W1]_F,          ;2400 baud
        J[07115]_Y24-Y35,[W1]+[W1]_F,           ;9600 baud
         F_LSZ Y_[W1],POP                       ; Ext clocks, 300 baud,
                                                ; 1 stop bit, 8bits, async lx
        J[LNOMDW]_RAMFILE ADR,POP               ;CTY mode word
        SWAP [W1]_[W1],
         CALL [W1_RAMFILE]
        ; GOTO [TEST]

;Here to check system seems to be ok
; This clobbers everything in Ramfile except CTY status and mode
; After checking will initialize Ramfile and 2903 regs


TEST:
;Initialize some registers
        ONES_[K -1],POP
        J[1]_[W1],POP
        SWAP [W1]_[BIT17],POP

.IF/FTDIAG
;First quick check on 2903, 2904, and 2910
        LIGHTS [1]                              ;1st ALU test
        JN[07776]_[W1]                          ;-2 to W1
        [W1]_Y,
         IF NOT CT [IN] THEN [ALU BROKE]
        [W1]+1_[W1],
         IF CT [IZ] THEN [ALU BROKE]
        [W1]+1_[W1],
         IF NOT CT [IZ] THEN [ALU BROKE]
;Right shift a bit through Q register
;Left rotate a bit through W1
;Count -36 to zero
        JS[0]_[W1]                              ;400000,,0_W1
        [W1]_Q,J[043]_CTR                       ;44(8) = 36(10)
        JN[07733]_[W2]                          ;Number to count up to zero
TALU21: Q_F,F_Y LSRQ_Q,                         ;Shift Q right
         IF CT [IZ] THEN [ALU BROKE]
        ROL [W1]_[W1],                          ;Put 1 in W1
         IF CT [IZ] THEN [ALU BROKE]
        [W2]+1_[W2],                            ;Check did not go to zero yet
        IF CT [IZ] THEN [ALU BROKE]
        LOOP [TALU21]                           ;Back for rest of count
        Q_F,F_Y LSRQ_Q,
         IF NOT CT [IZ] THEN [ALU BROKE]
        ROL [W1]_[W1],                          ;Rotate one more position
         IF NOT CT [IN] THEN [ALU BROKE]
        [K -1]+[W1]_Y,
         IF NOT CT [IZ] THEN [ALU BROKE]
        [W2]+1_[W2],                            ;Final count out
         IF NOT CT [IZ] THEN [ALU BROKE]

;Verify UX and MX in 2904
;For this test bits 28-31 is UX, 32-35 is MX

        LIGHTS [2]
        J[0377]_[W2]                            ;Start with all flags
.IF/FTBB
;Set UX from W2 bits 28-31, set KX from W2 bits 32-35
TUMX12: ROR [W2]_[W1],J[2]_CTR
TUMX13: ROR [W1]_[W1],Y_MX,LOOP [TUMX13]        ;Load MA from 32-35
        ROR [W1]_[W1],
         J[2]_CTR,MX_UX                         ;Load UX from 32-35
TUMX14: ROR [W1]_[W1],Y_MX,LOOP [TUMX14]        ;Load MX from 28-31
        MX_UX UX_MX                             ;Exchange MX and Ux

;Verify UX & MX by reading onto Y bus
        UX_[W1],J[3]_CTR                        ;Get micro flags
TUMX15: ROL [W1]_[W1],LOOP [TUMX15]             ;Put UX in W1 bits 31-35
        J[017]_[W3]                             ;Mask for extra Y bus bits
        [W3]&[W1]_F,F_Q Y_[W1],                 ;Mask off extra bits
        MX_Y,J[3]_CTR
TUMX16: ROL [W1]_[W1] ROL Q_Q,LOOP [TUMX16]     ;Shift left 4 places
        [W3]&[W1]_B                             ;Mask off extra bits
        Q.OR.[W1]_[W1]
        [W1].XOR.[W2]_Y,
         IF NOT CT [IZ] THEN [ALU BROKE]
.ENDIF/FTBB
.IFNOT/FTBB
;Set UX from W2 bits 28-31, set MX from W2 bits 32-35
TUMX12: LRS [W2]_[W1],J[2]_CTR
TUMX13: LRS [W1]_[W1],Y_MX,                     ;Load MX from 28-31
         LOOP [TUMX13]
        [W2]_Y,Y_MX MX_UX                       ;Load UX from MX and MX from Y

;Verify UX & MX by reading onto Y bus
        UX_[W1]                                 ;Get micro flags
        J[17]_[W3]                              ;Mask for extra Y bus bits
        [W3]&[W1]_B,J[1]_CTR                    ;Mask off extra bits
TUMX16: #4*[W1]_B,LOOP [TUMX16]                 ;Put UX in W1 bits 28-31
        MX_[W1],[W3]&[W1]_F,F_Q Y_[W1]          ;Mask off extra bits
        Q.OR.[W1]_[W1]                          ;Combine UX and MX
        [W1].XOR.[W2]_Y,
         IF NOT CT [II] THEN [ALU BROKE]
.ENDIF/FTBB

;Verify UX & MX with TEST SELECT
        ZERO_[W1],IF CT [UOVR] CALL [W1+1_W1]
        [W1]+[W1]_B,IF CT [UC] CALL [W1+1_W1]
        [W1]+[W1]_B,IF CT [UN] CALL [W1+1_W1]
        [W1]+[W1]_B,IF CT [UZ] CALL [W1+1_W1]
        [W1]+[W1]_B,IF CT [MOVR] CALL [W1+1_W1]
        [W1]+[W1]_B,IF CT [MC] CALL [W1+1_W1]
        [W1]+[W1]_B,IF CT [MN] CALL [W1+1_W1]
        [W1]+[W1]_B,IF CT [MZ] CALL [W1+1_W1]
        [W1].XOR.[W2]_Y,
         IF NOT CT [IZ] THEN [ALU BROKE]

        [K -1]+[W2]_B,
         IF NOT CT [IN] THEN [TUMX12]


;Verify LOCAL, USER, PAGED, RUN, TOPS20, PXCT, and TRAP latches

        LIGHTS [3]
        J[0177]_[W2]                            ;1st check all latches

TLTCH2:
;Here to set LOCAL, USER, PAGED, RUN, TOPS20, PXCT, & TRAP latches from W2
        J[0100]_Y24-Y35,[W2]_F,Y_[W3] F_Q
        Q&[W3]_F,F_Y QLS_Q,CLEAR LOCAL,
         IF NOT CT [IZ] CALL [SET LOCAL LATCH]
        Q&[W3]_F,F_Y QLS_Q,CLEAR USER,
         IF NOT CT [IZ] CALL [SET USER LATCH]
        Q&[W3]_F,F_Y QLS_Q,CLEAR PAGED,
         IF NOT CT [IZ] CALL [SET PAGED LATCH]
        Q&[W3]_F,F_Y QLS_Q,CLEAR RUN,
         IF NOT CT [IZ] CALL [SET RUN LATCH]
        Q&[W3]_F,F_Y QLS_Q,CLEAR TOPS20,
         IF NOT CT [IZ] CALL [SET TOPS20 LATCH]
        Q&[W3]_F,F_Y QLS_Q,CLEAR PXCT,
         IF NOT CT [IZ] CALL [SET PXCT LATCH]
        Q&[W3]_F,F_Y QLS_Q,CLEAR TRAP,
         IF NOT CT [IZ] CALL [SET TRAP LATCH]

;Here to read LOCAL, USER, PAGED, RUN, TOPS20, PXCT, & TRAP latches into W1
        ZERO_[W1],IF [LOCAL] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [USER] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [PAGED] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [RUN] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [TOPS20] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [PXCT] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [TRAP] CALL [W1+1_W1]

        CALL [TVR XY]                           ;Be sure W1 and W2 are same

        [K -1]+[W2]_B,                          ;Next combination of latches
         IF NOT CT [IN] THEN [TLTCH2]

;Verify the PI status register may be read and written
        LIGHTS [4]
        J[7]_[W2],Y_2914 STATUS                 ;1st value for reg
        J[7]_[W3]                               ;Mask for value
TP12:   #2914 STATUS_Y,Y_[W1]                   ;Get value back from reg
        [W3]&[W1]_B,
         CALL [TVR XY]                          ; Be sure we got correct value
        [K -1]+[W2]_B,Y_2914 STATUS,
         IF NOT CT [IN] THEN [TP12]

;Verify the PI mask register may be read & written 
.IF/FTLDIAG
        LIGHTS [5]
        J[0377]_[W2],                           ;1st value for mask
         Y_2914 MASK
        J[0377]_[W3]                            ;Mask for mask register
TP13:   Y_[W1],#2914 MASK_Y                     ;Get value back from mask
        [W3]&[W1]_B,                            ;Mask off extra bits
         CALL [TVR XY]                          ;Be sure we got correct value
        [K -1]+[W2]_B,
         Y_2914 MASK,
         IF NOT CT [IN] THEN [TP13]
        #2914 MASK_Y,                           ;Next value for register
         IF NOT CT [IN] THEN [TP12]
.ENDIF/FTLDIAG

;Verify the PI mask register blocks interrupts
        LIGHTS [6]
        J[0377]_[W2]                            ;1st value for mask
TP14:   J[07777]_[W6],                          ;Stall counter
         INT OP/MASTER CLEAR
        [W2]_Y,Y_2914 MASK                      ;Inhibit some interrupts
        J[0377]_[W1]                            ;Chnls where ints did not happen
        LRS [W1]_[W3],ALU_PROC REG              ;Start ints on all chnls
TP17:   J[7]_[W4]                               ;Mask for 2914 status
        [W4]_Q,
        IF [NO PI REQ] THEN [TP19]
        [W4]+1_Y,ALU_CTR                        ;Load ctr with 010
        IF [TIMER FLAG] THEN [TP171],
         GRANT INTERRUPT                        ; Grant interrupt
        #2914 STATUS_Y,Y_[W4]
        Q&[W4]_Y,ALU_CTR                        ;Get interrupting level+1
TP171:  BIT0_[W4],                              ;Bit for interrupt
        GOTO [TP173]
TP172: ROL [W4]_[W4]
TP173: ZERO_Y,Y_2914 STATUS,                    ;Allow next interrupt
        LOOP [TP172]
        [W4]BAR&[W1]_B                          ;Flag we got int
        [W4]BAR&[W3]_B,ALU_PROC REG             ;Stop trying to make that kind
TP19:   [K -1]+[W6]_B
        IF NOT CT [IN] THEN [TP17]
        CALL [TVR XY]                           ;See if right ints were inhibited
        [K -1]+[W2]_B,
         IF NOT CT [IN] THEN [TP14]

;Save CTY registers
        J[LNOMDW]_RAMFILE ADR
        RAMFILE_[PC]                    ;Save mode register here

;Ramfile test 1, float a bit through each word in Ramfile

TVR 00: LIGHTS [7.]                             ;First ramfile test
        CALL [TVR X0]                           ;Point to highest ramfile adr
TVR 1:  J[1]_[W2]                               ;Bit to float
TVR 2:  [W2]_RAMFILE,IX_MX,                     ;Write next pattern in ramfile
         CALL [TVR XX]                          ; Check we could write bit
        #2*[W2]_[W2],                           ;Write next word in ramfile
         IF NOT CT [MZ] THEN [TVR 2]
        Q_Y,ALU_RAMFILE                         ;Write words address in word
        Q+[K -1]_F,F_Q_Y,Y_RAMFILE ADR,         ;Next ramfile location
         IF NOT CT [IN] THEN [TVR 1]

;Ramfile test 2, verify each word has its address written in it
        LIGHTS [8.]                             ;Second ramfile test
        CALL [TVR X0]                           ;Initialize ramfile adr
TVR 3:  Q_[W2],Y_RAMFILE ADR,                   ;Address should equal data
        CALL [TVR XX]
        Q+[K -1]_F,F_Q_Y,Y_RAMFILE ADR,         ;Next ramfile word
         IF NOT CT [IN] THEN [TVR 3]

;Ramfile test 3, address ramfile with special selects
         LIGHTS [9.]                            ;Third ramfile test
         J[01477]_[W2],SET USER                 ;Expected page table contents
         J[0000]_[W3]                           ; Illegal section, sect.NE.0,
                                                ; not AC ref, no context match
        ONES_F,F_Y,
         SPEC SEL/PAGE TABLE ENTRY,
        CALL [RDPG LATCHES]
        J[01000]_[W2],SET EXEC                  ;Correct page table contents
        J[00016]_[W3]                           ; Legal section, sect.EQ.0
                                                ; AC ref, no context match
        ZERO_Y,ALU_PROC REG,                    ;Register block 0
         SPEC SEL/PAGE TABLE ENTRY,
         CALL [RDPG LATCHES]
        J[0701]_[W1]                            ;Will be AC16, XR=1
        SWAP [W1]_[W1]
        J[0601]_[W1]
        [W1]_Y,LOAD IR,SPEC SEL/XR,             ;Load IR
         CALL [TVR XX]
        J[0600]_[W2]                             ;What should be in AC0 block 0
        ZERO_Y,SPEC SEL/VMA,                    ;Address AC0
         CALL [TVR XX]
        SEL AC+[2]                              ;Select AC2 block 0
        CALL [TVR XX]
        J[0616]_[W2]
        SEL AC+[0]
        CALL [TVR XX]

;Zero entire Ramfile
        CALL [TVR X0]                           ;Set first adr for ramfile
IRF 2:  ZERO_Y,ALU_RAMFILE
        Q+[K -1]_F,F_Q_Y,Y_RAMFILE ADR,
         IF NOT CT [IN] THEN [IRF 2]

;Check PCIs are OK
        J[LNOSW]_[W6]                           ;First line block adr

;Verify we can read/write CR register
TPC10:  LIGHTS [10.]
        [W6]_[PXCT LH]
        J[0357]_[W4]                            ;Mask for compare
        J[0377]_[W3]                            ; Initial value

TPC 11: J[A1!A0]_[W1]                           ;To address CR register
        [W3]_[W2],CALL [WR PCI]                 ;Write CR register
        CALL [RD PCI CR]                        ;Get CR now
        [W4]&[W2]_B                             ;Leave only good data
        [W4]&[W1]_B,                            ;Leave only read data
         CALL [TVR XY]                          ; Compare good with bad
        [K -1]+[W3]_B,                          ;Next value for CR
         IF NOT CT [IN] THEN [TPC 11]

;Verify we can read/write MRI/2
        J[021]_[PXCT RH]

        [W6]+1_Y,Y_RAMFILE ADR                  ;Address mode word in ramfile
.IF/FTLDIAG
        J[06000]_[W1]                           ;Will become 30000
        J[07777]_Y24-Y35,[W1]+[W1]_F,           ;Leave 37777 in W1
        F_LSZ Y_[W1]
        SWAP [W1]_[W2]                          ;Put 37777,,0 in W2
.ENDIF/FTLDIAG
.IFNOT/FTLDIAG
        J[4000]_[W1]                            ;Will become 020000
        #4*[W1]_B                                ;Makes 020000
        SWAP [W1]_[W2]                          ;Make 020000,,0
.ENDIF/FTLDIAG
TPC12:  [W2]_RAMFILE,
        CALL [SET PCI MODE]
        J[A1]_[W1]                              ;For PCI adr to read MR1/2
        CALL [RD PCI]                           ;Get MR1
        J[0377]_[W3]                            ;Mask for extra bits
        [W3]&[W1]_Q                             ;Leave only MR1 in Q
        PCI_ALU,Y_[W1],J[3]_CTR                 ;Read MR2
        J[077]_[W2]                             ;Mask for MR25-MR20
        [W2]&[W1]_B
TPC14:  #4*[W1]_B,LOOP [TPC14]
        Q+[W1]_[W1]                             ;Combine W1 and W2
        [W6]+1_Y,Y_RAMFILE ADR,                 ;Address ramfile mode word
         CALL [SWAP W1_W1]                      ;Position like ramfile
        RAMFILE_[W2],CALL [TVR XY]              ;Get correct answer
.IF/FTLDIAG
        [W2]-[BIT17]_A,                         ;On to next combination
         IF NOT CT [IN] THEN [TPC12]
.ENDIF/FTLDIAG
.IFNOT/FTLDIAG
        ROR [W2]_[W2 LH],                       ;On to next bit
         IF NOT CT [IZ] THEN [TPC12]
.ENDIF/FTLDIAG

;Now ready for Next line
        J[010]_[W1]                              ;Bit to test
        [BIT17]+[W6]_B,                         ;Next line number in LH
         CALL [SWAP W1_W1]                      ;Position to test line number
         [W1]&[W6]_Y,                           ;See if we are done
          IF CT [IZ] THEN [TPC10]

;Restore CTY Ramfile registers
        J[LNOMDW]_RAMFILE ADR
        [PC]_RAMFILE,
        CALL [CMD&CMR FLUSH]                    ;Flush CMD and CMR buffers

;Checksum DISPATCH RAM
        LIGHTS [11.]                            ;Check DISPATCH ROM
        ZERO_F,F_Q_[W1]                         ;Initialize checksum
        J[0777]_[W2]                            ;First IR
TDP1:   SWAP [W2]_[W3],J[3]_CTR
TDP2:   #4*[W3]_B,LOOP [TDP2]
        #2*[W3]_[W3],LOAD IR
        DISP [010]_Y,Q+[W1]_F,F_Q Y_[W1]
        DISP [011]_Y,Q+[W1]_F,F_Q Y_[W1]
        DISP [012]_Y,Q+[W1]_F,F_Q Y_[W1]
        DISP [013]_Y,Q+[W1]_F,F_Q Y_[W1]
        DISP [014]_Y,Q+[W1]_F,F_Q Y_[W1]
        DISP [015]_Y,Q+[W1]_F,F_Q Y_[W1]
        DISP [016]_Y,Q+[W1]_F,F_Q Y_[W1]
        DISP [017]_Y,Q+[W1]_F,F_Q Y_[W1]
        [K -1]+[W2]_B,                          ;Next value for IR
         IF NOT CT [IN] THEN [TDP1]
        Q+[W1]_[W1]                             ;Make final checksum
        J[07777]_[W3]                           ;Mask for checksum
        J[0105]_[W2]                            ;Known checksum
        [W3]&[W1]_B,                            ;Mask result to 12 bits
        CALL [TVR XY]                           ; Compare two values

;Check memory is OK
        ;GOTO [SYS INIT]                        ;Initialize everything
.ENDIF/FTDIAG
.IFNOT/FTDIAG
        J[LNOMDW]_RAMFILE ADR                   ;Address tty mode word
        J[02000]_[W1]
        RAMFILE_[W6]                            ;Save it
        ZERO_[W2],Y_RAMFILE ADR
IR2:    ZERO_Y,ALU_RAMFILE,
         CALL [W2+1_RFA]
        [K -1]+[W1]_B,
         IF NOT CT [IZ] THEN [IR2]
        J[LNOMDW]_RAMFILE ADR                   ;Address Cty mode word
        [W6]_Y,ALU_RAMFILE,
         CALL [CMD&CMR FLUSH]                   ;Flush CMD and CMR buffers
.ENDIF/FTDIAG

;Here after TEST has run, to initialize machine for running
SYS INIT:

;Setup 2903 registers
        J[0077]_[K 77]                          ;Initialize register
        J[0777]_[K 777],                        ;Initialize register
         CLEAR RUN
        J[027]_[TIME]                           ;Initialize register
        ZERO_[K -1.0 RH]                        ;Clear RH of register
        J[3]_[C0!C1]
        ONES_[K -1.0 LH],PUSH J[2]_CTR          ;Set LH of register
        ROR [C0!C1]_[C0!C1],RFCT                ;Load 300000,,0
        J[1]_[W1]
        SWAP [W1]_[BIT17]                       ;Makes 1,,0
        J[07777]_Y24-Y35,[BIT17]_F,             ;Makes 0,,4077777
         F_ROR Y_[W1]
        SWAP [W1]_[K 407777.0]                  ;Initialize register
        J[0040]_[W1]
        SWAP [W1]_[BIT12]

;Setup RAMFILE byte masks
        J[BYTE MASK]_[W1]                       ;First adr in byte mask area
        [W1]+[K -1]_Q,                          ;First adr in Ramfi1e to set
         J[0077]_CTR                            ;Number of masks to write
        ZERO_[W1]                               ;First word is all zeros
IRF 10: CALL [RF WRITE]
        [W1]_F,LLS F_B,#1_SIO0 #1_QIO0,         ;Shift left shifting in ones
        B SEL/W1,LOOP [IRF 10]


;Setup RAMFILE bit table
        BIT0_[W1]                               ;First bit
IRF 12: CALL [RF WRITE]
        LRS [W1]_[W1],
         IF NOT CT [IZ] THEN [IRF 12]

;Setup other Ramfi1e locations
        J[PUSHJ FLAGS]_RAMFILE ADR
        J[04340]_[W1]                            ;Want 021600,,0
        SWAP [W1]_[W1]
        #4*[W1]_B,ALU_RAMFILE,
        J[5]_CTR

;Setup M8628 status register
        J[BIT20]_RAMFILE ADR                    ;Want 100000
        J[7]_[W5]                               ;Highest possible memory
        RAMFILE_[W4],J[1]_CTR
        J[06540]_[W1]                            ;Clear error flags
IM 12:  #4*[W1]_B,LOOP [IM 12]
IM 20:  [W4]+[W5]_F,F_Q_Y,                      ;Address memory status reg
        START IO WRITE
        [W1]_[W1],ALU_IO                        ;Write status register
        [K -1]+[W5]_B,                          ;Next memory
         IF NOT CT [IN] THEN [IM 20]            ; Loop back for rest of memories

;Setup another 2903 reg
        J[BIT4]_RAMFILE ADR
        RAMFILE_[BIT4]
        J[#30B MASK]_RAMFILE ADR
        RAMFILE_[K 7777.-1],
        CALL [SYS RESET]                        ;Reset a bunch of things

CONSOLE PROMPT:
        CALL [PUT CMR PROMPT]                   ;Type prompt
        ;GOTOP [CONSOLE]

.TOC "Console Program"

CONSOLE:
        IF [RUN] THENP [CSL2]
        CHECK INTERRUPTS
        J[INT RCOVR]_RAMFILE ADR                ;Address recovery routine
        RAMFILE_[W1]
        [W1]_[W1],
         IF NOT CT [IZ] THEN Y
CSL2:
CMD PRSEX:
        J[CMDTKR]_RAMFILE ADR
.IF/FTCRAM
        RAMFILE_[W1]                    ;Get break char flag
        [W1]_Y,
         IF CT [IZ] THEN [CSL3]
        J[CMRTKR]_RAMFILE ADR                   ;Address response putter
        RAMFILE_[W1]                    ;Get response taker
        [W1]_Y,
         IF CT [IZ] THEN [CMD PRSE]
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[W1],                   ;Get break char flag
         IF CT [IZ] THEN [CSL3]
        J[CMRTKR]_RAMFILE ADR                   ;Address response putter
        RAMFILE_[W2],                   ;Get response taker
         IF CT [IZ] THEN [CMD PRSE]
.ENDIF/FTCRAM
CSL3:   IF [RUN] THENP [IFETCH]
.IF/SH_N_TL
        CALL [SHOW&TELL]
.ENDIF/SH_N_TL
        GOTOP [CONSOLE]
.IF/SH_N_TL
SHOW&TELL:
        J[RF PROC REG]_RAMFILE ADR              ;Address ramfile copy of
        RAMFILE_[W1]                    ; PROC REG
        #2914 MASK_Y,Y_[W1]
        #2914 STATUS_Y,Y_[W1]
        J[LNOSW]_[W6]
        CALL [RD PCI CR]
        [W1]_[W1],
         CALL [RD PCI SR]
        [W1]_[W1]                               ;Display SR
        J[A1]_[W1]                              ;For PCI adr to read MR1/2
        CALL [RD PCI]                           ;Get MR1
        [W1]_[W1]                               ;Display MR1
        PCI_ALU,Y_[W1],                         ;Read MR2
        RETURN
.ENDIF/SH_N_TL

;Here to decode next console command
CMD PRSE:
        ZERO_[W5],                              ;Build command in W5
        CALL [GET CMD CHX]                      ;Get 1st nonblank char from command
        J[015]_[W2]                             ;Ascii "<cr>"
        [W1]-[W2]_Y,                            ;If end of line done
         IF CT [IZ] THEN [CMD DONE]
        J[054]_[W2]                             ;Ascii "."
        [W1]-[W2]_Y ,
         IF CT [IZ] THEN [CMD PRSE8]            ;Skip command separator
        GOTO [CMDP5]

CMDP2:  CALL [GET CMD CHR]                      ;Get next command char
        J[040]_[W2]                             ;Ascii " "
        [W2]-[W1]_Y,                            ;Compare
         IF CT [IZ] THEN [CMDDSP]
        J[015]_[W2]                             ;Ascii "<cr>"
        [W2]-[W1]_Y,                            ;Compare
         IF CT [IZ] THEN [CMDDSP]
        J[054]_[W2]                             ;Ascii ","
        [W2]-[W1]_Y,                            ;Compare
         IF CT [IZ] THEN [CMDDSP]
        #2*[W5]_[W5],
         J[2]_CTR
CMDP3:  #4*[W5]_B,
        LOOP [CMDP3]
CMDP5:  J[0140]_[W2]                            ;141 - 1ower case "a"
        [W1]-[W2]_Y,                            ;Compare
         IF CT [IN] THEN [CMDP6]
        J[0173]_[W2]                            ;172 - lower case "z"
        [W1]-[W2]_Y,                            ;Compare
         IF NOT CT [IN] THEN [CMDP6]
        J[040]_[W2]                             ;Mask for bit
        [W2].XOR.[W1]_F,F_B                     ;Convert to upper case
CMDP6:  [W1]+[W5]_B,
        GOTO [CMDP2]

;Consol commands include:
;
;       A       ;(101) Address Break
;       B       ;(102) Bootstrap
;       C       ;(103) Continue
;       D #1 #2 ;(104) Deposit #2 in physical memory location #1
;       DI      ;      Deposit IO
;       DR      ;      Deposit RAMFILE
;       DV      ;      Deposit Virtual
;       E #     ;(105) Examine physical memory location #
;       EI      ;      Examine IO
;       ER      ;      Examine RAMFILE
;       EV      ;      Examine Virtual
;       H       ;(110) Halts the machine and prints out PC
;       I       ;(111) Initialize system
;       R       ;(122) Repeat
;       S #     ;(123) Start at address #
;       SH      ;      Shutdown
;       SI      ;      Single Instruction
;       SM      ;      Start Microcode at uAddr
;       T       ;(124) Perform self test
;       ZM      ;      Zero Memory
;       ^C      ;(003) Abort repeat, or current line
;       ^M <cr> ;(015) ends command
;       ^R      ;(022) ?????
;       ^U      ;(025) deletes current command line
;       ^Z      ;(032) ?????
;       ^\      ;(034) Toggles console/user switch for console tty
;       ;       ;Separate commands
;       rubout  ;(177) deletes previous typed character

CMDDSP:
        CALL [BKUP CMD TKR]                     ;Backup over command terminator
        J[CMDERR MER]_[W1],POP                  ;Where to go if memory fails
        CALL [SET PF ME RCOVR]                  ;In case error in command
        J[0102]_[W1],POP
        [W1]-[W5]_F,F_Q_Y,
         IF CT [IZ] THEN [B CMD]
.IF/FTADRB
        Q+[K -1]_F,F_Y,
         IF CT [IZ] THEN [A CMD]                ;Ascii "A" = 101
.ENDIF/FTADRB
        Q+1_F,F_Q_Y,                            ;Ascii "C" = 103
         IF CT [IZ] THEN [C CMD]
        Q+1_F,F_Q_Y,                            ;Ascii "D" = 104
         IF CT [IZ] THEN [D CMD]
        Q+1_F,F_Q_Y,                            ;Ascii "E" = 105
         IF CT [IZ] THEN [E CMD]
        J[0110]_[W1]                            ;Ascii "H" = 110
        [W1]-[W5]_F,F_Q_Y,
         IF CT [IZ] THEN [H CMD]
        Q+1_F,F_Q_[W1],                         ;Ascii "I" = 111
        IF CT [IZ] THEN [I CMD]
.IF/FTFCSL
        [W1]+2_B,                               ;Ascii "K" = 113
        IF CT [IZ] THEN [JK CMD]
.ENDIF/FTFCSL
        J[0122]_[W1]                            ;Ascii "R" = 122
        [W1]-[W5]_F,F_Q_Y,
         IF CT [IZ] THEN [REPEAT]
        Q+1_F,F_Q_Y,                            ;Ascii "S" = 123
         IF CT [IZ] THEN [S CMD]
        Q+1_F,F_Q_Y,                            ;Ascii "T" = 124
         IF CT [IZ] THEN [T CMD]
        J[04000]_[W1]
        J[04710]_Y24-Y35,                       ;Ascii "SH" = 24710
        [W1]+[W1]_F,F_LSZ Y_[W1]
        [W1]-[W5]_F,F_Q_Y,                      ;Ascii "SI" = 24711
         IF CT [IZ] THEN [SH CMD]
        Q+1_F,F_Q_Y,
         IF CT [IZ] THEN [SI CMD]
.IF/FTFCSL
        [W1]J[01111]_[W1]                       ;Ascii "DI" = 21111
        [W1]-[W5]_Y,
         IF CT [IZ] THEN [DI CMD]
        [W1]J[01122]_[W1]                       ;Ascii "DR" = 21122
        [W1]-[W5]_Y,
         IF CT [IZ] THEN [DR CMD]
        [W1]J[01126]_[W1]                       ;Ascii "DV" = 21126
        [W1]-[W5]_Y,
         IF CT [IZ] THEN [DV CMD]
        [W1]J[01311]_[W1]                       ;Ascii "EI" = 21311
        [W1]-[W5]_Y,
         IF CT [IZ] THEN [EI CMD]
        [W1]J[01326]_[W1]                       ;Ascii "EV" = 21326
        [W1]-[W5]_Y,
         IF CT [IZ] THEN [EV CMD]
        [W1]J[01322]_[W1]                       ;Ascii "ER" = 21322
        [W1]-[W5]_Y,
         IF CT [IZ] THEN [ER CMD]
.IF/FTSM
        [W1]J[04715]_[W1]                       ;Ascii "SM" = 24715
        [W1]-[W5]_Y,
         IF CT [IZ] THEN [SM CMD]
.ENDIF/FTSM
.IF/FTZM
        [W1]J[06515]_[W1]                       ;Ascii "ZM" = 26515
        [W1]-[W5]_Y,
        IF CT [IZ] THEN [ZM CMD]
.ENDIF/FTZM
.ENDIF/FTFCSL

;Here if user typed an invalid command
CMDERR URC:
        CALL [CMDBUF FLUSH]                     ;Done with CMD buffer
        J[ERR.URC]_[W1]                         ;Unrecognized command
        GOTOP [CMDERR]

CMDERR NWR:
        J[ERR.NWR]_[W1]                         ;Error code (not while running)
        GOTOP [CMDERR]

CMDERR NXA:
        J[ERR.NXA]_[W1]                         ;Error code (nonexistent adr)
        GOTOP [CMDERR]

CMDERR E MER:
        CALL [PUT CMR NUM]                      ;Type error status
        CALL [PUT CMR SPACE]
        [MB]_[W1],                              ;Type data next
         GOTO [CMDERR MER]

CMDERR MER:
        CALL [PUT CMR NUM]                      ;Type error status
        J[ERR.MER]_[W1]                         ;Error code (memory error)
        ;GOTOP [CMDERR]

CMDERR: J[0103]_[W6]                            ;Ascii "C"
        [W1]_[W5],                              ;Save error code
        CALL [PUT ? W6]
        SWAP [W5]_[W1],
         CALL [P6DNUM]                          ;Type (6 digit) error number
        GOTOP [CMD DONE 2]


CMD DONE:
        CALL [CMDBUF FLUSH]                     ;Done with CMD buffer
CMD DONE 2:
        J[CMDFLG]_RAMFILE ADR,POP               ;Address command flags
        RAMFILE_[W1],POP                ;Get flags
        [BIT4]&[W1]_Y,                          ;(F.USR) Check user mode
        IF CT [IZ] CALL [PUT CMR PROMPT]
CMD9:

;Here when command has been executed

CMD PRSE8:
        ZERO_[W1],CALL [SET INT RCOVR]          ;Clear interrupt recovery
        ZERO_[W1],                              ;Clear page fail
         CALL [SET PF ME RCOVR]                 ; and mem err recovery
        GOTOP [CONSOLE]

;Here to get a char from a command line, skiping leading blanks
; Returns with character in W1
GET CMD CHX:
        CALL [GET CMD CHR]
        J[040]_[W2]
        [W1]-[W2]_Y,
         IF CT [IZ] THEN [GET CMD CHX]
        RETURN

;Here to get a number from a command line
; Returns clears UZ if number is found, number in W1
GET CMD NUM:
        ZERO_[W5],#1_UZ,                        ;Build number here
         CALL [GET CMD CHX]                     ; Get 1st nonblank char from command
GCN 2:  J[067]_[W2]                             ; Ascii '7'
        [W2]-[W1]_Y,
         IF CT [IN] THEN [GCN 4]
        J[060]_[W2]                             ;Ascii '0'
        [W1]-[W2]_A,
         IF CT [IN] THEN [GCN 4]
        #4*[W5]_B,#0_UZ                         ;Clear UZ (we got a num)
        #2*[W5]_[W5]
        [W1]+[W5]_B,
         CALL [GET CMD CHR]
        GOTO [GCN 2]

GCN 4:  CALL [BKUP CMD TKR]                     ;Backup command buffer taker
        [W5]_[W1],                              ;Copy result
         RETURN                                 ; and dismiss


;Here to type number on CTY
PUT CMR NUM:
        CALL [P6DNUM]                           ;Type first half
        J[054]_[W1]                             ;Ascii ","
        CALL [PUT CMR CHR]
        J[X1]_RAMFILE ADR
        RAMFILE_[W1],                           ;Get rest of number back
         GOTO [P6DNUM]                          ;Type 2nd half

;Here to type a six digit octal number on CTY
P6DNUM: J[6]_[W6]                               ;Keep digit counter in W6
        J[X1]_RAMFILE ADR
P6DNM2: J[2]_CTR
P6DNM3: ROL [W1]_[W1],ALU_RAMFILE,              ;Rotate left thrice
        LOOP [P6DNM3]
        J[7]_[W2]                               ;Mask for number
        [W2]&[W1]_F,F_Q FJ[060]_[W1]            ;Mask number to 3 bits
        Q+[W1]_[W1],                            ;Convert octal to ascii
        CALL [PUT CMR CHR]                      ; and print
        J[X1]_RAMFILE ADR                       ; and address word
        [K -1]+[W6]_B,IX_MX                     ;Count digits typed
        RAMFILE_[W1],                           ;Get number back again
         IF NOT CT [MZ] THEN [P6DNM2]
        RETURN

;Here to type "^X"
;  call with J[x]_[W6]
PUT CNTRL W6:
        J[0136]_[W1]                             ;Ascii "^"
PUTXW6:
        CALL [PUT CMR CHR]
        [W6]_[W1],
        GOTO [PUT CMR CHR]

;Here to type "?x"
; Call with J[x]_[W6]
PUT ? W6:
        CALL [PUT CMR CRLF]                     ;Begin with a flourish
        J[034]_[W1]                             ;Ascii "^\\"
        CALL [PUT CMR CHR]                      ;Type it for John Kirchoff
        J[077]_[W1]                             ;Ascii "?"
GOTO [PUTXW6]

;Here to type a "/" followed by a " "
PUT CMR SLSH:
        J[057]_[W1]                             ;Ascii "/"
        CALL [PUT CMR CHR]

PUT CMR SPACE:
        J[040]_[W1]                             ; Ascii " "
        GOTO [PUT CMR CHR]

;Here to type "<CR><LF>KT20>"
PUT CMR PROMPT:
        CALL [PUT CMR CRLF]                     ;Begin with a flourish
        J[CMDTKR]_RAMFILE ADR                   ;Address command taker
.IF/FTCRAM
        RAMFILE_[W1]                            ;If already have command
        [W1]_[W1],                              ;Let latches go
         IF NOT CT [IZ] RETURN                  ; do not prompt
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[W1],                           ;If already have command
         IF NOT CT [IZ] RETURN                  ; do not prompt
.ENDIF/FTCRAM
        J[0113]_[W1]                            ;Ascii "K"
        CALL [PUT CMR CHR]
        J[0124]_[W1]                            ;Ascii "T"
        CALL [PUT CMR CHR]
        J[062]_[W1]                             ;Ascii "2"
        CALL [PUT CMR CHR]
        J[060]_[W1]                             ;Ascii "0"
        CALL [PUT CMR CHR]
        J[076]_[W1]                             ;Ascii ">"
        GOTO [PUT CMR CHR]

;Here to type a <CR><LF>
PUT CMR CRLF:
        J[015]_[W1]
        CALL [PUT CMR CHR]
        J[012]_[W1]
        ;CALL [PUT CMR CHR]
        ;RETURN

;Here to type command responses on CTY
PUT CMR CHR:
        J[CMDFLG]_RAMFILE ADR                   ;Address command flags
        J[F.O]_[W2]                             ;Flag for we are flushing output
        RAMFILE_Y,[W2]_F,Y_[W2] F_Q             ;Get flags
        Q&[W2]_Y,IF NOT CT [IZ] RETURN          ;If flushing we are done
        J[CMRPTR]_RAMFILE ADR                   ;Address putter for CMRBUF
        J[CMRBUF END]_[W2]                      ;last location in CMRBUF
        RAMFILE_[W3]                            ;Get putter
        [W2]-[W3]_Y,                            ;If full can not put in
         IF CT [IZ] RETURN
        CALL [CMB NXT]                          ;Adjust pointer
        [W2]_RAMFILE                            ;Write byte into ramfile
        J[CMRTKR]_RAMFILE ADR                   ;Address taker
.IF/FTCRAM
        RAMFILE_[W1]                    ;Get taker
        [W1]_[W1],                              ;Let latches go
        IF CT [IZ] CALL [CKR PTR RESET]
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[W1],                   ;Get taker
         IF CT [IZ] CALL [CMR PTR RESET]
.ENDIF/FTCRAM
        ZERO_[W6 LH],                           ;Cty is line 0
         GOTO [SET PCI TXEN]                    ;Start transmitter

;Here to put characters in the command buffer

;With 7bit char in Q
CONSOLE CHAR:
        Q_[W1],                                 ; Flush nulls
         IF CT [IZ] THENP [PCI INT CLR]
        J[003]_[W2]                             ; Ascii "C"
        Q-[W2]_Y,
         IF CT [IZ] THEN [CNTRL C U]
        J[017]_[W2]                             ; Ascii "^0" = 17
        [W2]-[W1]_A,
         IF CT [IZ] THEN [CNTRL O]
        [W2]+2_B,
        IF CT [IZ] THEN [CNTRL Q]               ;Ascii "^Q" = 21 = Xon
        [W2]+2_B,
        IF CT [IZ] THEN [CNTRL S]               ;Ascii "^S" = 23 = Xoff
        J[CMDTKR]_RAMFILE ADR                   ;Address command taker
.IF/FTCRAM
        RAMFILE_[W3]                    ;Get taker
        [W3]_[W3],                              ;Let latches go
         IF NOT CT [IZ] THEN [TYPE AHEAD]       ; Ignore type ahead
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[W3],                   ;Get taker
        IF NOT CT [IZ] THEN [TYPE AHEAD]        ; Ignore type ahead
.ENDIF/FTCRAM
.IF/FTCTLR
        [W2]+[K -1]_Y,                          ; Ascii "^R" = 22
        IF CT [IZ] THEN [CNTRL R]
.ENDIF/FTCTLR
        [W2]+2_B,                               ;Ascii "^U" = 25
         IF CT [IZ] THEN [CNTRL C U]
        J[032]_[W2]                             ;Ascii "^Z"
        Q-[W2]_Y,
         IF CT [IZ] THEN [CNTRL Z]
        J[0177]_[W2]                            ;Ascii "rubout" = 177
        Q-[W2]_Y,                               ;Check for character was a rubout
        IF CT [IZ] THEN [CMD RUBOUT]
        J[CMDPTR]_RAMFILE ADR                   ;Address CMDBUF putter
        J[CMDBUF END]_[W2]                      ;Last location in CMDBUF
        RAMFILE_[W3]                            ;Get putter
        [W2]-[W3]_Y,                            ;If buffer is full stop
         IF CT [IZ] THEN [REFUSE CHAR]          ; accepting chars
        J[015]_[W2]                             ;Carriage return
        [W1]-[W2]_Y,
         IF CT [IZ] THEN [CMDC 2]
        J[012]_[W6]                              ;Ascii <LF>
        [W6]-[W1]_Y,
         IF NOT CT [IZ] THEN [CMDC 3]

;Here when char is <CR> or <LF>
CMDC 2: [W2]_[W1],                              ;Put <CR> in CMD buffer
         CALL [PUT CMDBUF]
        CALL [ENABLE PARSE]
        CALL [PUT CMR CRLF]                     ;End echo with <CR><LF>

CMDC X: IF [NOT RUN] THENP [PCI INT CLR]
.IF/DEBUG3
        J[POOP FLAG]_RAMFILE ADR
        ZERO_Y,ALU_RAMFILE
.ENDIF/DEBUG3
        ZERO_[W1],CALL [SET PF RCOVR]
        [PXCT]_[PI REG],Y_2914 STATUS,          ;Restore previous level
         GOTO [CMD PRSEX]                       ;This is not really an int

ENABLE PARSE:
        J[CMDTKR]_RAMFILE ADR                   ;Point to command taker
        GOTO [CMD PTR RESET]                    ;We can parse now

CMDC 3: [W1]_[W6],                              ;Save character
        CALL [PUT CMDBUF]                       ; And put in CMDBUF
        [W6]_[W1],                              ;Then echo the char
        GOTOP [PUT W1&DISMISS]                  ;Type W1 then dismiss int

;Here for typeahead
TYPE AHEAD:
        J[CMDRPT]_RAMFILE ADR                   ;Address repeat counter
        ONES_F,F_Y,ALU_RAMFILE                  ;typeahead kills repeat
REFUSE CHAR:
        J[007]_[W1]                             ;Ascii "^G"

PUT W1&DISMISS:
        CALL [PUT CMR CHR]
        GOTOP [PCI INT CLR]

;Here to process a rubout
CMD RUBOUT:
        J[CMDPTR]_RAMFILE ADR,                  ;Address putter
        [K 777]_Q
        RAMFILE_[W1]                    ;Get command putter
        Q&[W1]_F,                               ;Leave only ramfile adr in Q
        F_Q FJ[CMDBUF-1]_[W2]
        [W2]-[W1]_Y,                            ;See if any characters to delete
         IF CT [IZ] THENP [PCI INT CLR]         ; Nothing does not echo
        CALL [BKUP POINTER]                     ;Backup pointer
        J[0134]_[W1]                            ;Ascii "\"
        GOTOP [PUT W1&DISMISS]                  ;Type W1 then dismiss int

.IF/FTCTLR
;Here for a "R
CNTRL R:
        J[CMRTKR]_RAMFILE ADR                   ;Address response taker
.IF/FTCRAM
        RAMFILE_[W2]                    ;When typing ignore
        [W2]_[W2],                              ;let latches go
         IF NOT CT [IZ] THENP [PCI INT CLR]
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[W2],                   ;When typing ignore
         IF NOT CT [IZ] THENP [PCI INT CLR]
.ENDIF/FTCRAM
        J[0122]_[W6]                            ;Put "R" in W6
        CALL [PUT CNTRL W6]                     ;Type "^R"
        CALL [PUT CMR PROMPT]                   ;Retype prompt
;copy CMD buffer to CMR buffer
        CALL [ENABLE PARSE]
        GOTO [CR4]                              ;Be sure there is anything to do
CR2:    CALL [GET CMD CHR]
        CALL [PUT CMR CHR]                      ;Copy byte to CMR buffer
CR4:    J[CMDPTR]_RAMFILE ADR                   ;Address putter
        RAMFILE_[W2]
        J[CMDTKR]_RAMFILE ADR                   ;Address taker
        RAMFILE_[W1]
        [W1].XOR.[W2]_Y,
         IF NOT CT [IZ] THEN [CR2]
        ZERO_Y,ALU_RAMFILE,                     ;Reset CMD taker
        GOTOP [PCI INT CLR]
.ENDIF/FTCTLR

;Here for a ^\
CNTRL BKSLSH:

;Here for ^C or ^U
CNTRL C U:
        J[0100]_[W6]                            ;To convert "^C" to "C"
        Q+[W6]_[W6],
         CALL [CMD&CMR FLUSH]                   ;Flush command buffer
        [BIT4]_F,FJ[F.O!F.S]_[W1]               ; (F.USR) Flags to clear
        CALL [CLEAR CMDFLG]
        CALL [PUT CNTRL W6]                     ;Type ^C or ^U
        CALL [PUT CMR PROMPT]
        ZERO_[W1],CALL [SET INT RCOVR]          ;Clear interrupt recovery
        GOTOP [PCI INT CLR]                     ;Dismiss interrupt

;Here to turn off F.O (the control 0 flag)

F.O CLEAR:
        J[F.O]_[W1]                             ;Flags to clear for new command
        GOTO [CLEAR CMDFLG]

;Here for ^O
CNTRL O:
        CALL [CMRBUF FLUSH]                     ;Flush command response buffer
        J[0117]_[W6]                            ;Ascii "O"
        CALL [PUT CNTRL W6]                     ;Type ^O
        J[CMDFLG]_RAMFILE ADR                   ;Address ramfile word
        J[F.O]_[W1]                             ;Flag we are flushing output
        RAMFILE_Y,[W1]_F,Y_[W1] F_Q             ;Get word from ramfile
        Q.XOR.[W1]_F,F_Y,ALU_RAMFILE,           ;Set/clear flag
         GOTOP [PCI INT CLR]                    ;Dismiss interrupt

;Here to clear a flag in the CKDFLG word
CLEAR CMDFLG:
        J[CMDFLG]_RAMFILE ADR                   ;Address ramfile word
        RAMFILE_Y,Y_[W1] F_Q,           ;Get old flag word
         COMPLEMENT [W1]_F
         Q&[W1]_Y,ALU_RAMFILE,                  ;Clear flag
        RETURN

;Here for a ^S (Xoff) command

CNTRL S:
        J[F.S]_[W1]                             ;Flag to set
        CALL [SET CMDFLG]                       ; Set it
        GOTOP [PCI INT CLR]

;Here to set a flag in the CMDFLG word

SET CMDFLG:
        J[CMDFLG]_RAMFILE ADR                   ;Address ramfile word
        RAMFILE_Y,[W1]_F,Y_[W1] F_Q     ;Get old flag word
        Q.OR.[W1]_Y,ALU_RAMFILE,                ;Set flag
         RETURN

;Here for a ^Z
CNTRL Z:
        IF [NOT RUN] THENP [PCI INT CLR]        ;No user mode if stopped
        J[0132]_[W6]                            ;Ascii "Z"
        CALL [PUT CNTRL W6]                     ;^Z
        [BIT4]_[W1],                            ;(F.USR) User mode
         CALL [SET CMDFLG]                      ; Set flag
        ;GOTO [CNTRL Q]                         ;Also clear XOF flag

;Here for a ^Q (Xon)
CNTRL Q:
        J[F.S]_[W1]                             ;Flag to clear
        CALL [CLEAR CMDFLG]
        CALL [SET PCI TXEN]                     ;Start transmitter again
        GOTOP [PCI INT CLR]                     ;Dismiss interrupt


;Here to flush command and command response buffer

CMD&CMR FLUSH:
        CALL [CMRBUF FLUSH]                     ;First flush the response buffer
        ;GOTO [CMDBUF FLUSH]

;Here to flush command buffer
CMDBUF FLUSH:
        J[CMDTKR]_RAMFILE ADR
        ZERO_Y,ALU_RAMFILE                      ;Clear taker
        J[CMDRPT]_RAMFILE ADR                   ;Address repeat counter
        ZERO_Y,ALU_RAMFILE                      ;Clear repeat counter
        J[CMDPTR]_RAMFILE ADR

CMD PTR RESET:
        J[CMDBUF-1]_[W1]                        ;Adr of 1st word-1 of buffer
        [W1]_RAMFILE,                           ; Initialize putter
        RETURN

;Here to flush command response buffer

CMRBUF FLUSH:
        J[CMRTKR]_RAMFILE ADR
        ZERO_Y,ALU_RAMFILE                      ;Clear taker
        J[CMRPTR]_RAMFILE ADR

CMR PTR RESET:
        J[CMRBUF-1]_[W1]                        ;Adr of 1st word-1 of buffer
        [W1]_RAMFILE,                           ;Initialize putter
        RETURN

;Routine to put a byte into the ramfile

; Call with     [W1] = char to put
;      Will first increment pointer than store indirect it
PUT CMDBUF:
        J[CMDPTR]_RAMFILE ADR                   ;Address putter for command buffer
PUT CMB:
        CALL [CMB NXT]                          ;Put byte in ramfile word
        [W2]_RAMFILE,                           ;Put word back in ramfile
        RETURN

;Here to get a char from a command line

GET CMD CHR:
        J[CMDTKR]_RAMFILE ADR                   ;Address command char taker
        ;GOTO [CMS NXT]                         ;Advance to next byte

;Get or prepare to put next byte in ramfile CMD or CMR buffer
; Call  J[taker or putter]_RAMFILE ADR
;       _[W1]   ;Byte to be stored
; returns
;       [W1]    ;byte from ramfile
;       [W2]    ;Ramfile word with byte inserted

CMB NXT:
        RAMFILE_[W2]                            ;Get current pointer
        [K -1.0]+[W2]_B,                        ;Next byte adr
         IF NOT CT [IN] THEN [CMBP4]
        J[4]_[W3]                               ;First byte is number 4
        SWAP [W3]_[W2 LH]                       ;Put byte number in LH
        [W2]+1_[W2 RH]                          ;Next ramfile adr
CMBP4:  [W2]_RAMFILE,                           ;Store updated pointer
        Y_RAMFILE ADR                           ; and address buffer
        J[0117]_[W3]
        [W3]&[W1]_F, Y_[W1] F_Q,                ;Get mask for data
         RAMFILE_Y,                             ;Get word from ramfile
         GOTO [CMBP7]
CMBP5:  LRS [W1]_[W1]                           ;Shift ramfile word right
        LLSC [W3]_[W3],                         ;Shift mask and byte left
         J[5]_CTR
CMBP6:  LRS [W1]_[W1]                           ;Shift ramfile word right
        LLSC [W3]_[W3],                         ;Shift mask and byte left
         LOOP [CMBP6]
CMBP7:  [K -1.0]+[W2]_B,
         IF NOT CT [IN] THEN [CMBP5]
         J[0117]_[W2]                           ;Get mask for data
        [W2]&[W1]_B                             ;Leave only data byte
        RAMFILE_[W2]                            ;Get ramfile word again
        [W3]BAR&[W2]_B                          ;Clear slot for byte
        Q.OR.[W2]_[W2],                         ;Add new byte
         RETURN

;Here to backup the command buffer taker

BKUP CMD TKR:
        J[CMDTKR]_RAMFILE ADR
        ;GOTO [BKUP POINTER]

;Here to backup a pointer
BKUP POINTER:
        J[4]_[W2]
        RAMFILE_[W1]
        SWAP [W1]_[W2 RH] F_Q,B[W2 RH]_F
        [W2]-Q_F,F_Y,IX_MX                      ;Test for overflow
        [BIT17]+[W1]_B,                         ;Previous byte number
         IF NOT CT [MZ] THEN [W1_RAMFILE]
        ZERO_[W1 LH]
        [K -1]+[W1]_B,                          ;Backup ramfile word
         GOTO [W1_RAMFILE]

.TOC 2, " A - Console Address Break Command"

;Here for a "Address Break" command

.IF/FTADRB
A CMD:  CALL [GET CMD NUM]
        J[AB IF]_RAMFILE ADR
        [W1]_RAMFILE,
         CALL [GET CMD NUM]
        J[AB RD]_RAMFILE ADR
        [W1]_RAMFILE,
         CALL [GET CMD NUM]
        J[AB WR]_RAMFILE ADR
        [W1]_RAMFILE,
         GOTO [CMD PRSE8]
.ENDIF/FTADRB

.TOC 2, " B - Console Bootstrap Command"

;Here for a B "Bootstrap" command

B CMD:  IF [RUN] THEN [CMDERR NWR]
        GOTO [CMD PRSE8]

.TOC 2, " C - Console Continue Command"

;Here for a CONTINUE command

C CMD:  IF [RUN] THEN [CMDERR NWR]
        SET LOCAL,CALL [GET CMD PC]             ;Try to get a PC from command
        [BIT4]_[W1],                            ; (F.USR) Console now in user mode
        CALL [SET CMDFLG]
        CALL [SET PCI TXEN]                     ;Start transmitter
        J[HALT CODE]_RAMFILE ADR
        ZERO_Y,ALU_RAMFILE,SET RUN,             ;We have not halted
         CALL [SET PI MASK]                     ; Enable interrupts
        GOTO [CMD PRSE8]

GET CMD PC:
        CALL [GET CMD NUM]                      ;Get suggested starting address
        IF CT [UZ] RETURN
        [W1]_[PC],                              ;Set new PC
        RETURN

.TOC 2, " D - Console Deposit Command"

;Here for a D "Deposit memory" command

D CMD:  ZERO_[W1],                              ;No int recovery routine
        CALL [GET EXM ADR],#0_UC                 ;Get adr to deposit
DN:     CALL [UNMAPPED WRITE]
.IF/FTFCSL
        CALL [GET CMD NUM]                      ;Get data
        [W1]_[MB],
         IF NOT CT [UZ] THEN [DN]
.ENDIF/FTFCSL
        GOTO [CMD PRSE8]

.IF/FTFCSL
JK CMD: CALL [GET JK NUM]                       ;Get adr to deposit into
        [MB]_[PMA],
         IF CT [UZ] THEN [CMDERR NEA]           ;Require address
JK L:   CALL [GET JK NUM]                       ;Get data to deposit
         IF CT [UZ] THEN [CMD PRSE8]
        J[EXM ADR]_RAMFILE ADR
        [PMA]_Y,ALU_RAMFILE,                    ;Save last adr deposited
        CALL [UNMAPPED WRITE]
        [PMA]+1_[PMA],                          ;Next adr
         GOTO [JK L]

;Here to get an "Asciized" number
GET JK NUM:
        ZERO_[MB], #1_UZ,
         CALL [GET CMD CHX]                     ;Get 1st nonblank char from command
JK 1:   J[075]_[W2]
        [W1]-[W2]_Y,
         IF CT [IN] THEN [GCN 4]
        J[0175]_[W2]
        [W1]-[W2]_Y,
         IF NOT CT [IN] THEN [GCN 4]
        [K 77]&[W1]_B,                          ;Strip extra bits
        J[2]_CTR
JK 2:   #4*[MB]_B,LOOP [JK 2]
        [W1]+[MB]_B,#0_UZ,
         CALL [GET CMD CHR]
        GOTO [JK 1]
.ENDIF/FTFCSL

.TOC 2, " E - Console Examine Memory Command"

;Here for a E "Examine memory" command

E CMD:  J[E CMD RCOVR]_[W1]                     ;Recovery routine for ints
        CALL [GET EXM ADR], #1_UC                ;Get memory adr to examine
E CMD RCOVR:
        [PMA]_[PMA],MEM START READ
        CALL [UNMAPPED READ]
EC 3:   [MB]_[W1],
        CALL [PUT CMR NUM]
        GOTO [CMD PRSE8]

;Here to set an address to examine or deposit
; Call   J[adr]_[W1]                            ; Interrupt recovery address
;        CALL [GET EXM ADR],#0_UC                ;for deposit commands
;        CALL [GET EXM ADR],l_UC                ;For examine commands
;        Returns adr in [E] & [PMA], (and for deposits data in MB)
GET EXM ADR:
        [W1]_Y                                  ;Set recovery routine
         IF NOT CT [IZ] CALL [SET INT RCOVR]    ; for interrupts
        J[CMDERR E MER]_[W1]                    ;Recovery routine for examines
        IF CT [UC] CALL [SET PF ME RCOVR]
        CALL [GET CMD NUM]                      ;Get adr to examine
        J[EXM ADR]_RAMFILE ADR
        IF NOT CT [UZ] THEN [GEA2]              ;If no adr use last
        RAMFILE_[W1],                           ;Get last adr used
         IF NOT CT [UC] THEN [CMDERR NEA]       ;Require address
GEA2:   [W1]_[E],ALU_RAMFILE,                   ;Save address in E and ramfile
         IF CT [UC] THEN [GEA6]                 ; Branch for examine
        [E]_[PMA],                              ;Save adr in PMA also
        CALL [GET CMD NUM]                      ;Get data
        [W1]_[MB],
         IF NOT CT [UZ] RETURN                  ;Require data
        ;GOTO [CMDERR NEA]
CMDERR NEA:
        J[ERR.NEA]_[W1]                         ;Error code (not enough args)
        GOTOP [CMDERR]

GEA6:   [E]_[PMA],                              ;Save adr in PMA also
         CALL [PUT CMR CRLF]                    ;Begin with a flourish
        [PMA]_[W1],                             ;Now type adr
         CALL [PUT CMR NUM]
        GOTO [PUT CMR SLSH]

.TOC 2, "DI - Console Deposit I/O Command"

;Here for an DI "Deposit I/O" command
.IF/FTFCSL
DI CMD: ZERO_[W1],                              ;No int recovery
         CALL [GET EXM ADR],#0_UC               ;Get adr to deposit
         [W1]_[MEM-OP],                         ;Put data in right register
        CALL [WRIOX]                            ;Try to do it
        IF CT [UOVR] THEN [CMDERR NXA]
        GOTO [CMD PRSE8]
.ENDIF/FTFCSL

.TOC 2, "EI - Console Examine IO Command"

;Here for an EI "Examine I/O" command
.IF/FTFCSL
EI CMD: ZERO_[W1],                              ;No int recovery
         CALL [GET EXM ADR],#1_UC               ;Get adr to examine
        CALL [RDIOX]                            ;Do read like RDIO
        IF CT [UOVR] THENP [CMDERR NXA]
        [MEM-OP]_[W1],                          ;Copy data
         CALL [PUT CMR NUM]                     ; Display data
        GOTO [CMD PRSE8]
.ENDIF/FTFCSL

.TOC 2, "DR - Console Deposit Ramfi1e Command"

;Here for an DR "Deposit Ramfile" command

.IF/FTFCSL
DR CMD: ZERO_[W1],                              ;No int recovery
        CALL [GET EXM ADR],#0_UC                 ;Get adr to examine
        [PMA]_Y,Y_RAMFILE ADR
DRC 3:  [MB]_RAMFILE,                           ; Deposit ramfile
         GOTO [CMD PRSE8]

.TOC 2, "ER - Console Examine Ramfile Command"

;Here for an ER command
ER CMD: ZERO_[W1],                              ;No int recovery
        CALL [GET EXM ADR],#1_UC                 ;Get adr to examine
        [PMA]_Y,Y_RAMFILE ADR                   ;Address ramfile
        RAMFILE_[W1],
        CALL [PUT CMR NUM]
        GOTO [CMD PRSE8]
.ENDIF/FTFCSL

.TOC 2, "DV - Console Deposit Virtual Command"

;Here for an DV "Deposit Virtual" command
.IF/FTFCSL
DV CMD: J[DV CMD RCOVR]_[W1],POP                ;Recovery routine for ints
        CALL [GET EXM ADR],#0_UC                 ;Get adr to examine
DV CMD RCOVR:
        SET GLOBAL,CALL [MEMORY WRITE]          ;Write virtual
        GOTO [CMD PRSE8]

.TOC 2, "EV - Console Examine Virtual Command"

;Here for an EV command
EV CMD: J[EV CMD RCOVR]_[W1]                    ;Recovery routine for ints
        CALL [GET EXM ADR],#1_UC                 ;Get adr to examine
EV CMD RCOVR:
        SET GLOBAL,CALL [MEM READ 0]            ;Read virtual
        GOTO [EC 3]                             ;Rest like E cmd
.ENDIF/FTFCSL

.TOC 2, " H - Console Halt Command"

;Here for a HALT cOMMand

H CMD:  ;IF [NOT RUN] THEN [CMDERR NWR]         ;This is silly if not running
        J[HALT CONSOLE]_[W1]                    ;Stopped because told to
SET HALT CODE:
        J[HALT CODE]_RAMFILE ADR
        [K 77]_Y,Y_2914 MASK,                   ;Stop interrupts
         IF [NOT RUN] THENP [WRITE HSB]
        [W1]_RAMFILE,CLEAR RUN,                 ;Save code and go type result
         GOTOP [WRITE HSB]

.TOC 2, " I - Console Initialize Command"

;Here for a Initialize command

I CMD:  IF [RUN] THEN [CMDERR NWR]
        CALL [SYS RESET]
        GOTO [CMD PRSE8]

SYS RESET:
        ZERO_[PC FLAGS],CLEAR USER              ;Initialize register
        ZERO_[EPT],CLEAR PAGED                  ;Initialize register
        ZERO_[UPT],SET LOCAL                    ;Initialize register
        ZERO_[SPT],CLEAR PXCT                   ;Initialize register

;Set up PROC REG
        J[#33B MASK]_RAMFILE ADR                 ;Want high order 3 bits on
.IF/FT10PAG
        RAMFILE_[W1],CLEAR TOPS20
.ENDIF/FT10PAG
.IFNOT/FT10PAG
        RAMILE_[W1],SET TOPS20
.IFNOT/FT20PAG
.ERROR 2, "FT10PAG=0 and FT20PAG=0.  Need to enable one or the other"
.ENDIF/FT20PAG
.ENDIF/FT10PAG
        FJ[0200]_[W1],                          ; Line PI level
        COMPLEMENT [W1]_F                       ; 700000,,200
        J[PROC REG]_RAMFILE ADR                 ;Address ramfile copy of proc reg
        [W1]_RAMFILE,CLEAR TRAP,
         CALL [RESET PI]
        GOTO [RESET IO]                         ;Perform an IO reset

.TOC 2, " R - Console Repeat Command"

;Here for a REPEAT command

REPEAT: CALL [GET CMD NUM]                      ;Get repeat count
        J[CMDRPT]_RAMFILE ADR                   ;Address repeat counter
        NEGATE [W1]_F,F_Q_Y,IX_MX,
         CALL [RAMFILE_W1]                      ;Get current value for counter
         [W1]+1_Y,ALU_RAMFILE,                  ;Update repeat counter
        IF CT [IZ IX_MX] THEN [CMD PRSE8]
        [W1]_Y,
         IF CT [IN] THEN [REPEAT 3]
        Q_Y,ALU_RAMFILE                         ;Reseed repeat counter
REPEAT 3:
        CALL [ENABLE PARSE]
        GOTO [CMD PRSE8]

RAMFILE_W1:
        RAMFILE_[W1],
         RETURN

.TOC 2, " S - Console Start Command"

;Here for a START command

S CMD:  IF [RUN] THEN [CMDERR NWR]
        CALL [SYS RESET]                        ;Reset lots of things
        GOTO [C CMD]                            ;Rest is like a C command

.TOC 2, "SH - Console Shut Down Command"

SH CMD: J[030]_[PMA]
        ONES_[MB],                              ;Write -1 in location 30
         CALL [UNMAPPED WRITE]
        GOTO [CMD PRSE8]

.TOC 2, "SI - Console Single Instruction Command"

SI CMD: IF [RUN] THEN [CMDERR NWR]
        SET LOCAL,CALL [GET CMD PC]             ;Try to pick up a PC
        ZERO_[W1],                              ;Memory errs & page fails
        CALL [SET PF ME RCOVR]                  ; are usual
        J[HALT CODE]_RAMFILE ADR                ;Address halt code
        J[HALT SI]_[W2]                         ;Single instruction halt
        J[SI I RCOVR]_[W1]
        [W2]_RAMFILE,                           ;Set Halt code
         CALL [SET INT RCOVR]
        CALL [SET PI MASK]                      ;Allow interrupts
        ZERO_[W1],                              ;Normal recovery for
        CALL [SET PF ME RCOVR]                  ; for mem errs & page fails
SI RCOVR:
        [PC]_Q_[E],                             ;Put PC in ram address & Q
        SPEC SEL/PAGE TABLE ENTRY,
        GOTOP [IFETCH 0]

;Here if got interrupted out of SI cmd
SI I RCOVR:
        [K -1]+[PC RH]_B,                       ;Backup PC
         GOTO [SI RCOVR]

;Here to set exit for interrupt service
SET INT RCOVR:
        J[INT RCOVR]_RAMFILE ADR                ;Address ramfile
        [W1]_RAMFILE,RETURN

.TOC 2, "SM - Console Start u-code Command"
;Here for a START u-CODE command

.IF/FTSM
SM CMD: CALL [GET CMD NUM]
        [W1]_Y,GOTO Y                           ;Go whither he asketh
.ENDIF/FTSH


.TOC 2, " T - Console Self Test Command"

;Here for a SELF TEST command

T CMD:  IF [RUN] THEN [CMDERR NWR]
        GOTO [TEST]

;Here to write [W1] into Ramfile location Q+1
RF WRITE:
        Q+1_F,F_Q_Y,Y_RAMFILE ADR,              ;Point Ramfile at right location
         GOTO [W1_RAMFILE]                      ;Write Ramfile

.IF/FTDIAG
;Here to load LEGAL SECTION, SECTION 0, AC REF, CONTEXT MATCH in W1
; Call with expected page table data in W2, expected latches in W3
RDPG LATCHES:

        CALL [TVR XX]                           ;Check data expected is obtained
        ZERO_[W1],
         IF [LEGAL SECTION] CALL [W1+1_W1]
        #2*[W1]_[W1],
         IF [SECTION 0] CALL [W1+1_W1]
        #2*[W1]_[W1],
         IF [AC REF] CALL [W1+1_W1]
        #2*[W1]_[W1],
         IF [CONTEXT MATCH] CALL [W1+1_W1]
        [W1].XOR.[W3]_Y,
        IF CT [IZ] RETURN
        [W3]_[W2],
         GOTO [ALU BROKE]

SET TOPS20 LATCH:
        SET TOPS20,RETURN
SET TRAP LATCH:
        SET TRAP,RETURN
SET PXCT LATCH:
        SET PXCT,RETURN
SET RUN LATCH:
        SET RUN,RETURN
SET LOCAL LATCH:
        SET LOCAL,RETURN

W1+1_W1:
        [W1]+1_[W1],                            ;Flag is set
        RETURN

;Here to initialize Q with first ramfile adr
TVR X0: J[01777]_[W1],Y_RAMFILE ADR              ;Highest adr in Ramfile
        [W1]_Q,RETURN

;Here to verify ramfile contents are correct
TVR XX: RAMFILE_[W1],
        IX_MX
TVR XY: [W1].XOR.[W2]_Y,
         IF CT [IZ] RETURN
        GOTO [RF BROKE]
.ENDIF/FTDIAG

.TOC 2, "ZM - Console Zero memory Command"

;Here for a Zero Kemory command
.IF/FTZM
ZM CMD: J[ZMC 5]_[W1]                           ;Routine for memory errors
        ZERO_[MB],
         CALL [SET PF ME RCOVR]
        [K -1]_[PMA]
ZM 10:  J[EXM ADR]_RAMFILE ADR
        [PMA]+1_[PMA],ALU_RAMFILE,
         CALL [UNMAPPED WRITE]
        [PMA]_[PMA],MEM START READ,
         CALL [UNMAPPED READ]
        [MB]_Y,IF CT [IZ] THEN [ZM 10]
        GOTO [CMDERR MER]

ZMC 5:  [K -1.0]&[W1]_Q                         ;Get only code
        Q.XOR.[BIT17]_F,F_Y,
         IF CT [IZ] THEN [CMD PRSE8]
        GOTO [CMDERR MER]
.ENDIF/FTZM

;Here on incorrect u-code dispatch
MCE:    ;GOTO [U-CODE ERR]

;Here on a horrible u-code problem
U-CODE ERR:
        J[HALT DSP]_[W1]                        ;Illegal u-code dispatch
        GOTOP [SET HALT CODE]

;Here if the ALU is broken
ALU BROKE:
;Here if the Ramfile (or addressing logic) is broken
; Bad data in W1, good data in W2, test I on Y bus
RF BROKE:
        [PXCT]_Q                                ;Test code

; W1 on A bus, W2 on B bus, test # on Y bus
BROKE9: R SEL/W1,B SEL/W2,#0_CO,Q+C_F,F_Y,
        GOTO [BROKE9]


.TOC "Write Halt Status Block"

;Here when ISP code halts
WRITE HSB:
        [K 77]_Y,Y_2914 MASK,POP                ;Disallow interrupts
        [K 7777.-1]&[PC]_B,POP                  ;Mask PC to 30 bits
        J[HSB PMA]_RAMFILE ADR,POP              ;Save PMA here
        [PMA]_RAMFILE,POP                       ;Save PMA
        J[HSB]_RAMFILE ADR                      ;Get adr of Halt Status Block
.IF/FTCRAM
        RAMFILE_[PMA].NRFRD/1
        [PMA]_[PMA],                            ;Let latches go
         IF CT [IZ] THEN [WHSB2]                ;No block = do not write
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[PMA],
         IF CT [IZ] THEN [WHSB2]                ;No block = do not write
.ENDIF/FTCRAM
        J[HSB MB]_RAMFILE ADR                   ;Save MB here
        J[HSB MER]_[W1]                         ;Recovery in case of memory errs
        [MB]_RAMFILE,
         CALL [SET MER]
        ZERO_[W1], IF [LOCAL] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [USER] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [PAGED] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [RUN] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [TOPS20] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [PXCT] CALL [W1+1_W1]
        #2*[W1]_[W1],IF [TRAP] CALL [W1+1_W1]
        [W1]_[MB],CALL [UNMAPPED WRITE]
        [W2]_[MB],CALL [UNMAPPED WRITE NEXT]
        [W3]_[MB],CALL [UNMAPPED WRITE NEXT]
        [W4]_[MB],CALL [UNMAPPED WRITE NEXT]
        [W5]_[MB],CALL [UNMAPPED WRITE NEXT]
        [W6]_[MB],CALL [UNMAPPED WRITE NEXT]
        [IR]_[MB],CALL [UNMAPPED WRITE NEXT]
        [PC]_[MB],CALL [UNMAPPED WRITE NEXT]

        [E]_[MB],CALL [UNMAPPED WRITE NEXT]
        J[HSB MB]_RAMFILE ADR                   ;Get saved MB
        RAMFILE_[MB],CALL [UNMAPPED WRITE NEXT]
        [AC-OP]_[MB],CALL [UNMAPPED WRITE NEXT]
        [MEM-OP]_[MB],CALL [UNMAPPED WRITE NEXT]
        [PXCT]_[MB],CALL [UNMAPPED WRITE NEXT]
        [K 77]_[MB],CALL [UNMAPPED WRITE NEXT]
        [K 777]_[MB],CALL [UNMAPPED WRITE NEXT]
        [K -1.0]_[MB],CALL [UNMAPPED WRITE NEXT]
        [PC FLAGS]_[MB],CALL [UNMAPPED WRITE NEXT]
        [AC-OP+1]_[MB],CALL [UNMAPPED WRITE NEXT]
        [MEM-OP+1]_[MB],CALL [UNMAPPED WRITE NEXT]
        [EPT]_[MB],CALL [UNMAPPED WRITE NEXT]
        [UPT]_[MB],CALL [UNMAPPED WRITE NEXT]
        [SPT]_[MB],CALL [UNMAPPED WRITE NEXT]
        J[HSB PMA]_RAMFILE ADR                  ;Get saved PMA
        RAMFILE_[MB],CALL [UNMAPPED WRITE NEXT]
        [TIME]_[MB],CALL [UNMAPPED WRITE NEXT]
        [PI REG]_[MB],CALL [UNMAPPED WRITE NEXT]
        [BIT4]_[MB],CALL [UNMAPPED WRITE NEXT]
        [BIT12]_[MB],CALL [UNMAPPED WRITE NEXT]
        [BIT17]_[MB],CALL [UNMAPPED WRITE NEXT]
        [C0!C1]_[MB],CALL [UNMAPPED WRITE NEXT]
        [K 7777.-1]_[MB],CALL [UNMAPPED WRITE NEXT]
        [K 407777.0]_[MB],CALL [UNMAPPED WRITE NEXT]
        [K -1]_[MB],CALL [UNMAPPED WRITE NEXT]
        J[HALT CODE]_[W5],                      ;Address halt code in ramfile
        Y_RAMFILE ADR
        J[9.]_[W6]                              ;Also want 9 more locations
        RAMFILE_[MB],
         CALL [UNMAPPED WRITE NEXT]
WHSB1:  [W5]+1_[W5],Y_RAMFILE ADR               ;Next ramfile location
        RAMFILE_[MB]
        ZERO_Y,ALU_RAMFILE,
         CALL [UNMAPPED WRITE NEXT]
        [K -1]+[W6]_B,
         IF NOT CT [IZ] THEN [WHSB1]

;Type <CR><LF>?H<halt code> <flags> <PC>
WHSB2:  ZERO_[W1],CALL [SET INT RCOVR]          ;In case was SI cmd
        [BIT4]J[F.O!F.S]_[W1],                  ;(F.USR) Flags to clear
         SET LOCAL
        CALL [CLEAR CMDFLG]
        J[0110]_[W6]                            ; Ascii "H"
        CALL [PUT ? W6]
        J[HALT CODE]_RAMFILE ADR
        RAMFILE_[W1],                           ;Get halt code from ramfile
         CALL [PUT CMR NUM]                     ; and type it
        CALL [PUT CMR SPACE]                    ;Type a space
        [PC FLAGS]_[W1],                        ;Type flags
        CALL [P6DNUM]
        CALL [PUT CMR SPACE]
        [PC]_[W1],
         CALL [PUT CMR NUM]
        GOTO [CONSOLE PROMPT]


;Here in case of memory errors while writing HSB

HSB MER:
        J[HALT HSBMER]_[W1]
        J[HALT CODE]_RAMFILE ADR
        [W1]_RAMFILE,
         GOTO [WHSB2]

.TOC "Instruction fetch"

IFETCH:
.IF/DEBUG2
        IF [GLOBAL] THEN [U-CODE ERR]
.ENDIF/DEBUG2
.IF/SH_N_TL
        CALL [SHOW&TELL]
.ENDIF/SH_N_TL
        [PC]_Q_[E],                             ;Put PC in ram address & Q
        SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT RUN] THENP [WRITE HSB]

IFETCH 0:
        Q&[K 777]_Q RAMFILE_[W1],               ;Put on page adr in Q
        CLEAR PXCT,IX_MX,                       ; Put page entry in W1
         IF [UNPAGED OR AC] THENP [IFETCH 1]
        Q.OR.[W1]_[PMA],                        ;Start memory
         MEM START READ,
         IF [CONTEXT MATCH] THENP [IFETCH 3]
IFETCH 05:
        [PC]+1_[PC RH],                         ;Increment PC
         CALL [MEM READ 0]
        GOTOP [IFETCH 4]

;Here if not paged or AC REF
IFETCH 1:
        [E]_[PMA],SPEC SEL/VMA,                 ;Address AC in Ramfile
        IF [AC REF] THENP [IFETCH 05]
        [E]_[PMA],MEM START READ                ;Start memory

;Here if not paged or paging done
IFETCH 3:
        [PC]+1_[PC RH],MEM HOLD,                ; Increment PC
         CHECK INTERRUPTS
        MEM_IR_[IR],SPEC SEL/XR                 ;Read memory into IR
                                                ; Set XR=0 and @ flops
        [IR]_[E RH],MEM HOLD,
         IF [NO BUS ERROR] THENP [IFETCH EFA]
        [K -1]+[PC RH]_B,                       ;Backup the PC
        GOTO [IFETCH 05]                        ; And try again

;Here on an XCT, PXCT, LUUO
IFETCH 4:
        [MB]_[IR],SPEC SEL/XR,                  ;Set XR-O and @ flops
         LOAD IR

;Here with SPEC SEL/XR to set XR=O and @ flags
IFETCH EFA:
        [IR]_[E RH],SEL AC+[0] ,                ;Y rh E rh
         IF [NOT (I OR XR)] D [OPERAND FETCH]   ;Dispatch on op code to get operands
        [IR]_Y,SPEC SEL/XR,                     ;Do effective adr calc
         CALL [EFA 2]
        SEL AC+[0],
         DISPATCH [OPERAND FETCH]               ;Dispatch on op code to get operands

;Here if instruction being done under PXCT

IFETCH PXCT:
        J[0400]_[PXCT RH]                       ;PXCT bit for effective adr calc
        [K 7777.-1]&[E]_B,SET LOCAL,
         CALL [SET PXCT CTXT]                   ;Set context
        [IR]_[E RH],SPEC SEL/XR                 ;Y rh_E rh
        IF [I OR XR] CALL [EFA 2]
        CALL [SET CURRENT CTXT]
        SEL AC+[0],                             ;Dispatch on op code to get operands
         DISPATCH [OPERAND FETCH]

.TOC "Effective Address Calculation"

;Here to do an effective address calculation
; Call:     x_[MB],SPEC SEL/XR
; Returns   adr in E
;           clobbers W1
EFA CALC:
        [MB]_[E RH],SET LOCAL,
         IF [NOT (I OR XR)] RETURN

EFA 2:  [K 407777.0]_Q RAMFILE_[W1],            ;Get index register
        IF [NOT INDEXED] THEN [FETCH IW]
        RAMFILE_[MB]
        Q&[W1]_Y,IX_MX,                         ;Check section # in IDX
         IF [SECTION 0] THEN [EFA LCL INDEX]
        [K -1.0]BAR&[E]_Q,                      ;Put E rh in Q
         IF CT [(MNxMOVR)!MZ] THEN [EFA LCL INDEX]
        Q+[W1]_[E],SET GLOBAL,                  ;IDX(6-35)+Y(18-35)_E(6-35)
        IF [NOT B BIT 18] THEN [EFA 4]
        [K -1.0]+[E]_B,                         ;Sign extend Y
        IF [NOT INDIRECT] RETURN
        GOTO [FETCH IW]
EFA 4:  IF [NOT INDIRECT] RETURN
        GOTO [FETCH IW]

EFA LCL INDEX:
        [W1]+[E RH]_B,                          ;Y rh+IDX rh_E rh
         SET LOCAL,
         IF [NOT INDIRECT] RETURN
        ;GOTO [FETCH IW]

FETCH IW:
        READ [E]                                ;Fetch indirect word
                                                ; and SPEC SEL/IW
.IFNOT/FT20PAG
        GOTO [EFA CALC]
.ENDIF/FT20PAG
.IF/FT20PAG
        RAMFILE_[W1],                           ;Get index register
         IF [SECTION 0] THEN [EFA CALC]
         CLEAR LOCAL,
        IF [ILLEGAL IW] THENP [PF X24]
        IF [LOCAL IW] THEN [EFA CALC]
        [MB]_[E],
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT (I OR XR)] RETURN
        [MB]+[W1]_Q,                            ;XR(6-35)+IW(6-35) Q
        IF [NOT INDEXED] THEN [FETCH IW]
        Q_[E],
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT INDIRECT] RETURN
        GOTO [FETCH IW]
.ENDIF/FT20PAG

.TOC "Operand Fetch"

;These routines fetch instruction operands
;       if single operand is put in MEM-OP
;       AC & mem operands are put in AC-OP and MEM-OP
;       IX_MX for MEM-OP
;       IX_UX for AC-OP

;Double AC fetch - AC_MEM-OP, AC+I_MEM-OP+1
DFETCH AC:
        RAMFILE_[MEM-OP],                       ;Fetch first AC
         IX_MX,                                 ; Latch IZ in MZ
         SEL AC+[1]                             ; Point RAMFILE at AC+1
        RAMFILE_[MEM-OP+1],                     ;Get 2nd AC from RAMFILE
         SEL AC+[0],                            ; Repoint RAMFILE at AC
         DISPATCH [INST EXCT]

;Double AC & Mem fetch
DFETCH AC&MEM:
        RAMFILE_[AC-OP],                        ;Get 1st AC
         SEL AC+[1]
        RAMFILE_[AC-OP+1],                      ;Get 2nd AC
        GOTO [DFETCH MEM]

;Double word fetch from memory
; Sets MX according to highorder operand
DFETCH MEM:
        [K 7777.-1]&[E]_F,F_Q_B,                ;Get 1st operand
         SPEC SEL/PAGE TABLE ENTRY,
         IF [PXCT] THEN [PXCT DFETCH]
        CALL [MEMORY READ]
        [MB]_[MEM-OP],                          ;Save 1st operand
         CALL [READ NEXT]
        [MB]_[MEM-OP+1],                        ;We do not need to backup E
         GOTO [DFM 8]                           ; because noone uses it again
PXCT DFETCH:
        J[0200]_[PXCT RH]                       ;Bit for this flavour PXCT
        CALL [SET PXCT CTXT]
        [K 7777.-1]&[E]_F,F_Q_B,                ;Get 1st operand
         SPEC SEL/PAGE TABLE ENTRY,
         CALL [MEMORY READ]
        [MB]_[MEM-OP],                          ;Save 1st operand
        CALL [READ NEXT]
        [MB]_[MEM-OP+1],
        CALL [SET CURRENT CTXT]
DFM 8:  [MEM-OP]_Y,IX_MX,SEL AC+[0],            ;Set flags
        DISPATCH [INST EXCT]

;Single AC and memory word fetch
FETCH AC&MEM:
        RAMFILE_[AC-OP],                        ;Get AC from RAMFILE
         GOTO [FETCH MEM]

;Single word fetch from memory and set MX according to data
FETCH MEM:
        [E]_Q_[PMA],                            ;Read memory operand if not PXCT
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEMORY READ]
        [MB]_F,F_Q_[MEM-OP],                    ;Copy to right reg and set flags
        IX_MX,SEL AC+[0],
         IF [NOT PXCT] D [INST EXCT]
        CALL [PXCT FETCH 200]                   ;Get data
        [MB]_F,F_Q_[MEM-OP],                    ;Copy to right reg and set flags
         IX_MX,SEL AC+[0],
         DISPATCH [INST EXCT]

;Single AC and memory word fetch
FETCH AC&MEM(W):
        RAMFILE_[AC-OP],                        ;Get AC from RAMFILE
         GOTO [FETCH MEM(W)]

;Single word fetch and verify writable from memory
FETCH MEM(W):
        [E]_Q_[E],                              ;Read memory operand if not PXCT
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEMORY READ]
        [MB]_F,F_Q_[MEM-OP],                    ;Copy to right reg and set flags
         IX_MX,
         IF [NOT PXCT] THEN [FM(W) 2]
        CALL [PXCT FETCH 200]                   ;Fetch data
        [MB]_F,F_Q_[MEM-OP],                    ;Copy to right reg and set flags
        IX_MX, SEL AC+[0]
FM(W) 2:
        B SEL/W1,SEL AC+[0],                    ;Check writable from paging ram
        IF [B BIT 3] D [INST EXCT]
        IF [UNPAGED OR AC] D [INST EXCT]
        CALL [M W XX]                           ;Try to make writable
        SEL AC+[0],DISPATCH [INST EXCT]

;Single AC fetch and immediate operand
FETCH AC&I:
        RAMFILE_[AC-OP],                        ;Get AC from ramfile
         GOTO [FETCH I]
; Immediate mode operation
FETCH I:
        SWAP [K -1.0]_[MEM-OP]                  ;Mask for immediate operand
        [E]&[MEM-OP]_F,F_Q_B,IX_MX,             ;Get immediate operand
         SEL AC+[0],
         DISPATCH [INST EXCT]

;Single AC fetch but do not set Mx flags
FETCH AC:
.IF/FAST
        RAMFILE_[MEM-OP],               ;Get AC from RAMFILE
        DISPATCH [INST EXCT]
.ENDIF/FAST

;Single AC fetch and set Kx flags
FETCH AC(MX):
        RAMFILE_[MEM-OP]                ;Get AC from RAMFILE
        [MEM-OP]_[MEM-OP],IX_MX,                ;Set Mx flags
         DISPATCH [INST EXCT]

;Fetch AC and Fetch IO word

FETCH AC&IO:
        RAMFILE_[AC-OP]                 ;Get AC from RAMFILE

; Fetch IO word
FETCH IO:
        CALL [RDIOX]                            ;Get data
        SEL AC+[0],                             ; Repoint RAMFILE at AC
         IF NOT CT [UOVR] D [DISPATCH 3]
        GOTO [IO PF]

;Here to do an IO write
; returns with UOVR if illegal
RDIOX:  [K 7777.-1]&[E]_B,#1_UOVR,              ;Strip extraneous bits
        CALL [VAL IO ADR]                       ;Validate IO address
        [E]_[PMA],START IO READ,                ;Send IO address
         IF CT [MN] THEN [RDIO TTY]
        IO_[MEM-OP]                             ;Perform transfer
        #0_UOVR,IF [NO BUS ERROR] RETURN
.IFNOT/FTCKBP
        IF [NOT MEM EXISTS] THEN [SET UOVR]
        IF [NOT MEM FAULT] RETURN
.ENDIF/FTCKBP
;Here to set the u-overflow flag
SET UOVR:
        #1_UOVR,RETURN                           ;Set flag and exit

;Here to validate IO address
;   Call with address in E
;       If tty returns IN, address in W6, TTYRCV in W1, 7 in W2
VAL IO ADR:
.IF/FTMBZ
        J[07760]_[W1]                           ;Build mask for address
        SWAP [W1]_[W1],#1_UOVR                  ;We are checking bits 6-13 of E
        [W1]&[E]_Y,                             ;If nonzero illegal
         IF NOT CT [IZ] THENP [VIA9]            ;If illegal POP, POPJ
.ENDIF/FTMBZ
        J[LNZSW]_[W1]                           ;First non tty adr
VIA9:   [E]-[W1]_Y,
         IF NOT CT [IN IX_MX] RETURN
        [E]_[W6],Y_RAMFILE ADR                  ;Address ramfile
        LRS [W6]_[W3],PUSH J[1]_CTR             ;Copy & shift address
        LRS [W3]_[W3],RFCT                      ;Shift right
        J[7]_[W2]
        [W2]BAR&[W6]_B                          ;Make adr of status word
        [W2]&[W3]_B                             ;Leave only line number in W3
        SWAP [W3]_[W6 LH]
        J[TTYRCV BITS]_[W1],                    ;Min legal address
        RETURN

;Here when reading TTY register
RDIO TTY:
        [E]-[W1]_F,F_Q_Y,
         IF CT [IN IX_MX] RETURN
        RAMFILE_[MEM-OP],                       ;Get data from ramfile
         IF CT [MZ] THEN [RDIOTM]
        #0_UOVR
        [W2]&[W6]_F,F_Q_Y,                      ;Leave only word offset
         IF NOT CT [IZ] RETURN                  ;If not reading status done

;Here if reading the status register
RDIOT0:
        CALL [RD PCI SR]
        J[0300]_[W2]                            ;Mask for SR7&SR6
        [W2]&[W1]_B,                            ;Leave only SR7&SR6
         CALL [SWAP W2_W2]
        [W2]BAR&[MEM-OP]_B,                     ;Clear old SR7&SR6
         CALL [SWAP W1_W1]
        [W1].OR.[MEM-OP]_B,
         RETURN

.IF/FTTTYF
        RAMFILE_[MEM-OP],#0_UOVR,               ;Get received char
         CALL [ZERO RAMFILE]
        [W1]BAR&[W6]_B,Y_RAMFILE ADR            ;Make adr of line block
        RAMFILE_[W5],                   ;Get current status
         CALL [CLR RDN]
        GOTO [SET PROC REG]                     ;Be sure int flags are correct
.ENDIF/FTTTYF

;Here to read TTYRCV BITS
RDIOTM: RAMFILE_[MEM-OP],#0_UOVR,
        RETURN

.TOC "User Instructions"

;Here for LUUOs have already been through CHK PC SECT

LUUO:   IF [SECTION 0] THEN [LUUO0]             ;Check PC section
        IF [EXEC] THEN [MUUO]
        J[0420]_[PMA]                           ;Offset into UPT for LUUO block
        [UPT]+[PMA]_B,MEM START READ,           ;Location which has block adr
         CALL [UNMAPPED READ]
        [MB]_[PMA],SET GLOBAL,                  ;Save adr in PMA
        CALL [SV UUO STS]
        WRITE [PMA]                             ;Write flags,code,ac
        [PC]_[MB],CALL [WRITE NEXT]             ;Write 30 bit PC
        [MEM-OP]_[MB],CALL [WRITE NEXT]         ;Write 30 bit E
        [E]+1_[E],                              ;Fetch new PC
        SPEC SEL/PAGE TABLE ENTRY,
         CALL [MEMORY READ]
        [MB]_[PC],SET LOCAL,
        GOTOP [IFETCH]

;Here if LUUO is done in section 0
LUUO0:  SWAP [IR]_[MB],                         ;Put opcode A in MB rh
        CALL [LUUO 2]
        SWAP [E]_[MB LH],                       ;Want E in RH
        CALL [SWAP MB_MB]
        J[040]_[E]
        [E]_[PMA],
         IF [EXEC] THEN [LUUOOE]
        WRITE [E]                               ;Save info
        [E]+1_Q_[E],                            ;Get instruction to execute
         SPEC SEL/PAGE TABLE ENTRY,
         CALL [MEMORY READ]
        GOTOP [IFETCH 4]
LUUOOE: [EPT]+[PMA]_B,                          ;Save opcode and E
         CALL [UNMAPPED WRITE]
        [PMA]+1_[PMA],MEM START READ,
         CALL [UNMAPPED READ]
        GOTO [IFETCH 4]

SWAP MB_MB:
        SWAP [MB]_[MB],                         ;Put Opcode in LH
         RETURN

;Here as part of MUUO or LUUO to put [flags t,opcd],[PC]_F, [E] in MB
; Strips PC to 30 bits, puts E in MEM-OP
SV UUO STS:
        SWAP [IR]_[MB],                         ;Put opcode A in MB rh
         CALL [LUUO 2]                          ;Put O,,opcode A in MB
        [PC FLAGS]_[MB LH]
        [K 7777.-1]&[PC]_B                      ;Strip PC to 30 bits
E_MEM-OP:
        [E]_[MEM-OP],SECTION SELECT             ;Preserve RH of AC
        [K 7777.-1]&[MEM-OP]_B,                 ;Strip extraneous bits
        IF [NOT AC REF] RETURN
        [PC]_Y,SECTION SELECT,                  ;Check PC section
        IF [GLOBAL] RETURN
        IF [SECTION 0] RETURN
        [BIT17]_[MEM-OP LH],                    ;Sect == 1 here
         RETURN

;Here to put O,,opcode A in MB
LUUO 2: J[037]_[W1]                             ;Get mask for OPcode and AC field
        [W1]BAR&[MB]_B,                         ;Clear extraneous bits
         RETURN

;                        TOPS20                             TOPS10
;       +-----------------------------------+ +----------------------------------+
;   424 | flags       | 0 | opcode | A | 00 | | opcode | AC | 00 |      E        |
;       +-----------------------------------+ +----------------------------------+
;   425 | 00 |       PC                     | | flags            |      PC       |
;       +-----------------------------------+ +----------------------------------+
;   426 | 00 |       E                      | | process context word             |
;       +-----------------------------------+ +----------------------------------+
;   427 | process context word              |
;       +-----------------------------------+

;Here for MUUOs
; Will do several 2910 pops just in case
MUUO:   J[0424]_[PMA],POP                       ;Offset into UPT for block
        [UPT]+[PMA]_B,                          ;Physical adr of block
        CALL [SV UUO STS]
.IF/FT20PAG
.IF/FT10PAG
        IF [TOPS20] THEN [MUUO 1]
.ENDIF/FT10PAG
.ENDIF/FT20PAG
.IF/FT10PAG
        SWAP [MB]_[MB]                          ;Other side please
        [E]_[MB RH],
         CALL [UNMAPPED WRITE]
        [PC FLAGS]_[MB]
        [PC]_[MB RH],
         CALL [UNMAPPED WRITE NEXT]
        CALL [GET CONTEXT WD]
        CALL [UNMAPPED WRITE NEXT]
        [PMA]+1_[PMA],                          ;Point to 427
        GOTO [MUUO 2]
.ENDIF/FT10PAG
;Here for TOPS20 MUUO
.IF/FT20PAG
MUUO 1: [K 7777.-1]&[PC]_B,                     ;Strip PC to 30 bits
         CALL [UNMAPPED WRITE]                  ;Write flags, op cd, ac
        [PC]_[MB],                              ;Write 30 bit PC
         CALL [UNMAPPED WRITE NEXT]
        [MEM-OP]_[MB],                          ; Write 30 bit E
         CALL [UNMAPPED WRITE NEXT]
        CALL [GET CONTEXT WD]                   ;Get context word next
        [PMA]_Q_[PMA],                          ;Write context word in block
         CALL [UNMAPPED WRITE NEXT]
.ENDIF/FT2OPAG
;Heree to get new PC on an MUUO
MUUO 2: ZERO_[PC FLAGS],                        ;Clear flags
         IF [EXEC] THEN [MUUO 4]
        J[4]_[W1],POP,SET EXEC
        [W1]+[PMA]_B,POP
        J[04000]_[W1]                           ;Bit for previous context user
        SWAP [W1]_[PC FLAGS]
MUUO 4: [PMA]+1_[PMA],MEM START READ,
        CALL [UNMAPPED READ]                    ;Get new PC
        [MB]_[PC],SET LOCAL,
         IF [TOPS20] THEN [IFETCH]
        [PC FLAGS].OR.[MB]_B,                   ;Add prev context user
         GOTO [MB_PC FLAGS]

;Here for DMOVNX
DMOVNX:
        #2*[MEM-OP+1]_Q                         ;Put low order bits in Q
        NEGATE Q_F,F_Q_Y,IX_MX                  ;Negate low order bits
        [MEM-OP]BAR+C_F,MC_C IX_UX,             ;Negate high order bits
         F_[MEM-OP]
        Q_F,LRS F_B,B SEL/MEM-OP+1,             ;Save loworder portion
         #0_SION #0_QION,
         IF NOT CT [MZ] D [OPERAND STORE]
        IF CT [UZ] THEN [SET C0!C1 STORE]
        IF NOT CT [UOVR] D [OPERAND STORE]
        GOTO [SET OV!C1!T1 STORE]

;Here after P&S SETUP for ADJBP
ADJBP0: [AC-OP]_[AC-OP+1],IX_MX,                ;Copy # of bytes to adjust
         IF [AC.EQ.0] THEN [TO NOWHERE]         ;In case was really IBP
        [W6]_Y,                                 ; Check for S=0
         IF CT [MN IX_MX] THEN [ADJ04]
        ZERO_[AC-OP],GOTO [ADJ06]               ;Set high order word
ADJ04:  ONES_[AC-OP]
ADJ06:  [K -1.0]BAR&[W5]_Q,                     ;Copy P
        IF CT [MZ IX_MX] THEN [ADJBP9]          ;If S=O done
ADJBP1: Q-[W6]_F,F_Q,
         IF NOT CT [IN] THEN [ADJBP1]
;Count bytes in word
        J[044]_[W1]
        ONES_[W3],IX_MX                         ;Count bytes in word here
ADJBP2: Q+[W6]_F,F_Q
        [W1]-Q_F,F_Y,
         IF CT [IN] THEN [ADJBP3]
        [W3]+1_[W3],IX_MX,                      ;Count bytes in word
        GOTO [ADJBP2]
ADJBP3: [AC-OP]_[AC-OP+1],                      ;Copy # of bytes to adjust
         IF CT [(MNxMOVR)!MZ IX_MX] THEN [SET NO DIVIDE]
        [W3]_[MEM-OP],IX_MX,                    ;Copy divisor
         CALL [DIVSUB]                          ;Get quotient in MEM-OP
        [MEM-OP+1]_Y,                           ;Test remainder
         IF CT [IZ IX_MX] THEN [ADJBP5]
ADJBP5: ROR [W5]_[AC-OP],PUSH J[4]_CTR
        ROR [AC-OP]_[AC-OP],                    ;Justify pointer in AC-OP
         RFCT
        J[04000]_[W1]
        SWAP [W1]_[W1],SEL AC+[0]
        [W1]&[AC-OP]_F,
         IF NOT CT [IZ] THEN [ADJBP6]
        [MEM-OP]+[AC-OP RH]_B,
         GOTOP [AC TO AC]
ADJBP6: CALL [READ NEXT]                        ;Get 2nd half of pointer
        [MB]+[MEM-OP]_B,SEL AC+[1]
        [K 7777.-1]&[MEM-OP]_B
        [K 7777.-1]BAR&[MB]_B
        [MEM-OP].OR.[MB]_Y,
         ALU_RAMFILE,SEL AC+[0]
        [AC-OP]_RAMFILE,SET LOCAL,
         GOTOP [IFETCH]

ADJBP9: SEL AC+[1],
         IF NOT CT [UZ] D [DISPATCH 4]          ;Dispatch if not global
        [MEM-OP+1]_RAMFILE,
        DISPATCH [DISPATCH 4]

;Here for IBP or ADJBP
ADJBP:  IF [AC.EQ.0] THEN [IBP0]
        ;GOTO [P&S SETUP]

.TOC 2, "Byte Instructions"

;
;       +------+------+-+-+----+-----------------+
;       |   P  |   S  |X|I| AC |        Y        |
;       +------+------+-+-+----+-----------------+
;        0    0 0    1 1 1 1  1 1               3
;        0    5 6    1 2 3 4  7 8               5
;Common setup routine for byte instructions
; Returns W5/P W6/S Q/S UZ set if global format

.IF/FTBYTE
P&S SETUP:
        #2*[MEM-OP]_[W5],                       ;Copy pointer to W5
        J[1]_CTR
P&S 2:  #4*[W5]_B,                              ;Shift left 2 at a time
         LOOP [P&S 2]
        #2*[W5]_Q                                ;Leave S left justified in Q
P&S 3:  ROL [MEM-OP]_[W5] ROL Q_Q,              ;Rotate pointer in W5, also rot Q
         J[4]_CTR
P&S 4:  ROL [W5]_[W5] ROL Q_Q,                  ;Rotate pointer in W5, also rot Q
         LOOP [P&S 4]
        [K 77]&[W5]_B                           ;Mask P to 6 bits
        Q&[K 77]_F,F_Q_[W6],                    ;Mask S to 6 bits
         IF [SECTION 0] THEN [P&S 5]
        [BIT12]&[MEM-OP]_Y,                     ;Check for local/global format
         IF CT [IZ] THEN [P&S 5]
        [E]+1_F,F_Q_[E RH],#1_UZ,                ;Make adr of 2nd half
         IF [LOCAL] THEN [P&S 6]
        Q_[E],GOTO [P&S 6]                      ;Propagate carry
;Here if EFA calc is from first word
P&S 5:  [MEM-OP]_Y,SPEC SEL/XR,                 ;Set AC and @ flags
        #0_UZ,J[EFA CALC]_CTR                    ; Load 2910 reg for subroutine call
;Here to do EFA calc for byte pointer
P&S 6:  IF CT [UZ] JSRP [FETCH IW]              ;Do EFA calc
        IF [NOT PXCT] THEN [P&S 64]
        J[0100]_[PXCT RH]
        CALL [PXCT FETCH]
        GOTO [P&S 66]
P&S 64: READ [E]                                ;Get word to write
P&S 66: J[BYTE MASK]_[W1]                       ;Base of mask for byte size
        [W1]+[W6]_Y,Y_RAMFILE ADR               ;Address mask for byte
P&S 7:  [K -1]+[W5]_Y,ALU_CTR, IX_MX            ;Check P for 0 & load ctr
        RAMFILE_[W2],SEL AC+[0]                 ;Get mask
         DISPATCH [DISPATCH 4]

;Setup routine for ILOB, IDPB, and IBP instructions
; Returns W5/P W6/S Q/S                 UZ set if global format

IP&S SETUP:
        [BIT4]&[PC FLAGS]_Y,                    ;Check first part done
        IF NOT CT [IZ] THEN [P&S SETUP]
IBP0:   #2*[MEM-OP]_[W5],                       ;Copy pointer to W5
         J[1]_CTR
IP&S 2: #4*[W5]_B,LOOP [IP&S 2]                 ;Shift left 2 at a time
        [W5]+[W5]_Q                             ;Put S left justified in Q
        [K 7777.-1]BAR&Q_F,F_Q_[W6]             ;Leave only S in Q
        [MEM-OP]-Q_F,F_[MEM-OP],                ; Increment pointer
         IF CT [IC] THEN [IP&S 3]
        JS[4]_[W1]                              ; Put 400000,,4
        [K 7777.-1]&[MEM-OP]_B,                 ;Clear old P
        PUSH J[2]_CTR
        ROR [W1]_[W1],RFCT                      ;Leave 440000,,0 in W1
        [W1].OR.[MEM-OP]_B                      ; Put 36. in P
        [MEM-OP]-Q_F,F_[MEM-OP],                ;Make pointer
         IF [SECTION 0] THEN [IP&S27]
        [BIT12]&[MEM-OP]_Y,
         IF CT [IZ] THEN [IP&S27]
        [E]+1_F,F_Q_[E RH],
         IF [LOCAL] THEN [IP&S24]
        Q_[E]                                   ;Propagate carry
IP&S24: READ [E]                                ;Fetch 2nd half of pointer
        [K 7777.-1]BAR&[MB]_Q                   ;Save non Y portion
        [MB]+1_[MB]                             ; Increment Y
        [K 7777.-1]&[MB]_B                      ;Strip non Y portion
        Q.OR.[MB]_[MB],                         ;Add non Y portion
         CALL [MEMORY WRITE]
        ;[MB]+1_[MB],                           ;Increment 2nd half of pointer
        ;CALL [MEMORY WRITE]
        [K -1]+[E RH]_F,F_Q_[E RH],             ;Make adr of 1st half of pointer
         IF [LOCAL] THEN [IP&S 3]
        Q_[E], GOTO [IP&S 3]                    ;Propagate carry
IP&S27: [MEM-OP]+1_[MEM-OP RH]                  ;Increment adr
IP&S 3: [MEM-OP]_[MB],
         CALL [MEMORY WRITE]                    ;Write updated pointer in memory
        [W6]_Q,                                 ;Load Q with S left justified
         DISPATCH [DISPATCH 3]                  ;IBP is done, otherwise continue
IP&S 5: [BIT4].OR.[PC FLAGS]_B,                 ;Set first part done
         GOTO [P&S 3]                           ; Rest 1ike P&S setup

;Here for LDB or ILDB after P&S SETUP, memory word in MB
LDB:    IF CT [MN] THEN [LDB5]                  ;Branch if P=0
        J[18.]_[W1]                             ;Half word shift
        [W5]-[W1]_Y,
         IF CT [IN IX_MX] THEN [LDB4]
        SWAP [MB]_[MB]                          ;Do first 18 shifts
        ZERO_[MB LH],                           ;Clear half
         IF CT [MZ] THEN [LDB5]
        [W5]-[W1]-1_F,F_Y,ALU_CTR               ;Load ctr with excess 18.
LDB4:   LRS [MB]_[MB],LOOP [LDB4]
LDB5:   [MB]&[W2]_Y,ALU_RAMFILE,                ;Mask to byte size
         GOTOP [TO NOWHERE CFPD]

;Here for DPB or IDPB after P&S SETUP, memory word in MB
DPB:    [W2]&[AC-OP]_B,                         ;Clear extra bits from byte
         IF CT [MN] THEN [DPB5]                 ; Branch if P=0
        J[18.]_[W1]                             ;Half word shift
        [W5]-[W1]_Y,
         IF CT [IN IX_MX] THEN [DPB3]
        SWAP [AC-OP]_[AC-OP]                    ;Do first 18 shifts
        ZERO_[AC-OP RH],                        ;Clear half
         CALL [SWAP W2_W2]                      ;Shift mask also
        ZERO_[W2 RH],                           ;Clear half of mask
         IF CT [MZ] THEN [DPB3]                 ; FIXME: Cant read code
.WARNING "Can not read the code in the previous line.  It is probably wrong"
        [W5]-[W1]-1_F,F_Y,ALU_CTR               ;Load ctr with excess 18.
DPB3:   [W2]_Q                                  ;Put mask in Q reg
DPB4:   LLS [AC-OP]_[AC-OP] LLS Q_Q,
         LOOP [DPB4]
        Q_[W2]                                  ;Get mask back from Q
DPB5:   [W2]BAR&[MB]_B,                         ;Clear old bits from mem word
        IF [NOT PXCT] THEN [DPB6]
        [AC-OP].OR.[MB]_B,                      ;Set new bits
        CALL [PXCT STORE]                       ;Write word back
        GOTO [TO NOWHERE CFPD]
DPB6:   [AC-OP].OR.[MB]_B,                      ;Set new bits
        CALL [MEMORY WRITE]                     ;Write word in memory
        ;GOTO [TO NOWHERE CFPD]
.ENDIF/FTBYTE
;Here when instruction done, clear first part done
TO NOWHERE CFPD:
        [BIT4]BAR&[PC FLAGS]_B,                 ;Clear 1st part done and exit
        SET LOCAL,GOTOP [IFETCH]

.TOC 2, "Floating Point Instructions"

;Format for floating point numbers is
; 0 1 2 3 4 5 6 7 8 9l0lll2l~14l5l6l7l8l9202l2223242526272829303l32333435
; | \              / \                                                  /
; |       |                                    + ---fraction
; |       + ---exponent (excess 200)
; + ---sign

;Here for FIX instruction
FIX:
.IF/FTFP
        #2*[MEM-OP]_[MEM-OP],
         IF NOT CT [MN] THEN [FIX 1]
        NEGATE [MEM-OP]_F,F_[MEM-OP]            ;Work with positive copy
FIX 1:  ROL [MEM-OP]_[MEM-OP],                  ;Copy operand to extract exponent
         PUSH J[6]_CTR
         ROL [MEM-OP]_[MEM-OP],                 ;Rotate exponent to rh of W1
        RFCT
        [K 777]&[MEM-OP]_Q,                     ;Get the exponent
         SET LOCAL
        [K 777]BAR&[MEM-OP]_B                   ;Strip exponent from number
        J[0242]_[W2]
        [W2]-Q_F,F_Y,ALU_CTR,IX_UX
        IF CT [UN] THEN [SET OV!T1 TRAP]
        [K -1]&[MEM-OP]_F,                     ; Position result
         LSRC_B,#0_SION SIO0_QION,
         IF CT [UZ] THEN [FIX 6]
FIX 5:  [K -1]&[MEM-OP]_F,                ;Position result
         LSRC_B,#0_SION SIO0_QION,
        LOOP [FIX 5]
FIX 6:  [MEM-OP]_RAMFILE,
        IF NOT CT [MN] D [OPERAND STORE]
        NEGATE [MEM-OP]_F,F_[MEM-OP],
         ALU_RAMFILE,
        DISPATCH [OPERAND STORE]
.ENDIF/FTFP

;Here for FIXR = fix and round
FIXR:
.IF/FTFP
        Q_Y,
         IF NOT CT [IN] THENP [IFETCH]
        [MEM-OP]+1_Y,ALU_RAMFILE,
         IF NOT CT [MN] THENP [IFETCH]
        [K -1]+[MEM-OP]_Y,ALU_RAMFILE,
         GOTOP [IFETCH]
        GOTO [TO AC]
.ENDIF/FTFP

;Here for FLTR = float and round
FLTR:   ;DISPATCH [OPERAND STORE]

;Here for FADx
FADX:   ;DISPATCH [OPERAND STORE]

;Here for FADRx
FADRX:  ;DISPATCH [OPERAND STORE]

;Here for FSBx
FSBX:   ;DISPATCH [OPERAND STORE]

;Here for FSBRx
FSBRX: ;DISPATCH [OPERAND STORE]

;Here for FMPx
FMPX:   ;DISPATCH [OPERAND STORE]

;Here for FMPRx
FMPRX: ;DISPATCH [OPERAND STORE]

;Here for FDVx
FDVX: ;DISPATCH [OPERAND STORE]

;Here for FDVRx
FDVRX: ;DISPATCH [OPERAND STORE]

.TOC "Full Word Data Transmission"

;Here for MOVEI

.IF/FAST
MOVEI:  [K -1.0]BAR&[E]_F,F_Y,                 ;Strip extra bits
        ALU_RAMFILE,SET LOCAL,
         GOTOP [IFETCH]

;Here for MOVSI
MOVSI:  SWAP [E]_[E],SEL AC+[0] ;Position bits
        [K -1.0]&[E]_Y,ALU_RAMFILE,
         SET LOCAL,GOTO [IFETCH]
.ENDIF/FAST

;Here for MOVSx (also some Hxx instructions)
MOVSX:  SWAP [MEM-OP]_[MEM-OP],
         DISPATCH [OPERAND STORE]

;Here for MOVMx
MOVMX:  IF NOT CT [MN] D [OPERAND STORE]
        ;GOTO [MOVNX]

;Here for MOVNx
MOVNX:  NEGATE [MEM-OP]_F,F_[MEM-OP],           ;Negate operand
         IF CT [IZ IX_MX] THEN [SET C0!C1 STORE]
        IF NOT CT [MOVR] D [OPERAND STORE]

SET OV!C1!T1 STORE:
        J[05002]_[W1],SET TRAP                   ;Set overflow, carry 1, and trap 1
        SWAP [W1]_[W1],
         CALL [#64*W1!PCF]
        SEL AC+[0],
         DISPATCH [OPERAND STORE]

.TOC 2, "Fixed Point Instructions"

;Here for ADDx
ADDX:   [AC-OP]+[MEM-OP]_B,                     ;Add AC & HEM
         IF CT [IOVR IX_MX] THEN [ADDXOV]
ADDX2:  IF CT [NOT MC] D [OPERAND STORE]        ;No carry means done
SET C0!C1 STORE:
        [C0!C1].OR.[PC FLAGS]_B,
         SEL AC+[0],
         DISPATCH [OPERAND STORE]

;Here for SUBx
SUBX:   [AC-OP]-[MEM-OP]_B,                     ;AC-MEM_MEM and then store
        IF CT [NOT IOVR IX_MX] THEN [ADDX2]

;Here if got overflow
ADDXOV: IF CT [NOT MC] THEN [SET OV!C1!T1 STORE]
SET OV!C0!T1 STORE:
        J[06002]_[W1],SET TRAP                  ;Set overflow, carry 0, and trap 1
        SWAP [W1]_[W1],
         CALL [#64*W1!PCF]
        SEL AC+[0],
         DISPATCH [OPERAND STORE]


;Here for MULx or IMULx
; Memory operand already in Q
.IF/FAST
MULX:   ZERO_[MEM-OP],J[33.]_CTR                ;Initialize work register
        TCM [AC-OP] [MEM-OP]                    ;Do shift and add
MULX 2: TCM [AC-OP] [MEM-OP],             ;Do shift and add
         LOOP [MULX 2]
.ENDIF/FAST
.IFNOT/FAST
MULX:   ZERO_[MEM-OP],J[34.]_CTR                ;Initialize work register
MULX 2: TCM [AC-OP] [MEM-OP]                    ;Do shift and add
         LOOP [MULX 2]
.ENDIF/FAST
        TCM COR [AC-OP] [MEM-OP]                ;Final shift and add
        [MEM-OP]_F,B SEL/MEM-OP,ALSC_B,         ;Shift product left
         SION_MC QION_SIO0 #0_QIO0,IX_MX         ; put carry out in MC
        Q_F, (MN F)RS_[MEM-OP+1],               ;Get low order portion
         IF CT [MN] D [OPERAND STORE]
        IF NOT CT [MC] D [OPERAND STORE]
        BIT0_[MEM-OP],                          ;Architecture says to do this
         CALL [SET OV!T1]                       ;Set overflow & trap 1
        BIT0_[MEM-OP+1],                        ;More architecture cyberkrud
        DISPATCH [OPERAND STORE]

;Here for IMULx after doing MULx
IMULX:  [MEM-OP]+1_[MEM-OP],                    ;In case high order portion neg
         IF CT [MZ IX_MX] THEN [IMULX4]
        IF NOT CT [MZ] CALL [SET OV!T1]         ;Set overflow if high order bits
IMULX4: [MEM-OP+1]_[MEM-OP],
         DISPATCH [DISPATCH 4]

;Here for IDIVx
IDIVX:  [AC-OP]_[AC-OP+1],                      ;Put argument in right place
         IF CT [IN] THEN [IDIVXN]
        ZERO_[AC-OP],GOTO [DIVX0]               ;Extend sign
IDIVXN: ONES_[AC-OP],GOTO [DIVX0]               ;Extend sign

;Here for DIVx
DIVX:   SEL AC+[1]                              ;Address low order portion
        RAMFILE_[AC-OP+1]
DIVX0:  [MEM-OP]_[W3],IX_MX,                    ;Copy divisor
         CALL [DIVSUB]
        DISPATCH [OPERAND STORE]

;Subroutine to do a divide
; Call with dividend in AC-OP, AC-OP+1, divisor in MEM-OP_W3,IX_MX
DIVSUB: [AC-OP]_[W2],                           ;Copy highorder dividend
        IF NOT CT [MN IX_MX] THEN [DIVX02]
        NEGATE [W3]_F,F_[W3]                    ;Make magnitude of divisor
DIVX02: [AC-OP+1]+[AC-OP+1]_F,F_Q,              ;Put loworder dividend in Q
         IF NOT CT [MN] THEN [DIVX04]
;Following 2 ins for KL10 compatible divide
        NEGATE Q_F,IX_UX                        ;Latch carry out of loworder
        [W2]BAR+C_F,UC_C,F_[W2]
;Following for non KL10 compatible
        ;[W2]BAR+C_F,#0_CO,F_[W2]
DIVX04: [W2]-[W3]_F,
        IF NOT CT [IN] THEN [SET NO DIVIDE]
        [AC-OP]_F,ASRC_B,B SEL/AC-OP,
         MN_SION SIO0_QION
.IF/FAST
        R SEL/MEM-OP,S SEL[AC-OP],
         #0_CO,ALU SP FUN/DLN,ALU_Y/YES,
         SION_QIO0 QION_SIO0,J[33.]_CTR
        TCDIV [MEM-OP] [AC-OP]_B
DIVX15: TCDIV [MEM-OP] [AC-OP]_B,
         LOOP [DIVX15]
.ENDIF/FAST
.IFNOT/FAST
        R SEL/MEM-OP,S SEL[AC-OP],
         #0_CO,ALU SP FUN/DLN,ALU_Y/YES,
         SION_QIO0 QION_SIO0,J[34.]_CTR
DIVX15: TCDIV [MEM-OP] [AC-OP]_B,
         LOOP [DIVX15]
.ENDIF/FAST
        TCDIV COR [MEM-OP] [AC-OP]_B
        [AC-OP]_[MEM-OP+1],                     ;Latch remainder sign
         IF CT [MN IX_UX] THEN [DIVX40]         ; Branch if dividend negative
        [MEM-OP]_Y,                             ;Latch sign of divisor
        IF NOT CT [UN IX_MX] THEN [DIVX90]      ;Positive remainder = OK
        IF CT [MN] THEN [DIVXR]
DIVXQ:  [MEM-OP]+[MEM-OP+1]_B                   ;Add divisor to remainoer
DIVXQ1: Q+[K -1]_[MEM-OP],                      ;Adjust quotient and store
         RETURN

;Here because dividend was negative
DIVX40: [MEM-OP]_Y,                             ;Latch sign of divisor
        IF CT [UZ IX_MX] THEN [DIVX90]          ;Remainder=O OK
        [MEM-OP+1]+[W3]_Y,                      ;Remainder vs divisor magnitude
         IF CT [UN IX_UX] THEN [DIVX46]         ;R=negative, check quotient
DIVX42: IF CT [MN] THEN [DIVXQ]                 ;Branch if divisor was negative
DIVXR:  [MEM-OP+1]-[MEM-OP]_A                   ;Subtract divisor from remainder
        Q+1_F,F_[MEM-OP],                       ;Adjust quotient and store
         RETURN

DIVX46: IF NOT CT [UZ] THEN [DIVX90]
        IF CT [MN] THEN [DIVXR]                 ;Branch if divisor was negative
        [MEM-OP]+[MEM-OP+1]_B,
         GOTO [DIVXQ1]

DIVX90: Q_[MEM-OP],                             ;Save quotient
         RETURN

SET NO DIVIDE:
        J[040]_[W1]                             ;Will become no divide
        SWAP [W1]_[W1],
        CALL [W1!PCF]
SET OV!T1 TRAP:
        CALL [SET OV!T1],SET LOCAL              ;Set overflow and trap1
        GOTOP [TRAP]

.TOC 2, "Double Precision Fixed Point Instructions"

;Here for DADD
DADD:   #2*[AC-OP+1]_[AC-OP+1],                  ;Adjust low order AC operand
        CALL [DADD4]                            ; and adjust low order mem operand
        [AC-OP+1]+[MEM-OP+1]_B,                 ;Add low order parts
         IX_MX
        [AC-OP]+[MEM-OP]+C_B,                   ;Add AC & MEM
         MC_C IX_MX
DADD2:  ASR [MEM-OP+1]_[MEM-OP+1],              ;Put sign on low order portion
        IF CT [MOVR] THEN [ADDXOV]              ;No carry means done
        IF CT [NOT MC] D [OPERAND STORE]
        [C0!C1].OR.[PC FLAGS]_B,
         DISPATCH [OPERAND STORE]

DADD4:  #2*[MEM-OP+1]_[MEM-OP+1],                ;Adjust low order mem operand
         RETURN

;Here for DSUB
DSUB:   #2*[AC-OP+1]_[AC-OP+1],                  ;Adjust low order AC operand
         CALL [DADD4]                           ; and adjust low order mem operand
        [AC-OP+1]-[MEM-OP+1]_B,                 ;Subtract low order parts
         IX_MX
        [AC-OP]-[MEM-OP]-1+C_F,F_B,             ;AC-MEM_MEM and then store
        MC_C IX_MX,
         GOTO [DADD2]

;Here for DMUL
DMUL:   ;DISPATCH [OPERAND STORE]

;Here for DDIV
DDIV:   DISPATCH [OPERAND STORE]

.TOC 2, "Shift and Rotate Instructions"

ASHC SETUP:
        [MEM-OP]_F,IX_MX                        ;Latch MN
        #2*[MEM-OP+1]_Q,                         ;Load Q with low order portion
         GOTO [ASH SETUP]

LSHC SETUP:
        [MEM-OP+1]_Q,                           ;Load Q with low order portion
        GOTO [ASH SETUP]

;Here for ASH, etc. setup
ASH SETUP:
        J[0377]_[W1],SET LOCAL                   ;Generate mask for extraneous bits
        [W1]&[E]_B,IX_UX,                       ;Strip extraneous bits
         IF [B BIT 18] THEN [ASHR SETUP]
        [K -1]+[E]_B,ALU_CTR                    ;Load counter
        SEL AC+[0],
         IF NOT CT [UZ] D [DISPATCH 3]
        SET LOCAL,GOTOP [IFETCH]

ASHR SETUP:
        [W1]-[E]_B,ALU_CTR                      ;Load counter
        SEL AC+[0],
        DISPATCH [DISPATCH 4]

;Here for ASH
ASH:    [MEM-OP]+[MEM-OP]_B,                    ;Shift left
         IX!UOVR_UX,LOOP [ASH]                  ; Latch overflow if any
        [MEM-OP]_RAMFILE,SET LOCAL,             ;Write AC
         IF NOT CT [UOVR] THENP [IFETCH]
        [MEM-OP]+[MEM-OP]_B,                    ;Shift off sign
         CALL [SET OV!T1]
        B[MEM-OP]_F,MN_SION SIO0_QION,
        LRS F_B,ALU_RAMFILE,
         GOTOP [TRAP]

ASHR:   ASR [MEM-OP]_[MEM-OP],                  ;Shift right
         LOOP [ASHR]
        [MEM-OP]_RAMFILE,                       ;Write AC
         SET LOCAL,
         GOTOP [IFETCH]

;Here for ASHC
ASHC:   ASRC [MEM-OP]_[MEM-OP]                  ;Shift right once
ASCH1:  R SEL/MEM-OP,S SEL[MEM-OP],             ;Shift left & latch overflow
         IX!UOVR_UX,
         #0_CO,ALU SP FUN/DLN,ALU_Y/YES,
        QION_SIO0 #0_QIO0,LOOP [ASCH1]
        LLSC [MEM-OP]_[MEM-OP]                  ;Shift left
        LLSC [MEM-OP]_[MEM-OP]                  ;Shift left
        MN_SION SIO0_QION,LSRC_B,               ;Shift right adding sign
         B[MEM-OP]_F,ALU_RAMFILE                ; Save AC
        SEL AC+[1]                              ;Address AC+1
        Q_F,LRS F_B,MN_SION SIO0_QION,
         B SEL/MEM-OP+1,ALU_RAMFILE,
         IF NOT CT [UOVR] THEN [IFETCH]
        GOTOP [SET OV!T1 TRAP]

;Here for an ASH shifting right

ASHCR:  ASRC [MEM-OP]_[MEM-OP],                 ;Shift right
         LOOP [ASHCR]
        [MEM-OP]_Y,ALU_RAMFILE,
         SEL AC+[1]
        Q_F,LRS F_B,MN_SION SIO0_QION,
         B SEL/MEM-OP+1,
         ALU_RAMFILE,
         GOTOP [IFETCH]

;Here for LSH
LSH:    #2*[MEM-OP]_[MEM-OP],
         LOOP [LSH]
        [MEM-OP]_RAMFILE,                       ;Write AC
         SET LOCAL,
         GOTOP [IFETCH]

LSHR:   LRS [MEM-OP]_[MEM-OP],                  ;Shift right
         LOOP [LSHR]
        [MEM-OP]_RAMFILE,                       ;Write AC
         SET LOCAL,
         GOTOP [IFETCH]

;Here for LSHC
LSHC:   LLSC [MEM-OP]_[MEM-OP],                 ;Shift left with Q
        LOOP [LSHC]
        Q_[MEM-OP+1],
         GOTO [D TO AC.0]
LSHCR:  LSRC [MEM-OP]_[MEM-OP],                 ;Shift right with Q
         LOOP [LSHCR]
        Q_[MEM-OP+1],
         GOTO [D TO AC.0]

;Here for ROT
ROT:    ROL [MEM-OP]_[MEM-OP],
         LOOP [ROT]
        [MEM-OP]_RAMFILE,                       ;Write AC
         SET LOCAL,
         GOTOP [IFETCH]

ROTR:   ROR [MEM-OP]_[MEM-OP],
         LOOP [ROTR]
        [MEM-OP]_RAMFILE,                       ;Write AC
         SET LOCAL,
        GOTOP [IFETCH]

;Here for ROTC
ROTC:   ROLC [MEM-OP]_[MEM-OP],                 ;Rotate left
         LOOP [ROTC]
        Q_[MEM-OP+1],
         GOTO [D TO AC.0]
ROTCR:  RORC [MEM-OP]_[MEM-OP],                 ;Rotate right
         LOOP [ROTCR]
        Q_[MEM-OP+1],
         GOTO [D TO AC.0]

;Register usage:
;       MEM-OP AC contents
;       AC-OP BLT 1imi t
;Here for BLT
BLT:    [K 7777.-1]&[E]_B                       ;Mask E to 30 bits
        [E]_[AC-OP],                            ;Copy final adr
         IF [PXCT] THEN [BLT PXCT]
.IF/FAST
        SWAP [MEM-OP]_[E RH]                    ;Make first address to read
        [E]_[W1]                                ;Copy section number
        [MEM-OP]_[W1 RH]                        ;Make destination adr
        [W1]-[E]-1_F,F_Y,                       ; Check for "Clear core" case
         IF CT [IZ] THEN [BLT+1]
.ENDIF/FAST
BLT 2:  SWAP [MEM-OP]_[E RH],                   ;Make adr of location to read
         CALL [MEM READ 0]                      ;Get word to transfer
        [MEM-OP]_[E RH],                        ;Make destination adr
         CALL [MEMORY WRITE]
        [E]-[AC-OP]_Y,SEL AC+[0],IX_MX
        [BIT17]+[MEM-OP]+1_F,F_B,               ;Increment pointer
         IF NOT CT [MN] THEN [TO NOWHERE]
        [MEM-OP]_Y,ALU_RAMFILE,                 ;Remember how far we got
         GOTO [BLT 2]

BLT PXCT:
        SWAP [MEM-OP]_[E RH],                   ;Make adr of loc to read
         CALL [PXCT FETCH 40]
        [MEM-OP]_[E RH],                        ;Make destination adr
         CALL [PXCT STORE 200]                  ; Copy data
        [E]-[AC-OP]_Y,SEL AC+[0],IX_MX
        [BIT17]+[MEM-OP]+1_F,F_B,               ;Increment pointer
         IF NOT CT [MN] THEN [TO NOWHERE]
        [MEM-OP]_Y,ALU_RAMFILE,                 ;Remember how far we got
         GOTO [BLT 2]

.IF/FAST
;Here for BLT [#,#+1]
BLT+1:  READ [E] ;Fetch first word in block
        [MEM-OP]_[E RH],                        ;Write next word
         CALL [MEMORY WRITE]
        GOTO [BLT 14]
BLT+1N: [BIT17]+[MEM-OP]+1_F,F_B,
         ALU_RAMFILE,
         CHECK INTERRUPTS
        [E]+1_F,F_Q_[E],
        SPEC SEL/PAGE TABLE ENTRY,
        CALL [MEM WRITE 1]
BLT 14: [AC-OP]-[E]-1_F,F_Y,
         SEL AC+[0],
        IF NOT CT [IN] D [DISPATCH 3]
        SET LOCAL,GOTO [IFETCH]
.ENDIF/FAST

.TOC 2, "Program Control Instructions"
;Here for AOBJX instructions
AOBJX:  [MEM-OP]+1_[MEM-OP RH]                  ; Increment RH of AC
        [BIT17]+[MEM-OP]_B,IX_MX,               ; Increment LH
         DISPATCH [DISPATCH 3]

;Here for JRST
JRST:   #2*[IR]_[W1],
         IF [AC.EQ.0] THEN [JXA]
        #4*[W1]_B,                               ;Keep shifting
         CALL [#2*W1_W1 LOAD IR]
        [K 7777.-1]&[PC]_B,                     ;Reduce PC to 30 bits
         SECTION SELECT,                        ;load SECTION 0 from PC
         DISPATCH [MISC]

;Jump and restore flags from bits 0-12 of the final indirect or index word
; JRST 2,
JRSTF:
.IF/SILLY
        [IR]_[MB],                              ;Reseed  MB
        CALL [EFA CALC]
.ENDIF/SILLY
        IF [NOT SECTION 0] THEN [MUUO]
        [E]_[PC RH]                             ;New PC
JRSTFX: LRS [BIT4]_[W1],                        ;Make a user mode bit
         IF [EXEC] THEN [MB_PC FLAGS]
        [W1].OR.[MB]_B                          ;Will still be user mode
        LRS [W1]_[W2]                           ;Make a user I/O bit
        [PC FLAGS]BAR&[W2]_B                    ;Make mask for user I/O
        [W2]BAR&[MB]_B                          ;Prohibit new user I/O
MB_PC FLAGS:
        [MB]+[MB]_Q,                            ;Make user into bit4
        J[#23B MASK]_RAMFILE ADR
        Q&[BIT4]_Y,IX_MX,SET EXEC,              ;Latch new exec as MZ
        IF [TOPS10] CALL [ZERO_PC LH]           ;Size PC for TOPS10
        [MB]_Q RAMFILE_[W2],                    ;Get mask for allowable flags to set
        IF NOT CT [MZ] CALL [SET USER LATCH]
        [W2]BAR&Q_F,F_[PC FLAGS]                ;Set new flags
        SET LOCAL,
         GOTOP [TRAP]

SET USER LATCH:
        SET USER,RETURN

;JRST 4,
HALT:   IF [USER] CALL [CHECK IO OK]            ;Check if this is legal
        J[HALT INS]_[W1]                        ;Code fer JRST 4,
        [E]_[PC],                               ;Set new PC from E
         GOTOP [SET HALT CODE]

;Here for a JRST 5,
XJRSTF:
        READ [E]                                ;Get new flag word
        [MB]_[MEM-OP],                          ;Save flag word
         CALL [READ NEXT]                       ; Get new PC
        [MB]_[PC],                              ;Set new PC
         IF [TOPS10] CALL [ZERO_PC LH]
        [MEM-OP]_[MB],
         GOTOP [JRSTFX]

ZERO_PC LH:
        IF [NOT PAGED] RETURN                   ;If not paged do not do
        ZERO_[PC LH],RETURN                     ;Be sure only 18 bits

;JRST 6,
XJEN:   READ [E]                                ;Get new flag word
        [MB]_[MEM-OP],                          ;Save flag word
         CALL [READ NEXT]                       ; Get new PC
XJNO:   CALL [DISMISS INT]                      ;Dismiss interrupt
                                                ; If not legal do an MUUO
        [MB]_[PC],                              ;Set new PC
         IF [TOPS10] CALL [ZERO_PC LH]
        [MEM-OP]_[MB],
         GOTO [MB_PC FLAGS]

;JRST 7,
XPCW:   IF [USER] CALL [CHECK IO OK]            ;Be sure legal
        [PC FLAGS]_[MB],                        ;Save flags
         CALL [MEMORY WRITE]
        [PC]_[MB],
         CALL [WRITE NEXT]
        CALL [READ NEXT]                        ;Get new flags
        [MB]_[MEM-OP],                          ;Save new flags
         CALL [READ NEXT]                       ; Get new PC
        [MB]_[PC],                              ;Set new PC
         IF [TOPS10] CALL [ZERO_PC LH]
        [MEM-OP]_[MB],
         GOTO [MB_PC FLAGS]

;JRST 10,
JRST 10:
        CALL [DISMISS INT]
        [E]_[PC],
         SET LOCAL,
         GOTOP [IFETCH]

;JRST 12,
JEN:    [MB]_[MEM-OP],                          ;Save new flags
        IF [NOT SECTION 0] THEN [MUUO]          ;Not legal in section 0
        [E]_[MB],                               ;Save new PC
         GOTOP [XJNO]

;Here to dismiss an interrupt
; If IO not legal will do an MUUO
; uses Q, W1, W2, updates RF(PI IN PROG) and PI REG

DISMISS INT:
        J[PI IN PROG]_RAMFILE ADR               ;Address of PIs in progress
        J[0100]_[W2]                            ;Mask for highest PI
        [W2]_Q RAMFILE_[W2],IX_MX,              ;Put mask in Q, Pis in W2
         IF [USER] CALL [CHECK IO OK]           ;Be sure IO is legal
        IF CT [MZ] RETURN                       ;Check if any PIs in progress
JEN2:   Q&[W2]_F,F_Y RORQ_Q,
        IF CT [IZ] THEN [JEN2]
        Q_F,ROL F_B,B SEL/W1                    ;Make mask for level
        [W1]BAR&[W2]_B,ALU_RAMFILE,             ;One less PI in progress
         IF NOT CT [IZ] THEN [JEN3]
        ZERO_[PI REG],Y_2914 STATUS,
         RETURN

JEN3:   Q&[W2]_F,F_Y RORQ_Q,IX_MX
        [K -1]+[PI REG]_B,
        Y_2914 STATUS,
         IF CT [MZ] THEN [JEN3]
        RETURN

SFM:    IF [NOT SECTION 0] THEN [SFM 2]         ;Legal in nonzero sections
         IF [USER] CALL [CHECK IO OK]           ;Or if IO is 1egal
SFM 2:  [PC FLAGS]_[MEM-OP],                    ;Copy flags and then write them
         GOTO [TO MEM]

;Here for JFFO
JFFO:   ZERO_[W1],                              ;Count leading zeros here
         IF CT [MZ] THEN [JFFO X]
        [E]_[PC],                               ;Take branch
         IF CT [MN] THEN [JFFO X]
JFFO 1: [MEM-OP]+[MEM-OP]_B,IX_MX               ;Left shift word
        [W1]+1_[W1],                            ;Count leading zeros
        IF NOT CT [MN] THEN [JFFO 1]
JFFO X: SEL AC+[1]                              ;Address AC+1
        [W1]_RAMFILE,                           ;Clear AC+1
         GOTOP [IFETCH]

;Here for JFCL
JFCL:   J[JFCL MASK]_RAMFILE ADR                ;Point to 037777 777777
        #2*[IR]_[W1],                            ;Copy IR and shift left once
         J[3]_CTR
JFCL4:  #4*[W1]_B,LOOP [JFCL4]                   ;Shift copy of IR
        RAMFILE_[W2],                           ;Get mask for JFCL test bits
        CALL [W2BAR&W1_B]                       ; Leave only bits to test
        [W1]&[PC FLAGS]_Y,                      ;Test flag bits
         SET LOCAL,
         IF CT [IZ] THENP [IFETCH]
        [W1]BAR&[PC FLAGS]_B,                   ;Clear flags
         GOTO [JXA]

;Here for XCT
;       MEM-OP contains instruction to execute
XCT:    [K -1.0]&[IR]_Q,                        ; In case this is PXCT
         IF [USER] THEN [IFETCH 4]
        Q_[PXCT],                               ;In case this is PXCT
        IF [AC.EQ.0] THEN [IFETCH 4]            ;If plain just do it
        [MEM-OP]_[IR],SET PXCT,LOAD IR,         ;Set flag this is PXCT
        GOTOP [IFETCH PXCT]

PXCT STORE 40:
        J[0040]_[PXCT RH]
        GOTO [PXCT STORE]

;Here for usual case of writing operands to memory
PXCT STORE 200:
        J[0200]_[PXCT RH]                       ;Flavour of store
        ;GOTO [PXCT STORE]

;Here when doing memory write under PXCT
;    Cali J[testbit]_[PXCT RH]
PXCT STORE:
        CALL [SET PXCT CTXT]
        [K 7777.-1]&[E]_F,F_Q_B,                ;Get 1st operand
        SPEC SEL/PAGE TABLE ENTRY,
        CALL [MEMORY WRITE]
        GOTO [SET CURRENT CTXT]

PXCT FETCH 40:
        J[0040]_[PXCT RH]
        GOTO [PXCT FETCH]

;Here for usual PXCT FETCH (i.e. 200)
PXCT FETCH 200:
        J[0200]_[PXCT RH]                       ;Flavour of fetch
        ;GOTO [PXCT FETCH]

;Here when doing a memory read under PXCT
; Call J[testbit]_[PXCT RH]
PXCT FETCH:
        CALL [SET PXCT CTXT]
        [K 7777.-1]&[E]_F,F_Q_B,                ;Get 1st operand
         SPEC SEL/PAGE TABLE ENTRY,
        CALL [MEMORY READ]
        ;GOTO [SET CURRENT CTXT]

;Here to set current context
SET CURRENT CTXT:
        J[PROC REG]_RAMFILE ADR                 ;Get what AC blocks should be
        RAMFILE_[W2 LH],
         CLEAR USER
        J[RF PROC REG]_RAMFILE ADR              ;Get current proc reg
        RAMFILE_[W2 RH]
        [W2]_Y,ALU_PROC REG                     ;Set proper processor reg
        [W2]_RAMFILE,
         RETURN

SET PXCT CTXT:
        SWAP [PXCT]_[W1]                        ;Copy test bits
        [W1]&[PXCT]_Y,
         IF CT [IZ] RETURN
        ;GOTO [SET PREV CTXT]

;Here to set previous context
;Called only in exec mode !!
        J[04000]_[W1]                           ;bit 24
        SWAP [W1]_[W1]                          ;becomes bit 6-prev context user
        [W1]&[PC FLAGS]_Y,IX_MX                 ;See if he can do this
        J[RF PROC REG]_RAMFILE ADR              ;Address last value of PROC REG
        RAMFILE_[W1],                   ;Get last PROC REG
        IF NOT CT [MZ] CALL [SET USER LATCH]
        #2*([W1]+[W1 LH])_B                      ;Shift left twice
        #2*[W1]_[W1 LH]                          ;Puts prev AC in position
        [W1]_RAMFILE                            ;In case clock interrupts
        [W1]_Y,ALU_PROC REG,
         RETURN
        ;RAMFILE [E LH],                        ;Get previous section
        ;J[PCS]_RAMFILE ADR                     ;Remember previous section

;Here for MAP
MAP:    [K 7777.-1]&[E]_B,                      ;Strip E to 30 bits
        SPEC SEL/PAGE TABLE ENTRY,              ; Set section flags
         IF [USER] CALL [CHECK IO OK]           ;Be sure allowed to do this
        J[MAP 3]_[W1]
        CALL [SET PF RCOVR]
        ZERO_[W1],#0_UC,
         IF [PAGED] CALL [PAGE R REFIL]         ;Get page info for E
MAP 3:  [K 777]&[E]_B,SEL AC+[0]                ;Leave only on page portion
        J[01000]_[W2]                           ;Will become V bit
        SWAP [W2]_[W2],                         ;Make bit8 = V bit
         IF [PAGED] CALL [W2.OR.W1]
        [E].OR.[W1]_B,ALU_RAMFILE,              ;Add on page portion
        SET LOCAL,GOTOP [IFETCH]

.TOC 2, "Stack Operation Instructions"

;Here for ADJSP after FETCH AC&I and CHK PC SECT

ADJSP:  [K 407777.0]&[AC-OP]_Y,IX_MX,           ;Latch sign of stack pointer
        SEL AC+[0],                             ; Address AC
         IF [SECTION 0] D [DISPATCH 4]          ; D4 = ADJSP V
        SET LOCAL,
         IF CT [(MNxMOVR)!MZ] THEN [ADJSP V]
        [AC-OP]+[MEM-OP]_B,ALU_RAMFILE,         ;Add adjustment
         IF [NOT B BIT 18] THEN [TO AC]
        [K -1.0]+[MEM-OP]_B,ALU_RAMFILE,
         GOTO [TO AC]

ADJSP V:
        [MEM-OP]+[AC-OP RH]_B,                  ;Adjust RH
         SET LOCAL
        SWAP [MEM-OP]_[MEM-OP]                  ;Prepare to add to LH
        [MEM-OP]+[AC-OP]_B,ALU_RAMFILE,
         IF NOT CT [INxorMN] THEN [IFETCH]
        [MEM-OP]_Y,                             ;Compare sign of E to AC
         IF CT [INxorMN] CALL [SET TRAP 2]
        GOTO [TRAP]

;Here for PUSHJ
; CHK PS SECT loaded SECTION 0 from PC and loaded MB with PC
PUSHJ:  [E]_[MEM-OP+1]                          ;Save adr where we will go
        [PC FLAGS]_Q,                           ;Save pc flags fer sectO case
         J[PUSHJ FLAGS]_RAMFILE ADR             ;Adr of mask for flags to clear
        RAMFILE_[W6],                           ;Get mask
        IF [SECTION 0] THEN [PUSHJ VANILLA]
        [K 407777.0]&[MEM-OP]_Y,                ;Check for which extended case
         IX_MX
        SWAP [K 777]_[W1]                       ;9bit mask for PC section
                                                ; PC sect to 9 bits (strange but ok)
        [W1]&[MB LH]_B,                         ;We are going to write PC in memory
         IF CT [(MNxMOVR)!MZ] THEN [PJ H]
        [MEM-OP]+1_[MEM-OP],SET GLOBAL          ;Increment pointer
        WRITE [MEM-OP]
        [W6]BAR&[PC FLAGS]_B,                   ;Clear flags
         SEL AC+[0]                             ;Select AC to restore pointer
        [MEM-OP+1]_[PC],
         GOTO [TO AC]

PUSHJ VANILLA:
        Q_[MB LH]                               ;<PC flags,,PC> in MB
PJ H:   [BIT17]+[MEM-OP LH]_B                   ;Increment LH
        [MEM-OP]+1_[MEM-OP RH]                  ;Increment RH of AC
        [MEM-OP]_[E RH],SET LOCAL,              ;Address to write into
         CALL [MEMORY WRITE]
        [K -1.0]&[MEM-OP]_Y,
         IX_MX,SEL AC+[0]                       ;Check for overflow
        [W6]BAR&[PC FLAGS]_B                    ;Clear flags
        [MEM-OP+1]_[PC],                        ;Perform branch
         SET LOCAL,
         IF NOT CT [MZ] THENP [TO AC]
        [MEM-OP]_Y,ALU_RAMFILE,                 ;Update pointer
         GOTO [PUSH TRAP]                       ;Set trap flags

;Here to check PC section, set MZ if section 0
CHK PC SECT:
        [PC]_[MB],SECTION SELECT,               ;Select our section
         DISPATCH [DISPATCH 3]


;Here for PUSH
; CHK PC SECT loaded SECTION 0 from PC
PUSH:   [PC]_Y,SECTION SELECT                   ;Select our section
        [K 407777.0]&[AC-OP]_Y,                 ;Test for extended case
         IX_MX,
        IF [SECTION 0] THEN [PUSH VANILLA]
        IF CT [(MNxMOVR)!MZ] THEN [PUSH VANILLA]
        [AC-OP]+1_[E],                          ;New stack address
         IF [PXCT] CALL [PXCT STORE 40]
        [K 7777.-1]&[E]_F,F_Q_B,
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEM WRITE 1]
        SEL AC+[0]                              ;Address AC
        [AC-OP]+1_Y,ALU_RAMFILE,                ;Update AC
         CLEAR LOCAL,
         GOTOP [IFETCH]
PUSH VANILLA:
        [BIT17]+[AC-OP LH]_B                    ; Increment LH of stack pointer
        [AC-OP]+1_[AC-OP RH]                    ; Increment RH
        [AC-OP]_[E RH],                         ;Set in section address
         IF [PXCT] CALL [PXCT STORE 40]
        [K 7777.-1]&[E]_F,F_Q_B,                ; Data already in MB
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEM WRITE 1]
        [K -1.0]&[AC-OP]_Y,                     ;Check for overflow
        IX_MX,SEL AC+[0]                        ; Address AC to restore updated version
        [AC-OP]_RAMFILE,                        ;Restore stack pointer
        SET LOCAL,
        IF NOT CT [MZ] THENP [IFETCH]
PUSH TRAP:
        CALL [SET TRAP 2]                       ;Set trap 2 flag
        SET LOCAL,GOTOP [TRAP]


;Here for POP after CHK PC SECT
POP:    [K 407777.0]&[MEM-OP]_Y,IX_MX,          ;Test stack pointer
         IF [SECTION 0] THEN [POP VANILLA]
        [E]_[W6],                               ;Save effective address
         IF CT [(MNxMOVR)!MZ] THEN [POP V 1]
        [MEM-OP]_Q_[E],                         ;Address of stack data
         IF [GLOBAL] THEN [POP 3]
        [K 7777.-1]&[E]_B,CLEAR LOCAL,
         IF [PXCT] CALL [PXCT FETCH 40]
        [E]_Q_[E],
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEMORY READ]
        SET LOCAL,GOTO [POP 5]                  ;Restore effective address
POP 3:  [K 7777.-1]&[E]_B,                      ;Read location off stack
        IF [PXCT] CALL [PXCT FETCH 40]
        [E]_Q_[E],
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEMORY READ]       ;Read location off stack
POP 5:  [W6]_[E],
         IF [PXCT] CALL [PXCT STORE 200]
        [K 7777.-1]&[E]_F,F_Q_B,
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEM WRITE 1]
        SEL AC+[0]
        [K -1]+[MEM-OP]_Y,                      ;Decrement stack pointer
         ALU_RAMFILE,
         SET LOCAL,
         GOTOP [IFETCH]                         ;Store stack pointer

POP V 3:
        [MEM-OP]_[E RH],SET LOCAL,              ;Get in section address
         IF [PXCT] CALL [PXCT FETCH 40]
        [K 7777.-1]&[E]_F,F_Q_B,                ;Get data from stack
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEMORY READ]
        SET GLOBAL,
         GOTO [POP V 5]

POP VANILLA:
        [E]_[W6]                                ;Save effective address

POP V 1:
        [PC]_[E],                               ;Copy pdl section number
         IF [GLOBAL] THEN [POP V 3]
        [MEM-OP]_[E RH],SET LOCAL,              ;Get in section address
         IF [PXCT] CALL [PXCT FETCH 40]
        [K 7777.-1]&[E]_F,F_Q_B,                ;Get data from stack
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEMORY READ]
POP V 5:
        [W6]_[E],
        IF [PXCT] CALL [PXCT STORE 200]
        [K 7777.-1]&[E]_F,F_Q_B,
         SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PXCT] CALL [MEM WRITE 1]
        ;GOTO [POP V PNTR]
POP V PNTR:
        [K -1.0]&[MEM-OP]_Y,                    ;Check for overflow
         IX_MX
        [MEM-OP]-[BIT17]_A,SEL AC+[0]           ;Decrement LH
        [K -1]+[MEM-OP RH]_B,                   ;Decrement RH of pointer
         SET LOCAL,
         IF NOT CT [MZ] THENP [TO AC]
        [MEM-OP]_RAMFILE,                       ;Store updated pointer
         GOTO [PUSH TRAP]                       ; Then trap

;Here for POPJ
POPJ:
.IF/FTMBZ
        [K -1.0]BAR&[IR]_Y,                     ;E should be 0
        IF NOT CT [IZ] THEN [MUUO]
.ENDIF/FTMBl
        [K 407777.0]&[MEM-OP]_Y,                ;Test stack pointer
         IX_MX,
         IF [NOT SECTION 0] THEN [POPJ 1]
        [MEM-OP]_[E RH],                        ;Fetch new PC
         CALL [MEM READ 0]
        [MB]_[PC RH],                           ;Set new PC
         GOTO [POP V PNTR]

POPJ 1: [MEM-OP]_[E RH],SET LOCAL,
        IF NOT CT [(MNxMOVR)!MZ] THEN [POPJ 2]
        READ [E]                                ;Fetch new PC
        [MB]_[PC],                              ;Set new PC
         GOTO [POP V PNTR]

POPJ 2: [MEM-OP]_[E],SET GLOBAL,                ;Stack address
        CALL [MEM READ 0]                       ;Fetch new PC
        [MB]_[PC],                              ;Set new PC
         SEL AC+[0]
        [K -1]+[MEM-OP]_Y,                      ;Save new AC
         ALU_RAMFILE,
         SET LOCAL,
         GOTOP [IFETCH]

;Here to put flags & PC in MB or PC in MB depending on section
; First part of JSR and JSP
JSR SETUP:
        J[PUSHJ FLAGS]_RAMFILE ADR
        RAMFILE_[W5],                   ;Get bits to clear from flags
         IF [SECTION 0] THEN [JSR SECT 0]
        [K 7777.-1]&[MB]_B,                     ;Mask off bits 0-5
        SEL AC+[0],
         DISPATCH [INST EXCT]
JSR SECT 0:
        [PC FLAGS]_[MB LH],SEL AC+[0],          ;Put flags in memory lh
        DISPATCH [INST EXCT]


;Here for JSR
JSR:
.IF/FTMBZ
        IF [AC.NE.0] THEN [MUUO]                ;AC field should be 0
.ENDIF/FTMBZ
        CALL [MEMORY WRITE]                     ;MB already setup by JSR SETUP
        [E]+1_[E RH]                            ;Go to next location

JSR CLEAR FLAGS:
        [W5]BAR&[PC FLAGS]_B                    ;Clear 1st part done, Address failure
                                                ; inhibit, and trap flags
        [E]_[PC],SET LOCAL,                     ;Set new PC
         GOTOP [IFETCH]

;Here for JSP
JSP:    [MB]_RAMFILE,                           ;Write AC and exit
         GOTO [JSR CLEAR FLAGS]


;Here for JSA

JSA:    [MEM-OP]_[MB],                          ;Copy AC to write in E
         CALL [MEMORY WRITE]
        SWAP [E]_[MEM-OP]                       ;Put E rh in mem lh
        [PC]_[MEM-OP RH]                        ;Put PC rh in mem rh
        [E]_[PC]                                ;Set new PC
        [PC]+1_[PC RH],                         ;Make E+1 new PC
         GOTO [TO AC.0]

;Here for JRA
JRA:    [E]_[W6]                                ;Save E
        SWAP [MEM-OP]_[E RH],                   ;Address to load AC with
         CALL [MEM READ 0]
        [W6]_[PC],SEL AC+[0]                    ;Set new PC
        [MB]_Y,ALU_RAMFILE,                     ;Write AC and done
        SET LOCAL,GOTO [IFETCH]


.TOC 2, "Arithmetic Testing Instructions"

;Here for CAxx instructions to compare operands

CAX:    [AC-OP]-[MEM-OP]_Y,IX_MX,               ;Compare operands and dispatch
         DISPATCH [DISPATCH 3]

;Here for AOxx instructions to increment AC or memory
AOXX:   [MEM-OP]+1_[MEM-OP],                    ;Increment and dispatch
         IF CT [IZ IX_MX] THEN [SET C0!C1 STORE]
        IF NOT CT [MOVR] D [DISPATCH 3]
        GOTO [SET OV!C1!T1 STORE]

;Here for SOxx instructions to decrement AC or memory

SOXX:   [K -1]+[MEM-OP]_B,                      ;Decrement and dispatch
        IF CT [MZ IX_MX] D [DISPATCH 3]
        IF NOT CT [MOVR] THEN [SET C0!C1 STORE]
        GOTO [SET OV!C0!T1 STORE]

;Here for SxL instructions to conditionally skip
SXL:    IF NOT CT [MNxMOVR] D [DISPATCH 4]
        [PC]+1_[PC RH],
        DISPATCH [DISPATCH 4]

;Here for SxE instructions to conditionally skip
SXE:    IF NOT CT [MZ] D [DISPATCH 4]
        [PC]+1_[PC RH],
        DISPATCH [DISPATCH 4]

;Here for SxLE instructions to conditionaly skip
SXLE:   IF NOT CT [(MNxMOVR)!MZ] D [DISPATCH 4]
        ; G070 [SXA]

;Here for SxA instructions to conditionaly skip
SXA:    [PC]+1_[PC RH],
        DISPATCH [DISPATCH 4]

;Here for SxGE instructions to conditionaly skip
SXGE:   IF CT [MNxMOVR] D [DISPATCH 4]
        [PC]+1_[PC RH],
         DISPATCH [DISPATCH 4]

;Here for SxN instructions to conditionaly skip
SXN:    IF CT [MZ] D [DISPATCH 4]
        [PC]+1_[PC RH],
         DISPATCH [DISPATCH 4]

;Here for SxG instructions to conditionaly skip
SXG:    IF CT [(MNxMOVR)!MZ] D [DISPATCH 4]
        [PC]+1_[PC RH],
        DISPATCH [DISPATCH 4]

;Here for JXL instructions to conditionaly branch
JXL:    IF NOT CT [MN] D [DISPATCH 4],
         SET LOCAL
        [E]_[PC],DISPATCH [DISPATCH 4]

;Here for JxE instruction to conditionaly branch
JXE:    IF NOT CT [MZ] D [DISPATCH 4],
         SET LOCAL
        [E]_[PC],DISPATCH [DISPATCH 4]

;Here for JxLE instructions to conditionaly branch
JXLE:   IF NOT CT [(MNxMOVR)!MZ] D [DISPATCH 4],
         SET LOCAL
        [E]_[PC],DISPATCH [DISPATCH 4]

;Here for JxA instructions to conditionaly branch
JXA:    [E]_[PC],SET LOCAL,
         DISPATCH [DISPATCH 4]

;Here for JxGE instructions !o conditionaly branch
JXGE:   IF NOT CT [NOT MN] D [DISPATCH 4],
         SET LOCAL
        [E]_[PC],DISPATCH [DISPATCH 4]

;Here for JxN instructions to conditionaly branch
JXN:    IF CT [MZ] D [DISPATCH 4],
         SET LOCAL
        [E]_[PC],DISPATCH [DISPATCH 4]

;Here for JxG instructions to conditionaly branch
JXG:    IF CT [(MNxMOVR)!MZ] D [DISPATCH 4],
         SET LOCAL
        [E]_[PC],DISPATCH [DISPATCH 4]

;Here for SKIPx instructions to store in AC if AC.NE.0
SKIPX:  SET LOCAL,
        IF [AC.EQ.0] THENP [IFETCH]             ;If nc AC we are done
        [MEM-OP]_RAMFILE,                       ;Store in AC
        GOTOP [IFETCH]

.TOC 2, "Boolean Instructions"

;Here for SETZx
SETZX:  ZERO_[MEM-OP],
         DISPATCH [INST EXCT]

;Here for ANDx
ANDX:   [AC-OP]&[MEM-OP]_B,                     ;And AC with MEM and store
         DISPATCH [OPERAND STORE]

;Here for ANDCAx
ANDCAX: [AC-OP]BAR&[MEM-OP]_B,                  ;And AC complement with mem and store
         DISPATCH [OPERAND STORE]

;Here for SETMI = XMOVEI
XMOVEI: CALL [E_MEM-OP]
        SEL AC+[0],
         DISPATCH [OPERAND STORE]

;Here for ANDCMx
ANDCMX: COMPLEMENT [MEM-OP]_F,                  ;Complement mem operand then
        F_[MEM-OP],GOTO [ANDX]                  ; same as AND

;Here for XORx
XORX:   [AC-OP].XOR.[MEM-OP]_F,F_B              ;Xor operands and store
         DISPATCH [OPERAND STORE]

;Here for IORx
IORX:   [AC-OP].OR.[MEM-OP]_B,                  ;Ior operands and store
         DISPATCH [OPERAND STORE]

ANDCBX:
;Small way is:
;       COMPLEMENT [AC-OP]_F,                   ;Comp1ement AC operand
;        F_[AC-OP], GOTO [ANDCMX]
;Fast way is:
        COMPLEMENT [MEM-OP]_F,
         F_[MEM-OP]
        [AC-OP]BAR&[MEM-OP]_B,                  ;And complements and store
         DISPATCH [OPERAND STORE]

;Here for EQVx
EQVX:   [AC-OP].XNOR.[MEM-OP]_F, F_B,           ;Put eqv (XNOR) in mem store
         DISPATCH [OPERAND STORE]

;Here for SETCAx
SETCAX: COMPLEMENT [MEM-OP]_F,                  ;Complement AC and store
         F_[MEM-OP],
         DISPATCH [OPERAND STORE]

;Here for ORCAx
ORCAX: COMPLEMENT [AC-OP]_F,                    ;Complement AC then same as OR
        F_[AC-OP],
         GOTO [IORX]

;Here for SETCMx
SETCMX: COMPLEMENT [MEM-OP]_F,                  ;Complement mem and store
        F_[MEM-OP],
         DISPATCH [OPERAND STORE]

;Here for ORCMx
ORCMX:  COMPLEMENT [MEM-OP]_F,                  ;Complement mem and then same as OR
        F_[MEM-OP],
         GOTO [IORX]

;Here for ORCBx                                 ;And operands then same as SETCM
ORCBX:  [AC-OP]&[MEM-OP]_F,
        GOTO [SETCMX]

;Here for SETOx
SETOX:  ONES_[MEM-OP],
        DISPATCH [INST EXCT]


.TOC 2, "Half Word Instructions"

;Here for HLL
HLL:    [AC-OP]_[MEM-OP RH],                    ;Preserve RH of AC then store
         DISPATCH [OPERAND STORE]

;Here for HLLI = XHLLI
XHLLI:  [E]_[MEM-OP LH],SECTION SELECT          ;Preserve RH of AC
        [K 7777.-1]&[MEM-OP]_B,                 ;Strip extraneous bits
         IF [NOT AC REF] THEN [TO AC.0]
        [PC]_Y,SECTION SELECT,                  ;Check PC section
         IF [GLOBAL] THEN [TO AC.0]
        SEL AC+[0],
        IF [SECTION 0] D [OPERAND STORE]
        [BIT17]_[MEM-OP LH],                    ;Sect = 1 here
         GOTO [TO AC]

; Here for HRU,
HRLM:   SWAP [AC-OP]_[AC-OP]                    ;Swap AC op then same as HLLM
        ;GOTO [HLLM]

;Here for HLLM
HLLM:   [AC-OP]_[MEM-OP LH],                    ;Preserve LH of AC then store
        DISPATCH [OPERAND STORE]

;Here for HRL & HRLI
HRL:    SWAP [MEM-OP]_[AC-OP LH],               ;Swap memory op then same as HLL
         DISPATCH [OPERAND STORE]

;Here for HRLS
HRLS:   SWAP [MEM-OP]_[MEM-OP LH],              ;Put RH in LH then store
        DISPATCH [OPERAND STORE]

;Here for HLLZX
HLLZX:  [K -1.0]&[MEM-OP]_B,                    ;Mask off rh and store
        DISPATCH [DISPATCH 4]

;Here for HRLEX
HRLEX:  [MEM-OP]_Y,IX_MX                        ;Test sign bit
        ;GOTO [HLLEX]

;Here for HLLEX
HLLEX:  ZERO_[MEM-OP RH],                       ;Clear RH
        IF NOT CT [MN] D [DISPATCH 4]
        ;GOTO [HLLOX]

;Here for HLLOX
HLLOX:  ONES_[MEM-OP RH],                       ;Add ones to rh and store
         DISPATCH [DISPATCH 4]


;Here for HRR & HRRI
HRR:    [AC-OP]_[MEM-OP LH],                    ;Preserve ACs lh then store
         DISPATCH [OPERAND STORE]

;Here for HLRM
HLRM:   SWAP [AC-OP]_[AC-OP]                    ;Swap AC arg then same as HRRM
        ;GOTO [HRRM}

;Here for HRRK
HRRM:   [AC-OP]_[MEM-OP RH],                    ;Copy Rh then store
         DISPATCH [OPERAND STORE]

;Here for HLR & HLRI
HLR:    SWAP [MEM-OP]_[AC-OP RH],               ;Swap mem arg then same as HRR
         DISPATCH [OPERAND STORE]

;Here for HLRS
HLRS:   SWAP [MEM-OP]_[MEM-OP RH],              ;Put LH in RH then store
        GOTO [TO SELF]

;Here for HRRZX
        HRRZX: ZERO_[MEM-OP LH],                ;Clear LH and store
         DISPATCH [DISPATCH 4]

;Here for HRREX
HRREX:  [K -1.0]BAR&[MEM-OP]_B,                ; Clear RH and check sign
         IF [NOT B BIT 18] D [DISPATCH 4]
        ;GOTO [HRROX]

;Here for HRROX
HRROX:  ONES_[MEM-OP LH],                       ;Put ones in LH and store operand
        DISPATCH [DISPATCH 4]


.TOC 2, "Logical Testing and Modification Instructions"

;Here for TRxx Instructions to get test bits and AC
TRX:    ZERO_[E LH],                            ;Leave only E RH, then set AC
        GOTO [TDXX]

;Here for TLxx Instructions to get test bits and AC
TLX:    ZERO_[E LH]                             ;Strip RH and select AC
        SWAP [E]_[E],                           ;Put test bits in LH and select AC
         GOTO [TDXX]

;Here for TDxx Instructions to get test bits and AC
TDX:    READ [E]                                ;Fetch test bits
        [MB]_[E],SEL AC+[0]                     ;Copy test bits, and select AC
TDXX:   RAMFILE_[MEM-OP],               ;Get AC and dispatch
        SET LOCAL,
        DISPATCH [DISPATCH 2]

;Here for TSxx Instructions to get test bits and AC
TSX:     READ [E]                               ;Fetch test bits
         SWAP [MB]_[E],SEL AC+[0]               ;Swap test bits and select AC
         RAMFILE_[MEM-OP],              ;Get AC and dispatch
          SET LOCAL,
          DISPATCH [DISPATCH 2]

;Here for TxE Instructions for conditional skip
TXE:    [E]&[MEM-OP]_Y,                         ; Check for need to skip
         IF NOT CT [IZ] D [DISPATCH 3]
        ;GOTO [TXA]

;Here for TxA Instructions for conditional skip
TXA:    [PC]+1_[PC RH],
         DISPATCH [DISPATCH 3]

;Here for TxN Instructions for conditional skip
TXN:    [E]&[MEM-OP]_Y,                         ;Check for need to skip
         IF CT [IZ] D [DISPATCH 3]
        [PC]+1_[PC RH],
         DISPATCH [DISPATCH 3]

;Here for TxZ Instructions to change bits
TXZ:    [E]BAR&[MEM-OP]_Y,                      ;Store new bits
        ALU_RAMFILE,
         GOTOP [IFETCH]

;Here for TxC Instructions to change bits
TXC:    [E].XOR.[MEM-OP]_Y,                     ;Store new bits
        ALU_RAMFILE,
         GOTOP [IFETCH]

;Here for TxO Instructions to change bits
TXO:    [E].OR.[MEM-OP]_Y,                      ;Store new bits
         ALU_RAMFILE,
        GOTOP [IFETCH]


.TOC 2, "Extend Instructions"

.IF/FTEXTEND
EXTEND: READ [E]                                ;Get EO word
        CALL [EFA CALC]
.ENDIF/FTEXTEND


.TOC 2, "CIS Instructions"

.IF/FTCIS
;Current block AC0 wi11 be as follows for interrupts
;
;                  11111111112222222 222333333
;        012345678901234567890123456 789012345
;       +---------------------------+---------+
;       +                           +         +
;       +---------------------------+---------+
;                                    \       /
;                                        + ---number of bytes so far
;Register usage
;       W1 current byte
;       W2 src adr (bit0-immediate;bits 4-35 are 32bit byte adr)
;       W3 src wrd
;       W4 dest adr
;       W5 dest wrd
;       W6 0,,bytes left to do
;       ACO number of bytes to do,,number of bytes written

;Common routine to do setup for CIS instructions
CIS SETUP:
        J[0400]_[W1]
        SWAP [W1]_[W1]                          ;Make a bit9
        [W1]_Q                                  ;Save copy in Q reg
        Q&[IR]_F,F_Y LSRQ_Q,IX_MX               ;Test bit 9
        Q&[IR]_F,F_Y LSRQ_Q,                    ;Test bit 10
         IF CT [MZ IX_MX] THEN [CS 2]
;Here if bit 9 is 0
        Q&[IR]_F,F_Y LSRQ_Q,                    ;Test bit 11
         IF NOT CT [MZ IX_MX] THEN [CS 1]
        [E]_[W2]                                ;Copy source adr
        #2*[W2]_[W2],
         IF NOT CT [IZ] CALL [W2+1]
        #2*[W2]_[W2],
         IF NOT CT [IZ] CALL [W2+1]
        [PC FLAGS]&[BIT4]_F                     ;Check first part done
W2+1:   [W2]+1_[W2],RETURN
;Here if bits 9,10 are 0,1
CS 1:   Q&[IR]_F,F_Y LSRQ_Q, ;Test bit 12
         IF NOT CT [MZ IX_MX] THEN [MUUO]
        [E]_[W3],                               ;In case immediate
         IF NOT CT [MZ] THEN [CS1 IM]
;Here if first operand is deferred mode
        READ [E]                                ;Get adr of operand
.IF/FTMBZ
        J[#32B MASK]_RAMFILE ADR
        RAMFILE_[W1]
        [W1]BAR&[MB]_Y,IX_MX                    ;Test for illegal bits
        [MB]_[W2],                              ;Copy adr
         IF NOT CT [MZ] THEN [MUUO]
.ENDIF/FTMBZ
.IFNOT/FTMBZ
        [MB]_[W2]                               ;Copy adr
.ENDIF/FTKBZ

; Here if immediate operand
CS1 IM:

;Here is bit 9 is 1
CS 2:   DISPATCH [DISPATCH 2]

MOVC:
        [BIT4]&[PC FLAGS]_F                     ;Check first part done
        JS[0]_[W6]
        LRS [W6]_[W6]
        LRS [W6]_[W6]
MOVC 7:
        CALL [NXT SRC BYT]                      ;Get next byte to transfer
        CALL [W NXT DST BYT]                    ;Copy it
        [K -1]+[W6]_B,
         IF NOT CT [IZ] THEN [MOVC 7]
        GOTOP [IFETCH]

;Register conventions same as MOVC
CMPC:
CMPC 7: CALL [NXT SRC BYT]                      ;Get first operand byte
        J[EIS W1]_RAMFILE ADR
        [K 777]&[W1]_Y,ALU_RAMFILE,             ;Save first operand
        CALL [R NXT DST BYT]                    ;Get other byte
        [K 777]&[W1]_Q,
         J[EIS W1]_RAMFILE ADR
        RAMFILE_[W1]
        Q-[W1]_Y,
         IF NOT CT [IZ IX_MX] THEN [CMPC 8]
        [K -1]+[W6]_B,
         IF NOT CT [IZ] THEN [CMPC 7]
        GOTOP [IFETCH]
CMPC 8: IF CT [MN] THEN [CMPC 9]
CMPC 9: GOTOP [IFETCH]


;Move Characters Variable Length
MOVCV:
;Compare Characters Variable Length
CMPCV:
;Compare Numeric Display
CMPND:
;Add Numeric Display
ADDND:
;Subtract Numeric Display
SUBND:
;Move Numeric Display
MOVND:
;Arithmetic Shift Numeric Display
ASHND:
;Convert Numeric Display to Binary
CVTNDB:
;Convert Binary to Numeric Display
CVTBND:
;Test for Legal Numeric Display
TLGND:
;Compare Packed
CMPP:
;Add Packed
ADDP:
;Subtract Packed
SUBP:
;Move Packed
MOVP:
;Arithmetic Shift Packed
ASHP:
;Clear High Order Packed
CHOP:
;Convert Packed to Binary
CVTPB:
;Convert Binary to Packed
CVTBP:
;Convert Numeric Display to Packed
CVTNDP:
;Convert Packed to Numeric Display
CVTPND:
; Convert EBCDIC Numeric Display to Packed
CVTEP:
; Convert Packed to EBCDIC Numeric Display
CVTPE:

;Here to read the next source byte
NXT SRC BYT:
        [W2]+1_[W2],                            ;Next byte adr
         IF CT [IN IX_MX] THEN [NXT SRC I]
        ASR [W2]_[E] MC                         ;Copy adr to E
        ASR [W2]_[E] MC,                        ;Copy word adr
         IF CT [MC] THEN [NSB 2]                ; Check for odd or even byte
        IF CT [MC] THEN [NSB 3]

;Here if need to fetch next source word
        READ [E]
        [MB]_[W3],                              ;Copy data
         J[2]_CTR
        SWAP [W3]_[W1]
        #2*[W1]_[W1],
         GOTO [NSB 30]

;Here for 3rd byte in word
NSB 3:  #2*[W3]_[W1],                            ;Copy to right word
         J[3]_CTR
NSB 30: #4*[W1]_B,
        LOOP [NSB 30]
SWAP W1 W1:
        SWAP [W1]_[W1],
         RETURN

;Here for 2nd or 4th byte in word
NSB 2:  [W3]_[W1],
         IF CT [MC] RETURN
;Here for 2nd byte in word
        SWAP [W1]_[W1],
         RETURN

NXT SRC I:
        [W3]_[W1],                              ;Next byte
         RETURN

;Here to read the next destination byte
R NXT DST BYT:

;Here to write the next destination byte
; Call with byte right justified in W1
W NXT DST BYT:
        [W4]+1_[W4]                             ;Next byte adr
        ASR [W4]_[E] MC                         ;Copy adr to E
        ASR [W4]_[E] MC,                        ;Copy word adr
         IF CT [MC] THEN [WNDB 2]               ; Check for odd or even byte
        IF CT [MC] THEN [WNDB 3]
;Here if need to fetch next source word
        READ [E]
        [MB]_[W5],                              ;Copy data
         J[3]_CTR
        J[NBBYTE1]_RAMFILE ADR
        SWAP [W1]_[W1]
        #2*[W1]_[W1],
         GOTO [WNDB 30]

;Here for 3rd byte in word
WNDB 3: J[NBBYTE3]_RAMFILE ADR
        #2*[W5]_[W1],                            ;Copy to right word
        J[3]_CTR
WNDB 30:#4*[W1]_B,
        LOOP [WNDB 30]
        RAMFILE_[MB],                           ;Get mask for character
         RETURN

WNDB 2: SWAP [K 777]_[MB],                      ;Mask for byte
        IF CT [MC] THEN [WNDB 4]
;Here for 2nd byte in word
        SWAP [W1]_[W1]                          ;Position data
WNDB 20:[MB]BAR&[W5]_B                          ;Strip old byte from word
        [MB]&[W1]_B                             ;Strip data to move
        [W1].OR.[W5]_B,                         ;Add new bits to word
        RETURN

;Here for 4th byte in word
WNDB 4: [K 777]BAR&[W5]_Q                       ;Mask off old data
        [K 777]&[W1]_B                          ;Mask off extraneous bits from data
        Q.OR.[W1]_[MB],                         ;Add new byte to data
         CALL [MEMORY WRITE]
        [E]+1_Q_[E],
        SPEC SEL/PAGE TABLE ENTRY,
        CALL [MEMORY READ]
        [MB]_[W5],
         RETURN
.ENDIF/FTCIS

.TOC 2, "IO Instructions"

IO:     #2*[IR]_[W1],                            ;Copy IR to W1 shifted left
        IF [USER] CALL [CHECK IO OK]
        #4*[W1]_B,                               ;Keep shifting
         CALL [#2*W1_W1 LOAD IR]
        DISPATCH [IO 0]

#2*W1_W1 LOAD IR:
        #2*[W1]_[W1],                            ;Keep shifting
         LOAD IR,RETURN

IO 4:

;Here for an illegal IO instruction
XIO:    IF [USER] CALL [CHECK IO OK]
        GOTOP [IFETCH]

;Here to check if EXEC or user IO is set
; If IO is legal return, else do MUUO
CHECK IO OK:
        J[04000]_[W1],IF [EXEC] RETURN           ;Bit 24
        SWAP [W1]_[W1],IF [PXCT] RETURN         ;Make bit 6-User I/O
        [W1]&[PC FLAGS]_Y,
         IF NOT CT [IZ] RETURN
        GOTOP [MUUO]

.TOC 1, "Executive Instructions"
.TOC 2, "Arithmetic Processor"
.TOC 3, "APRID - APR Identification"

;Arithmetic Processor Identification
;        APRID
;       +-------+---+---+---+
;       | 70000 | I | X | Y |
;       +-------+---+---+---+
;
;  0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;  | \       /\                      / \                                 /
;  |     |                 |                             + ---reserved
;  |     |                 + ---u-code version number
;  |     + ---reserved
;  +---u-code includes address break

APRID:

;Possible coding
;       J[X]_[MEM-OP]                           ;load bits 0-11
;       ROL [MEM-OP]_[MEM-OP],J[10.]_CTR
;       ROL [MEM-OP]-[MEM-OP],LOOP [.]
;       [MEM-OP]J[Y]-[MEM-OP]                   ;Add bits 12-23
;       ROL [MEM-OP]-[MEM-OP],J[10.]_CTR
;       ROL [MEM-OP]-[MEM-OP],LOOP [.]
;       [MEM-OP]J[Z]-[MEM-OP],                  ;Add bits 24-35
;        GOTO [TO MEMORY]


.IFNOT/FTADRB
        J[U-CODE VERSION]_[MEM-OP]              ;Put u-code version in register
.ENDIF/FTADRB
.IF/FTADRB
        J[U-CODE VERSION]_Y24-Y35,              ;Put u-code version in register
        [BIT17]_F,F_ROR Y_[MEM-OP]              ;Bit for address break feature
.ENDIF/FTADRB
        SWAP [MEM-OP]_[MEM-OP],                 ;Put u-code version in lh
        GOTO [TO MEM]

.TOC 3, "WRAPR - Write APR Conditions"
;Conditions Out, arithmetic processor
;        WRAPR,
;       +-------+---+---+---+
;       | 70020 | I | X | Y |
;       +-------+---+---+---+
;
; E bits
;
;       181920212223242526272829303132333435
;        | | | | | | \    flags    / | \   /
;        | | | | | |                 |   + ---PIA
;        | | | | | |                 + ---should be zero
;        | | | | | + ---Set selected flags
;        | | | | + ---Clear selected flags
;        | | | + ---disable selected flags
;        | | + ---enable selected flags
;        | + ---clear all IO devices
;        + ---should be zero

WRAPR:
.IFNOT/FT7PI
        J[6]_[W1]                               ;Mask for PI channel
        [W1]&[E]_Y,IX_MX
        ROR [W1]_[W1],                          ;Make mask for bit 35
         IF NOT CT [MZ] THEN [CNAPR1]
        [W1]&[E]_Y,                             ;May not put on channel 1
         IF NOT CT [IZ] THEN [MUUO]
CNAPR1:
.ENDIF/FT7PI
.IF/FTMBZ
        J[0010]_Y24-Y35,[BIT17]_F,              ;Makes 0,,400010
        F_ROR Y_[W1]
        [W1]&[E]_Y,                             ;Check for illegitimate bits
         IF NOT CT [IZ] THEN [MUUO]
.ENDIF/FTMBZ
        J[04000]_[W1]                           ;Mask to test bits
        [W1]+[W1]_Q,                            ;Put mask in Q reg
         J[APR FLAGS]_RAMFILE ADR
        J[07760]_[W2]                           ;Mask for flags
        [E]&[W2]_B                              ;leave only flags
        RAMFILE_[W1],                           ;Get processor flags
         CALL [CAPR X]                          ; Turn on/turn off flags
        SWAP [W2]_[W2],                         ;Swap halves
         CALL [CAPR Y]                          ; Turn off/turn on flags
        J[7]_[W2]                               ;Mask for PI chnl
        [W2]BAR&[W1]_B                          ;Strip old PI chnl
        [E]&[W2]_B                              ;leave only PI chnl
.IFNOT/FT7PI
        [W2]+[K -1]_Y,                          ;Check for setting PI level 1
         IF CT [IZ] THEN [MUUO]                 ;No you do not
.ENDIF/FT7PI
        [W2].OR.[W1]_Y,ALU_RAMFILE              ;Save updated APR flags
        Q&[E]_F,ALU_Y/YES,#2*Q_Q,               ;Test for IO reset
         IF NOT CT [IZ] CALL [RESET IO]
        CALL [SET PROC REG]
        SET LOCAL,
         GOTOP [IFETCH]

;Here to perform an IO reset function
; Wave IO RESET, clear all APR flags, clear all TTY flags
RESET IO:
        J[APR FLAGS]_RAMFILE ADR                ;Address APR flags
        ZERO_Y,ALU_RAMFILE                      ;Clear flags
        J[LNOSW]_[W6],Y_RAMFILE ADR             ;Address first TTY link block
        J[04200]_[W6]                           ; CR5-RTS, CR1=DTR
        SWAP [W5]_[W5]
        #4*[W5]_B,ALU_RAMFILE                   ;Save initial CTY status
        [W6]+1_F,F_Q,J[075]_CTR                 ;Address mode word
IOR2:   Q+1_F,F_Q_Y,Y_RAMFILE ADR               ;Address next location
        ZERO_Y,ALU_RAMFILE,LOOP [IOR2]
        ;J[02000]_[W1]                          ;Bit for IO reset
        ;[W1]_Y,ALU_PROC REG,                   ;Tell processor reset
        ; CALL [SET PROC REG]                   ; Then tell it right info
        ZERO_Y,ALU_PROC REG,                    ;Clean processor reg
         CALL [SET PROC REG]                    ; Then load it
        GOTO [SET PCI MODE]                     ;Set mode for CTY

;Here to test for set/lest for clear flags
; Mask (to be shifted left) is in Q and is tested with E
; W2 is ored or bar&ed into W1

CAPR X: Q&[E]_F,ALU_Y/YES,#2*Q_Q,               ;Test for set selected flags/enables
         IF NOT CT [IZ] CALL [W2.OR.W1]         ;Set selected flags/enables
        Q&[E]_F,ALU_Y/YES,#2*Q_Q,               ;Test for clear selected flags/enables
         IF CT [IZ] RETURN
W2BAR&W1_B:
        [W2]BAR&[W1]_B,                         ;Clear selected flags/enables
        RETURN

;Here to test for clear/test for set flags
; Mask (to be shifted left) is in Q and is tested with E
; W2 is ored or bar&ed into W1
CAPR Y: Q&[E]_F,ALU_Y/YES,#2*Q_Q,                ;Test for set selected flags/enables
         IF CT [IZ] THEN [CAPRY2]
        [W2]BAR&[W1]_B                          ;Clear selected flags/enables
CAPRY2: Q&[E]_F,ALU_Y/YES,#2*Q_Q,                ;Test for clear selected flags/enables
        IF CT [IZ] RETURN
W2.OR.W1:
        [W2].OR.[W1]_B,                         ;Set selected flags/enables
        RETURN

.TOC 3, "RDAPR - Read APR Conditions"
;Conditions In, arithmetic processor
;        RDAPR,
;       +-------+---+---+---+
;       | 70024 | I | X | Y |
;       +-------+---+---+---+
;
; 0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;            \     flags    /                   \     flags     / | \   /
;                    |                                  |         |   + ---PIA
;                    |                                  |         + ---intrupt req
;                    |                                  + ---flags
;                    + ---flags enabled for interrupts

RDAPR:
        CALL [CI APR]
        GOTO [TO MEM]                           ;Store results and exit

;Here for RDAPR, SZAPR, or SNAPR,

CI APR: J[APR FLAGS]_RAMFILE ADR                ;Where we keep f1ags
        RAMFILE_[MEM-OP]
        SWAP [MEM-OP]_[W1]                      ;Put enables in RH
        [MEM-OP]&[W1]_Y,IX_MX                   ;Mask bits
        J[0010]_[W1],                           ;Bit for interrupt request
         IF CT [MZ] RETURN
        [W1].OR.[MEM-OP]_B,
         RETURN

.TOC 3, "SZAPR (CONSZ APR) - Skip on masked APR conditions all zero"
CONSZ APR:
SZAPR:
        CALL [CI APR]                           ;Get APR bits for CONI
        ZERO_[MEM-OP LH],
         GOTO [CONSZ]

.TOC 3, "SNAPR (CONSO APR) - Skip on any masked APR conditions non-zero"
CONSO APR:
SNAPR:
        CALL [CI APR]                           ;Get APR bits for CONI
        ZERO_[MEM-OP LH],
         GOTO [CONSO]


.TOC 2, "PI System"
.TOC 3, "WRPI - Write PI Conditions"
;Conditions Out, Priority Interrupt
;        WRPI,
;       +-------+---+---+---+
;       | 70060 | I | X | Y |
;       +-------+---+---+---+
;
; E bits
;       181920212223242526272829303132333435
;        \     / | | | | | | | 1 2 3 4 5 6 7
;         \   /  | | | | | | | \           /
;          \ /   | | | | | | |       + ---Select levels
;           |    | | | | | | + ---Turn on PI system
;           |    | | | | | + ---Turn off PI system
;           |    | | | | + ---Turn off level
;           |    | | | + ---Turn on level
;           |    | | + ---initiate interrupt on level
;           |    | + ---clear PI system
;           |    + ---drop program request on level
;           + ---should be zero

WRPI:
.IF/FT7PI
.IF/FTMBZ
        J[07400]_[W1]                           ;Mask for must be zero bits
        #4*[W1]_B,                              ;Shift 6 places and check
         CALL [LLS4 MBZ]
.ENDIF/FTMBZ
        BIT0_[W2]                               ;Bit for PI on
        J[0177]_[W3]                            ;Mask for chnl bits
        [W3]+1_Q,                               ; Put 200 in Q
         J[PI LVL REG]_RAMFILE ADR
        [E]&[W3]_B                              ;Leave only chnls to select
        RAMFILE_[W1],                           ;Get PI LVL REG from ramfile
         CALL [CAPR X]                          ; Test for PION/PIOFF
.ENDIF/FT7PI
.IFNOT/FT7PI
.IF/FTMBZ
        J[07401]_[W1]                           ;Mask for must be zero bits
        #4*[W1]_B,                              ;Shift 6 places and check
        CALL [LLS4 MBZ]
.ENDIF/FTMBZ
        BIT0_[W2]                               ;Bit for PI on
        [K 77]_[W3]                             ;Mask for chnl bits
        [W3]+1_Q,                               ; Put 100 in Q
         J[PI LVL REG]_RAMFILE ADR
        [E]&[W3]_B                              ;Leave only chnls to select
        RAMFILE_Y,Y_[W1] QLS_Q,                 ;Put PI LVL REG in W1
        QION_SIO0 #0_QIO0,                      ; Put 200 in Q
        CALL [CAPR X]                           ; Test for PION/PIOFF
.ENDIF/FT7PI
        [W3]_[W2],                              ;Test for turn off/on levels
        CALL [CAPR Y]                           ; Set/clear bits in W1
        [W1]_RAMFILE                            ;Save updated PI LVL REG
        J[PI SFT REQ]_RAMFILE ADR
        Q&[E]_F,ALU_Y/YES,#2*Q_Q,IX_MX           ;Test for initiate int on level
        RAMFILE_[W2],                           ;Get software interrupt requests
         IF CT [MZ] THEN [C PI 5]
        [W3].OR.[W2]_B,ALU_RAMFILE              ;Add new levels
C PI 5: Q&[E]_F,ALU_Y/YES,#2*Q_Q,                ;Test for clear PI system
         IF CT [IZ] THEN [C PI 6]
        CALL [RESET PI]                         ;Reset the PI system
        SET LOCAL, GOTOP [IFETCH]

C PI 6: Q&[E]_Y,                                ;Test for drop int on level
         IF CT [IZ] THEN [C PI 7]
        [W3]BAR&[W2]_B,ALU_RAMFILE              ;Clear some levels
C PI 7: CALL [SET PI SYSTEM]                    ;Setup PI hdw
        SET LOCAL,GOTOP [IFETCH]


;Here to reset the PI system

RESET PI:
        J[PI IN PROG]_RAMFILE ADR               ;Ints in progress in bits 29-35
        ZERO_Y,ALU_RAMFILE
        J[PI SFT REQ]_RAMFILE ADR               ;Software PI requests
        ZERO_Y,ALU_RAMFILE,
         INT OP/MASTER CLEAR                    ;bits 29-35 are levels on
        J[PI LVL REG]_RAMFILE ADR               ;bit 0 is PI system on/off flag
        ZERO_[PI REG],ALU_RAMFILE,
         Y_2914 STATUS,
        GOTO [SET PI SYSTEM]                    ;Set mask register

;Here to set up 2914 PI mask
SET PI MASK:
        J[PI LVL REG]_RAMFILE ADR               ;Address ramfile list of levels on
        J[0300]_[W2]                            ;Always enable level 0 and 1
        RAMFILE_[W1]                            ;Get levels from ramfile
        [W1]_Y,
         IF NOT CT [IN] THEN [SPM 7]
        [W1].OR.[W2]_B                          ;Enable software levels also
SPM 7:  COMPLEMENT [W2]_F,F_Y,                  ;Load mask with PIs to permit
        Y_2914 MASK,
         RETURN

;Here to setup PI system

SET PI SYSTEM:
        CALL [SET PI MASK]
        ;GOTO [SET PROC REG]


;PROC REG (Processor register)
; 0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;             \   /                             \ / |\    / \           /
;               |                                |  |  |          + ---PI req
;               |                                |  |  + ---Line PI reg
;               |                                |  + ---IO reset
;               + ---Current AC block            + ---reserved
;
;Ramfile word [PROC REG]
;0 1 2 3 4 5 6 7 8 91011l2l3l41516l7l81920212223242526272829303132333435
;            \   / \   /                       \ /   \   /
;              |     + ---Prev ctxt AC block    |      + ---Line PI lvl
;              + ---Current AC block            + ---reserved


;Here to set up hardware PROC reg according to Ramfile
; Called whenever APR/TTY/SoftwarePIReq change
; Uses W1-W4
 SET PROC REG:
        J[PI SFT REQ]_RAMFILE ADR               ;Ramfile list of software pi reqs
        RAMFILE_[W4]
        J[APR FLAGS]_RAMFILE ADR                ;Address APR flags
        RAMFILE_[W1]                            ;Get APR flags
        SWAP [W1]_[W2]                          ;Swap flags and enables
        [W1]&[W2]_Y,                            ;Check for flags with enables
        IF NOT CT [IZ] CALL [SPR 77]            ;Set request level
        J[04000]_[W1]                           ;Will become 020000
        J[02220]_Y24-Y35,                       ;Mask for flags -022220
        [W1]+[W1]_F,F_LSZ Y_[W1]
        [W1]_Q,J[7]_CTR                         ;Save mask
         J[LNOSW]_[W3],Y_RAMFILE ADR            ;Address line block
SPR 2:  RAMFILE_[W1]                    ;Get status for line
        Q&[W1]_F,LSZ F_[W2],                    ;Check for any flags set
         IF CT [IZ] THEN [SPR 4]
        [W1]&[W2]_Y,                            ;Check for enables for flags
         IF NOT CT [IZ] CALL [SPR 77]           ; Set int req
SPR 4:  J[010]_[W1]                             ;To make next line adr
        [W1]+[W3]_B,Y_RAMFILE ADR,              ;Next block adr
         LOOP [SPR 2]
        J[PROC REG]_RAMFILE ADR                 ; Address ramfile copy of proc reg
        RAMFILE_[W3]                    ;Get ramfile copy of proc reg
SET RFPRG:
        J[RF PROC REG]_RAMFILE ADR
        [W4].OR.[W3]_Y,ALU_RAMFILE
        [W4].OR.[W3]_Y,ALU_PROC REG,            ;Change software interrupts
         RETURN

SPR 77: J[7]_[W2]                               ;Mask for PI level
        [W2]&[W1]_B,IF CT [IZ] RETURN           ;If no channel dismiss
        J[BIT28]_[W2]                           ;Base to index into bit table
        [W2]+[W1]_Y,Y_RAMFILE ADR               ;Make bit for our level
        RAMFILE_[W1]                    ;Get bit for interrupt
        [W1].OR.[W4]_B,RETURN                   ; Set 1evel


.TOC 3, "RDPI - Read PI Conditions"
;Conditions In, Priority Interrupt
;        RDPI,
;       +-------+---+---+---+
;       | 70064 | I | X | Y |
;       +-------+---+---+---+
;
;0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;                      1 2 3 4 5 6 7       1 2 3 4 5 6 7 | 1 2 3 4 5 6 7
;                      \           /       \           / | \           /
;                            |                   |       |       + ---levels on
;                            |                   |       + ---PI system on
;                            |                   + ---interrupt in progress on
;                            + ---program requests on

RDPI:
        CALL [CPI]                              ;Get PI bits
        J[PI SFT REQ]_RAMFILE ADR               ;Get software requests
        RAMFILE_[W1]                    ;Get software requests
        SWAP [W1]_[MEM-OP LH],
         GOTO [TO MEM]                          ;Give user result

;Here from CONI PI, or CONSO PI, or CONSZ PI
; Returns bits in MEM-OP, and 177 in W1
CPI:    J[PI LVL REG]_RAMFILE ADR               ;Get PI levels on
        J[0177]_[W1]                            ;Mask for levels
        RAMFILE_Y,[W1]_F,F_Q Y_[W1]
        J[PI IN PROG]_RAMFILE ADR
        [W1]_Y,IX_MX                            ;Test for PI on
        Q&[W1]_[MEM-OP],                        ;Leave only PI levels on
         IF NOT CT [MN] THEN [CP12]             ; Branch if PI OFF
        Q+[MEM-OP]+1_F,F_[MEM-OP]               ;Add 200 to MEM-OP
CP12:   RAMFILE_[W1],PUSH J[3]_CTR
        #4*[W1]_B,RFCT                           ;Shift left 8 places
        [W1].OR.[MEM-OP]_B,                     ;Add interrupts in progress
         RETURN

.TOC 3, "SZPI - Skip on masked PI conditions all zero"
SZPI:
        CALL [CPI]                              ;Get bits to test in MEM-OP
CONSZ:  [MEM-OP]&[E]_Y,
         SET LOCAL,
         IF NOT CT [IZ] THENP [IFETCH]
        [PC]+1_[PC RH],
         GOTOP [IFETCH]

.TOC 3, "SNPI - Skip on any masked PI conditions non-zero"
SNPI:
        CALL [CPI]                              ;Get bits to test in MEM-OP
CONSO:  [MEM-OP]&[E]_Y,
         SET LOCAL,
         IF CT [IZ] THENP [IFETCH]
        [PC]+1_[PC RH],
         GOTOP [IFETCH]

.TOC 2, "Pager"
.TOC 3, "WREBR - Write Executive Base Address"

;        WREBR
;       +-------+---+---+---+
;       | 70120 | I | X | Y |
;       +-------+---+---+---+
;
; E format
;       181920212223242526272829303132333435
;       \    / | | \                       /
;        \  /  | |           + ---Executive base address (page number)
;         |    | + ---Enable Pager
;         |    + ---Tops20 Paging
;         + ---should be zero

WREBR:
.IF/FTMBZ
        J[07000]_[W1]
        #4*[W1]_B,
         CALL [LLS4 MBZ]
.ENDIF/FTMBZ
        CALL [PAGE TABLE CLEAR]                 ;Clear entire page table
        [E]_[W1],                               ;Get page number
        CALL [W1(22) LLS9]
        J[BIT22]_RAMFILE ADR                    ;Mask for enable
        Q&[W2]_[EPT],SET TOPS20                 ;Set new EPT
        [E]_Q RAMFILE_[W2],CLEAR PAGED          ;Get bit for enable
        [W2]&[E]_F,ROR F_B ROR Q_Q,
         IF NOT CT [IZ] CALL [SET PAGED LATCH]
.IF/FT10PAG
.IF/FT20PAG
        Q&[W2]_Y,
        IF NOT CT [IZ] THEN [TO NOWHERE]
.ENDIF/FT20PAG
        CLEAR TOPS20,
        GOTO [TO NOWHERE]
.ENDIF/FT10PAG
.IFNOT/FT10PAG
        SET LOCAL,
        GOTO [IFETCH]
.ENDIF/FT10PAG

SET PAGED LATCH:
        SET PAGED,RETURN

;Here to shift W1 left 9 places and get 22 bit mask
W1(22) LLS9:
        J[#22B MASK]_RAMFILE ADR                ;Mask for EPT adr

;Here to shift W1 left 9 places, leave it in Q and W1 and read ramfile into W2
W1 LLS9:
        #2*[W1]_[W1],PUSH J[3]_CTR              ;Shift left 1 place
        #4*[W1]_B,RFCT                          ;Keep shifting 2 at a time
        [W1]_Q RAMFILE_[W2],                    ;Get ramfile
         RETURN

.IF/FTMBZ
LLS4 MBZ:
        #4*[W1]_B
        #4*[W1]_B
        [W1]&[E]_Y,
         IF CT [IZ] RETURN
        GOTO [MUUO]
.ENDIF/FTMBZ

.TOC 3, "RDEBR - Read the Executive Base Address"

;        RDEBR
;       +-------+---+---+---+
;       | 70124 | I | X | Y |
;       +-------+---+---+---+
;
; E format
;       181920212223242526272829303132333435
;       \    / | | \                       /
;        \  /  | |           + ---Executive base address (page number)
;         |    | + ---Enable Pager
;         |    + ---Tops20 Paging
;         + ---reserved

RDEBR:
        J[BIT22]_RAMFILE ADR                    ;Bit for paging enabled
        [EPT]_[W1],
        CALL [W1 LLS9]
        SWAP [W1]_[W1],                         ;Put page number in right half
        IF [PAGED] CALL [W2.OR.W1]              ;We are paged
        #2*[W2]_[W2],                            ;Make a bit 21
         IF [TOPS20] CALL [W2.OR.W1]            ;Flag this is TOPS20
        [W1]_[MEM-OP],
         GOTO [TO MEM]

.TOC 3, "WRUBR (DATAO PAG) - Write User Base Address"

;        WRUBR
;       +-------+---+---+---+
;       | 70114 | I | X | Y |
;       +-------+---+---+---+
;
; 0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
; | | |       \   / \   /   \       / |         \                       /
; | | |        \ /   \ /     \     /  |                    + ---User Base adr (page #)
; | | |         |     |       \   /   + ---Do not update accounts
; | | |         |     |         + ---previous context section
; | | |         |     + ---previous context ac block
; | | |         + ---current ac block
; | | + ---load user base address
; | + ---select previous context section
; + ---select ac blocks

DATAO PAG:
WRUBR:
        READ [E]                                ;Get data word
        CALL [PAGE TABLE CLEAR]                 ;Clear entire page table
        BIT0_[W3]                               ;Get mask for enable
        J[PROC REG]_RAMFILE ADR,                ;Where we keep AC block numbers
         [W3]_Q                                 ;Save mask in Q reg
        Q&[MB]_F,F_Y LSRQ_Q,IX_MX               ;latch request to set AC blocks
        RAMFILE_[W3]                            ;Get old value for AC block numbers
        J[07700]_[4]                            ;Build mask for AC blocks
        SWAP [W4]_[W4],
         IF CT [MZ] THEN [DATOP2]               ;If do not want to set blocks
        [W4]BAR&[W3]_B                          ;Strip old AC blocks
        [MB]&[W4]_B                             ;New AC blocks
        [W4].OR.[W3]_B,ALU_RAMFILE,
         CALL [SET RFPRG]
DATOP2: Q&[MB]_F,F_Y LSRQ_Q,                    ;Check for select prev context sect
          IF CT [IZ] THEN [DATOP4]
        J[PCS]_RAMFILE ADR                      ;Previous context section
        J[037]_[W1]                             ;Get maskk for section
        SWAP [W1]_[W1]
        [W1]&[MB]_Y,ALU_RAMFILE                 ;Save previous context section
DATOP4: Q&[MB]_Y,                               ;Check for load UBR
         IF CT [IZ] THENP [IFETCH]
        [MB]_[W1],                              ;Get page ruBber
         CALL [W1(22) LLS9]
        Q&[W2]_[UPT],                           ;Set new UPT
         GOTOP [IFETCH]

.TOC 3, "RDUBR - Read User Base Address"
;Data In, Pager
;        RDUBR
;       +-------+---+---+---+
;       | 70104 | I | X | Y |
;       +-------+---+---+---+
;
; 0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
; | | |       \   / \   /   \       /           \                       /
; | | |        \ /   \ /     \     /                       + ---User Base adr (page #)
; | | |         |     |       \   /
; | | |         |     |         + ---previous context section
; | | |         |     + ---previous context ac block
; | | + ---1    + --- current ac block
; | + ---1
; + ---1

RDUBR:
        CALL [GET CONTEXT WD]                   ;Get process context word
        [MB]_[MEM-OP],                          ;Put in right register
        GOTO [TO MEM]

;Here to get a "process context word"
GET CONTEXT WD:
        [UPT]_[W1],                             ;Put UPT page number in LH
         CALL [W1 LLS9]
        J[PCS]_RAMFILE ADR                      ;Previous context section
        SWAP [W1]_[W1]                          ;Put UPT page number in RH
        [W1]_Q RAMFILE_[W1]
        J[PROC REG]_RAMFILE ADR                 ;Get current AC block number
        Q.OR.[W1]_[MB]
        RAMFILE_[W1]
        [W1].OR.[MB LH]_B,                      ;Add AC blocks to word
         RETURN

.IF/FT20PAG
.TOC 3, "WRSPB - Write the SPT base address"
WRSPB:  READ [E]                                ;Get data
        [MB]_[SPT],                             ;Set SPT base adr, no checking
         GOTOP [IFETCH]

.TOC 3, "RDSPB - Read SPT base address"
RDSPB:  [SPT]_[MEM-OP],                         ;Get information he wants
         GOTO [TO MEM]

.TOC 3, "WRCSTM - Write CST Mask register"
WRCSTM:
        READ [E]                                ;Get data
        J[CSTMASK]_RAMFILE ADR                  ;Address ramfile
        [MB]_RAMFILE,                           ;Set mask register, no checking
         SET LOCAL,
        GOTOP [IFETCH]

.TOC 3, "RDCSTM - Read CST Mask register"
RDCSTM: J[CSTMASK]_RAMFILE ADR                  ;Address ramfile location
        RAMFILE_[MEM-OP],                       ;Get information he wants
         GOTO [TO MEM]

.TOC 3, "WRPUR - Write process use register (CSTDATA)"
WRPUR: READ [E]                                 ;Get data
       J[CSTDATA]_RAMFILE ADR                   ;Address ramfile location for data
       [MB]_RAMFILE,                            ;Set data word (age) register
        SET LOCAL,
        GOTOP [IFETCH]

.TOC 3, "RDPUR - Read process use register (CSTDATA)"
RDPUR:  J[CSTDATA]_RAMFILE ADR                  ;Address ramfile location for data
        RAMFILE_[MEM-OP],                       ;Get information he wants
         GOTO [TO MEM]

.TOC 3, "WRCSB - Write Core status table base address"
WRCSB:  READ [E]                                ;Get data
        J[CST]_RAMFILE ADR                      ;Ramfile adr of CST
        [MB]_RAMFILE,                           ;Set CST register, no checking
         SET LOCAL,
         GOTOP [IFETCH]

.TOC 3, "RDCSB - Read Core status table base address"
RDCSB:  J[CST]_RAMFILE ADR                      ;Address Ramfile
        RAMFILE_[MEM-OP],                       ;Get information he wants
         GOTO [TO MEM]
.ENDIF/FT20PAG

.TOC 3, "CLRPT - Clear Page Tables"
CLRPT:  SET USER,CALL [CLR PTE]                 ;Clear user entry first
        CLEAR USER,CALL [CLR PTE]               ;Now clear exec entry
        GOTOP [IFETCH]

CLR PTE:
        [E]_Y,SECTION SELECT,
        SPEC SEL/PAGE TABLE ENTRY
ZERO RAMFILE:
        ZERO_Y,ALU_RAMFILE,                     ;Clear entry
         RETURN

.TOC 2, "Timer"
.TOC 3, "RDTIM - Read time base register"

;TIMER FLAG goes true 27 times/millisecond
;      note: 27.*37.=999.       note: 37.=45
;      note: 27.*148.=3996.     note: 148.=224
;Ramfile locations TIME & TIME+1 are 72bit u-second counter

RDTIM:  J[27.]_[MEM-OP]
        [MEM-OP]-[TIME]_A                       ;Number of clock ticks this ms
        ZERO_[MEM-OP+1],CALL [RDT 4]
        CALL [RDT 4]
        J[TIME BASE+1]_RAMFILE ADR
        #2*[MEM-OP]_[MEM-OP],
         CALL [RDT 4]
        RAMFILE_[MEM-OP]                        ;Get low order part of uptime
        J[TIME BASE]_RAMFILE ADR
        [MEM-OP]+[MEM-OP+1]_B,IX_MX
        RAMFILE_[MEM-OP],
         IF NOT CT [MOVR] THEN [D TO MEM]
        [MEM-OP]+1_[MEM-OP],
         GOTO [D TO MEM]

;Shift MEM-OP left 2 then add to MEM-OP+1
RDT 4:  #4*[MEM-OP]_B                           ;Shift two left
        [MEM-OP]+[MEM-OP+1]_B,
         RETURN

.TOC 3, "WRTIM - Write time base register"
WRTIM:  READ [E]                                ;Get high order bits
        J[TIME BASE]_RAMFILE ADR
        [MB]_Y,ALU_RAMFILE,                     ;Write high order bits
         CALL [READ NEXT]                       ;Get low order bits
        J[TIME BASE+1]_RAMFILE ADR
        [MB]_RAMFILE,                           ;Write low order bits
         SET LOCAL,
         GOTOP [IFETCH]

.TOC 3, "RDINT - Read Interval Timer register"
RDINT: J[TIME INTERVAL]_RAMFILE ADR             ;Address ramfile location he wants
        RAMFILE_[MEM-OP]
        #4*[MEM-OP]_B,                          ;Display as u-seconds
        GOTO [TO MEM]

.TOC 3, "WRINT - Write Interval Timer register"
WRINT:  READ [E]
        J[INTERVAL COUNTER]_RAMFILE ADR         ;Start interval counter again
        [MB]+1_F,B SEL/MB,
         LRS F_B,#0_SION #0_QION
        [MB]+1_F,B SEL/MB,
         LRS F_B,#0_SION #0_QION,
         ALU_RAMFILE
        J[TIME INTERVAL]_RAMFILE ADR            ;Save for restarting counter
        [MB]_RAMFILE,
         SET LOCAL,
         GOTOP [IFETCH]

.TOC 2, "Halt Status Block"
.TOC 3, "WRHSB - Write Halt Status Block Address"

WRHSB:  READ [E]                                ;Get new value for HSB
        J[HSB]_RAMFILE ADR                      ;Address ramfile
        [MB]_RAMFILE,                           ;Put new value in ramfile
         SET LOCAL,
         GOTOP [IFETCH]

.TOC 3, "RDHSB - Read Halt Status Block Address"

RDHSB:  J[HSB]_RAMFILE ADR                      ;Address of halt status block
        RAMFILE_[MEM-OP],
         GOTO [TO MEM]

.TOC 2, "PCI Devices"
.TOC 3, "RDTTY - Read TTY Conditions"

;Status word in ramfile
;
; 0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
; | | \     CR      / | |       \   / | | |         | | | | \ RCV /\    /
; | |        |        | |         |   | | |         | | | | | | | |  + ---PI chn 1
; | |        |        | |         |   | | |         | | | | | | | + ---xof flag
; | |        |        | |         |   | | |         | | | | | | + ---xof enable
; | |        |        | |         |   | | |         | | | | | + ---rcv done
; | |        |        | |         |   | | |         | | | | + ---rcv int enable
; | |        |        | |         |   | | |         | | | + ---xmt done
; | |        |        | |         |   | | |         | | + ---xmt enable
; | |        |        | |         |   | | |         | + ---dataset change flag
; | |        |        | + ---SR6  |   | | |         + ---data set change enable
; | |        |        + ---SR7    |   | | + ---Nxm or mem err on rcv
; | |        + CR7 ... CRO        |   | + ---Nxm or mem err on xmt
; | + Half duplex.                |   + ---flag for TTYRCV BITS
; + ---DDT mode.                  + ---protocol
;
;Mode word in ramfile
;0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;\      / \        / \             / \                                 /
;   |         |             + ---MR17-MR10            + ---CRC seed
;   |         + ---MR25-MR20
;   + ---reserved
;
;Syn word in ramfile
;0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;                       \              / \             / \             /
;                              |                 |              + ---Syn1 char
;                              + ---OLE char     + ---Syn2 char
;
;CRC word in ramfi1e
;0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;   \                                /   \                             /
;                   + ---Incoming CRC                   + ---Outgoing CRC
;
;Transmit and receive header words
; 0 1 2 3 4 5 6 7 8 9101112131415161718192021222324252627282~303132333435
; \                         / \                                         /
;             + ---reserved                      + ---phys adr of current header
;
;
;Transmit and receive byte pointer words
; 0 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829303132333435
;\                      /\                                           /\ /
;             |                                |                       + ---byte number
;             + ---byte count                  + ---phys adr of byte word


.IF/DEBUGTTY
RDTTY:  [E]_Y, Y_TTY ADR                        ;Address register
        PCI_ALU,Y_[MEM-OP]                      ;Read register
        PCI_ALU,Y_[W1]                          ;Get 2nd half
        SWAP [W1]_[MEM-OP LH],
        GOTO [TO AC.0]
.ENDIF/DEBUGTTY


;Here to reset a PCI line

.IF/FTTTYR
RESET PCI:
        [K -1.0]&[W6]_Y,IX_MX                   ;Check for CTY
        J[0200]_[W5]                            ;Transmit done
        [W6]_Y,Y_RAMFILE ADR,                   ;Address status word
         IF NOT CT [MZ] THEN [RPC11]
        J[04200]_[W1]                           ;For RTS & DTR
        #4*[W1]_B
        SWAP [W1]_[W5 LH]                       ;Put in LH
RPC11:  [W5]_Y,ALU_RAMFILE,                     ;Update status word
        CALL [SET PCI CR]
        [W6]+1_F,F_Q_Y,Y_RAMFILE ADR,           ;Address of Mode word
         J[5]_CTR
        ZERO_[W1 RH]                            ;Clear CRC seed
        RAMFILE_[W1 LH],                        ;Get mode word
         CALL [W1_RAMFILE]
RPC12:  Q+1_F,F_Y,Y_RAMFILE ADR                 ;Address next ramfile word
        ZERO_Y,ALU_RAMFILE,                     ;Zero next location
         LOOP [RPC12]
        ;GOTO [SET USART MODE]
        RETURN
.ENDIF/FTTTYR

;Here to set mode register in USART line
; Call with [W6]-linenumber,,adr of ramfile line block

SET PCI MODE:
        J[A1!A0]_[W1]                           ;Address bits for CR
        ZERO_[W2],CALL [WR PCI]                 ;Clear command register
        [W6]+1_Y,Y_RAMFILE ADR,                 ;Address mode word
         CALL [RAMFILE_W1]                      ;Get mode word from ramfile
        SWAP [W1]_[W1]                          ;Put mode words in RH
        J[A1]_[W2]                              ;Makes A1 for mode register
        SWAP [W6]_[W3],                         ;Get line number
         CALL [SUM 40]                          ; write MR1 & MR2
        [W1]_Y,ALU_MR2                          ;Write M8626 copy of MR2
        J[A0]_[W2];                             ;Set A0 for SYN1/SYN2/DLE
        J[LNXSYN]_[W1]                          ;Offset for syn word
        [W6]+[W1]_Y,Y_RAMFILE ADR               ;Address ramfile word
        RAMFILE_[W1],                           ;Get synchs and OLE chars
        CALL [SUM 40]                           ;Write SYN1, SYN2 registers
        CALL [SUM 1]                            ;Write DLE register
        [W6]_Y,Y_RAMFILE ADR                    ;Address ramfile copy of CR
        RAMFILE_[W5],                           ;Set CR according to ramfile
         GOTO [SET PCI CR]

;Here to set 2651 mode or syn registers
; Call with MR2, MR1 as low order 8-bit bytes in W1,
; and with A1 or AO in W2 and line number in W3

SUM 40: [W2]+[W3]_Y,Y_TTY ADR                   ;Address line and mode registers
        [W1]_Y,ALU_PCI                          ;Write MR1/SYNl
SUM 1:  #4*[W1]_B,                              ; Shift 1eft 2 at a time
         J[3]_CTR
SUM 2:  #4*[W1]_B,                              ;Shift left 2 at a time
         LOOP [SUM 2]                           ; 10 all together
        SWAP [W1]_[W1]
        [W1]_Y,ALU_PCI,                         ;Write MR2/SYN2
         RETURN

;Here to set PCI CR
SET PCI CR:
;       SWAP [W5]_[W2],J[4.]_CTR                ;Copy CR
;SPCR2: #4*[W2]_B,LOOP [SPCR2]                   ;Shift left 10 places
;       SWAP [W2]_[W2]                          ;Right justify CR
        ROL [W5]_[W2],J[8.]_CTR                 ;Copy CR from status word
SPCR2:  ROL [W2]_[W2],LOOP [SPCR2]              ;Put CR in W2 rh
        [K -1.0]&[W6]_Y,IX_MX                   ;Check for CTY line
        J[A1!A0]_[W1]                           ;Address bits for CR
        SWAP [W6]_[W1],F_Q,B[W1]_F              ;Get line number
        Q+[W1]_Y,Y_TTY ADR,                     ;Address command register
         IF CT [MZ] THEN [SPCR7]
        [W2]_Y,ALU_PCI,                         ;Write CR
         RETURN
;Here when writing CR for CTY
SPCR7:  J[4]_[W1]                               ;Bits we always leave on in CTY
        [W1].OR.[W2]_Y,ALU_PCI,                 ;Write CR
        RETURN

;Here for a transmitter interrupt for a PCI line
; call with adr of line status register in W6. and status in W5
INT XMT:
        [K -1.0]&[W6]_Y,                        ;See if this is the cty
         IF NOT CT [IZ] THEN [XINT10]           ; Branch if not cty
        J[CMDFLG]_RAMFILE ADR                   ;Address console flags
        RAMFILE_[W1]
        J[CMRTKR]_RAMFILE ADR                   ;Get taker for response buffer
.IF/FTCRAM
        RAMFILE_[W2]                            ;If no data stop transmitter
        [W2]_[W2],                              ;Let latches go
         IF CT [IZ] THEN [XINT05]
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[W2],                           ;If no data stop transmitter
        IF CT [IZ] THEN [XINT05]
.ENDIF/FTCRAM
        J[F.S]_[W2]                             ;Xoff flag
        [W1]&[W2]_Y,                            ;If Xoff stop typing
         IF NOT CT [IZ] THEN [XINT95]
        CALL [CMB NXT]                          ;Get next byte
        CALL [XMT CHR]                          ;Type it
        J[CMRPTR]_RAMFILE ADR                   ;Get response putter
        RAMFILE_[W1]
        J[CMRTKR]_RAMFILE ADR                   ;Address response taker
        RAMFILE_[W2]
        [W1].XOR.[W2]_Y,                        ;Check for buffer empty
         IF CT [IZ] CALL [CMRBUF FLUSH]
        GOTO [CMDC X]                           ;Process waiting commands if any

XINT05: [BIT4]&[W1]_Y,                          ; (f.USR) Exec mode-shut off xmtr
         IF CT [IZ] THEN [XINT95]

;Here because line is in user mode
XINT10:
        J[LNXXHD]_[W4]                          ;Offset for header
.IF/FTDDTM
        [W5]_Y,
         IF NOT CT [IN] THEN [XINT30]           ;Check for DDT mode

;Here because line is in DDT mode
        [W6]+[W4]+1_Y,Y_RAMFILE ADR             ;Address ramfile word
.IF/FTCRAM
        RAMFILE_[W1]                            ;Get next char to type
        [W1]_[W1],                              ;Let latches go
         IF CT [IZ] THEN [XINT95]               ; If nothing shut down
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_[W1],                           ;Get next char to type
         IF CT [IZ] THEN [XINT95]               ; If nothing shut down
.ENDIF/FTCRAM
        ZERO_Y,ALU_RAMFILE,                     ;Have sent char now
         CALL [XMT CHR]                         ; Type char
        CALL [SET XDN]                          ;Set done flag in status wcrd
        GOTOP [PCI INT CLR]                     ;Here because line is not in DDT mode
.ENDIF/FTDDTM

XINT30:
        J[0400]_[W1]                            ;Will become CR0
        SWAP [W1]_[W1]                          ;Makes CRO
        [W5]&[W1]_Y,
         IF CT [IZ] THEN [XINT95]
;Here to get next byte from buffer
        J[XMT TTY PF]_[W1]
        CALL [SET PF RCOVR]
        J[#24B MASK]_RAMFILE ADR
        RAMFILE_[W2],                           ;Get 24 bit Mask
         CALL [NXT RX WRD]
        ROL [PMA]_[W1],IX_MX                    ; byte #ab, a_MN
        ROL [W1]_[W1],                          ;Byte #ab, B_MN
         IF NOT CT [MN IX_MX] THEN [XINT70]
        IF NOT CT [MN] THEN [XINT72]            ;Check for byte 2 or 3
        GOTO [XINT73]
XINT70: SWAP [MB]_[MB],                         ;Enter here for byte 0
         IF CT [MN] THEN [XINT73]               ;Check for byte 0 or 1
XINT72: #2*[MB]_[MB],J[3]_CTR                    ;Enter here for byte 2
XINT74: #4*[MB]_B,LOOP [XINT74]
        SWAP [MB]_[MB]                          ;Enter here for byte 1
XINT73: [MB]_[W1],CALL [XMT CHR]                ;Enter here for byte 3
        IF NOT CT [UZ] THENP [PCI INT CLR]      ;Check for buffer exhausted
XINT93: CALL [SET XDN]                          ;We are done with buffer
        J[LNXXHD]_[W4]                          ;Got clobbered so restore
        [W6]+[W4]_Y,Y_RAMFILE ADR               ; Addr RF copy of current hdr addr
        RAMFILE_[PMA],                          ;Get adr of header
         CALL [CHNG2]                           ; write pointer back
        CALL [GET NXT RX HDR]                   ;Get header for next buffer
        IF CT [UOVR] CALL [CLR XGO]             ;We have now stopped
PCI INT CLR:
.IF/DEBUG3
        J[POOP FLAG]_RAMFILE ADR
        ZERO_Y,ALU_RAMFILE
.ENDIF/DEBUG3
        ZERO_[W1],CALL [SET PF RCOVR]           ; FIXME:
         [PXCT]_[PI REG], Y_2914 STATUS,        ; Restore previous level
         GOTOP [CONSOLE]                        ;This is not reatly an int

;Here because memory error reading transmit buffer

XINT91: ROR [BIT17]_[W1]                        ;Need to make a bit 19
        ROR [W1]_[W1]                           ;Make a bit 19
        [W1].OR.[W5]_B,                         ;5et xmtr err bit
         GOTO [XINT93]                          ; and stop transMitter

;Here when page fail (=nxm or mem fault)
XMT TTY PF:
        ROR [BIT17]_[W1]                        ;Make a bit 18
        ROR [W1]_[W1]                           ;Make a bit 19
        [W1].OR.[W5]_B,                         ;Set xmt mem err flag
         CALL [SET XDN]                         ; And flag transMitter stopped
        CALL [CLR XGO]                          ;Clear CRO in status word

;Here to stop the transmitter
XINT95: CALL [CLR PCI TXEN]                     ;Disable transmitter
        GOTOP [PCI INT CLR]

;Here to get next word fra. transmit or receive buffer
; Call with LNXXHD or LNXRHD in W4, 24b mask in W2
; Returns with word :n ~
;       Returns UZ if count expires

NXT RX WRD:
        [W6]+[W4]+1_F,F_Y,Y_RAMFILE ADR         ;Address byte pointer
        RAMFILE_[PMA]                           ;Get byte header
        [PMA]-[W2]_A,                           ; Increment pointer, decrement count
        ALU_RAMFILE                             ; save updated byte pointer
        [W2]BAR&[PMA]_Y,IX_UX                   ;Set UZ if count has expired
        ROR [PMA]_[PMA]                         ;Address of word which haS byte
        ROR [PMA]_[PMA],                        ;Divide by 2
         GOTO [UNMAPPED READ 0]                 ; get word


;Here to get next receive or transmit header
; CALL with LNXXHD or LNXRHD in W1
GET NXT RX HDR:
        [W6]+[W4]_Y,Y_RAMFILE ADR               ;Address ramfile
.IF/FTTTYSB
        RAMFILE_[PMA],                          ;Get address of header
        CALL [UNMAPPED READ 0]                  ;Get header status
        [BIT17]&[MB]_Y,                         ;Check for stop on buffer
         IF NOT CT [IZ] THEN [SET UOVR]
.ENDIF/FTTTYSB
.IFNOT/FTTTYSB
        RAMFILE_[PMA]                           ;Get adr of header
.ENDIF/FTTTYSB
        [PMA]+2_B,MEM START READ,               ;ftakes adr of next header adr
        CALL [UNMAPPED READ]
        [W6]+[W4]_Y,Y_RAMFILE ADR               ;Address LNXXHD or LNXRHD
        [MB]_[PMA],ALU_RAMFILE,                 ;Save adr of new header
         IF CT [IZ] THEN [SET UOVR]
GET RX HDR:
        [PMA]+1_[PMA],MEM START READ,           ;Get byte pointer for new header
        CALL [UNMAPPED READ]
        J[#24B MASK]_RAMFILE ADR
        RAMFILE_[W1]                            ;Get mask for count
        [W1]BAR&[MB]_F,F_Y,                     ;Check count field
         IF CT [IZ] THEN [SET UOVR]
        [W6]+[W4]+1_F,F_Y,Y_RAMFILE ADR
        [MB]_RAMFILE,#0_UOVR,                    ;Save new pointer
        RETURN

;Here to transmit a char on a 2651 line
; Call with [W6]-line number,,adr of ramfile line block, char in W1

XMT CHR:
        SWAP [W6]_[W2]                          ;Put line number in RH
        [W2]_Y,Y_TTY ADR                        ;Address line and mode registers
        [W1]_Y,ALU_PCI,                         ;Transmit character
         RETURN

;Here to clear LS.RGO in LNXSWD
CLR RGO:
        J[02000]_[W1]                           ;Bit to clear
        [W6]_Y,Y_RAMFILE ADR,                   ;Address the status word
        GOTO [CLR RXGO]

;Here to stop transmitter
CLR XGO:
        [W6]_Y,Y_RAMFILE ADR                    ;Address the status word
        J[0400]_[W1]                            ;Will become CR0
CLR RXGO:
        SWAP [W1]_[W1]                          ;Make CRO
        [W1]BAR&[W5]_B,ALU_RAMFILE,             ;Write updated status
         RETURN

;Here to set LS.RDN in LNXSWD
SET RDN:
        J[LS.RDN]_[W1]                          ;Bit to set
        [W6]_Y,Y_RAMFILE ADR,
        GOTO [W1!W5_RAMFILE]

.IF/FTTTYF
;Here to clear LS.RDN in LNXSWD
CLR RDN:
        J[LS.RDN]_[W1]                          ;Bit to set
        [W6]_Y,Y_RAMFILE ADR
W1BAR&W5_RAMFILE:
        [W1]BAR&[W5]_B,ALU_RAMFILE,             ;Write updated status
        GOTO [SET PROC REG]
.ENDIF/FTTTYF

;Here to set LS.XDN in LNXSWD
SET XDN:
        J[LS.XDN]_[W1]                          ;Bit to set
        [W6]_Y,Y_RAMFILE ADR
W1!W5_RAMFILE:
        [W1].OR.[W5]_B,ALU_RAMFILE,             ;Write updated status
        GOTO [SET PROC REG]                     ; Adjust int requests

.IF/FTTTYF
;Here to clear LS.XDN in LNXSWD
CLR XDN:
        J[LS.XDN]_[W1]                          ;Bit to set
        [W6]_Y,Y_RAMFILE ADR,
        GOTO [W1BAR&W5_RAMFILE]
.ENDIF/FTTTYF

;Here to set TXEN = transmit enable in a PCI
; call with   [W6] = line #,,x
;             clobbers W1, W2
SET PCI TXEN:
        [BIT17]+1_[W2],                         ;Get bit for TXEN
         CALL [RD PCI CR]
        [W1].OR.[W2]_Y,ALU_PCI,                 ;Set bit
         RETURN

;Here to clear TXEN = transmit enable in a PCI
; call with   [W6] = line #,,x
;            clobbers W1 & W2
CLR PCI TXEN:
        [BIT17]+1_[W2],                         ;Get bit for TXEN
        CALL [RD PCI CR]
        [W2]BAR&[W1]_Y,ALU_PCI,                 ;Clear bit
         RETURN

;Here to set RXEN  = receive enable in a PCI
; call with   [W6] = line #,,x
;             clobbers W1 & W2
SET PCI RXEN:
        J[RXEN]_[W2]                            ;Get bit for RXEN
        CALL [RD PCI CR]
        [W1].OR.[W2]_Y,ALU_PCI,                 ;Set bit
         RETURN

;Here to clear RXEN = receive enable in a PCI
; call with   [W6] = line #,,x
;             clobbers W1 & W2

CLR PCI RXEN:
        J[RXEN]_[W2]                            ;Get bit for RXEN
        CALL [RD PCI CR]
        [W2]BAR&[W1]_Y,ALU_PCI,                 ;Clear bit
         RETURN

;Here to read PCI SR register
RD PCI SR:
        J[A0]_[W1]                              ;Address of status register
        SWAP [W6]_[W1] F_Q,B[W1]_F,             ;Get line number
        GOTO [RDPCI2]

;Here to read PCI CR register
RD PCI CR:
        J[A1!A0]_[W1]                           ;Bits to address command register
        ;GOTO [RD PCI]

;Here to read a PCI register
RD PCI: SWAP [W6]_[W1] F_Q,B[W1]_F              ;Get line number
RDPCI2: Q+[W1]_Y,Y_TTY ADR                      ;Address register
        PCI_ALU,Y_[W1],                         ;Read register
         RETURN

;Here to write a PCI register
; Call with A[1:0] in W1, and data in W2
WR PCI: SWAP [W6]_[W1] F_Q,B[W1]_F              ;Get line number
        Q+[W1]_Y,Y_TTY ADR                      ;Address register
        [W2]_Y,ALU_PCI,                         ;Write register
         RETURN

;Here for a receiver interrupt for a PCI line
; call with adr of line status register in W6, and status in W1
INT RCV:
        J[LNXRHD]_[W4]                          ;Offset for receive header
        SWAP [W6]_[W1] F_Q,ZERO_F,              ;Get line number
        CALL [RDPCI2]                           ;Read receiver register
        J[0377]_[W3]                            ;Mask to strip extraneous bits
        [W1]&[W3]_B,                            ;Strip extraneous bits
         CALL [RD PCI SR]                       ; and get SR
        J[070]_[W2]                             ;Mask for error bits
        [W2]&[W1]_B,                            ;Leave only error flags
         IF CT [IZ IX_UX] THEN [RINT2]
        J[0400]_[W2]                            ;Error flag
        [W2].OR.[W3]_B                          ;Add flag
        SWAP [W1]_[W3 LH]                       ;Add flags
RINT2:  [K -1.0]&[W6]_Y,                        ;See if this is the cty
        IF NOT CT [IZ] THEN [RINT10]            ; Branch if not cty
        J[0177]_[W2]                            ;Mask to strip parity
        [W3]&[W2]_F,F_Q FJ[034]_[W2]            ;^\ char
        J[CMDFLG]_RAMFILE ADR                   ;Address console flags
        Q-[W2]_Y,                               ;Check for typing ^\
        IF CT [IZ] THEN [CNTRL BKSLSH]
        RAMFILE_Y,Y_[W2]                        ;Get console flags
        [BIT4]&[W2]_Y,                          ;(F.USR) Branch if user mode
         IF CT [IZ] THEN [CONSOLE CHAR]         ;Treat as CTY input

;Here for a receive interrupt except for CTY in Console mode
; received char in W4
RINT10:
.IFNOT/FTDDTM
        [W4]+[W6]_Y,Y_RAMFILE ADR               ;Address char word
.ENDIF/FTDDTM
.IF/FTDDTM
        [W5]_Y, IX_MX                           ;Check status reg
        [W4]+[W6]_Y,Y_RAMFILE ADR,              ;Address char word
         IF NOT CT [MN] THEN [RINT30]           ; Branch if not DDT mode

;Here because line is in DDT mode
.IF/FTCRAM
        RAMFILE_[W2]                            ;Check for already holding
        [W2]_[W2],                              ;Let latches go
        IF CT [IZ] THEN [RINTI2]
.ENDIF/FTCRAM
.IFNOT/FTCRAM
        RAMFILE_Y,                              ;Check for already holding
        IF CT [IZ] THEN [RINT12]
.ENDIF/FTCRAM
        J[0420]_[W2]                            ;Overrun error
        [W2].OR.[W1]_B                          ;Add error flag
RINT12: SWAP [W1]_[W4 LH]                       ;Put flags in LH
        [W4]_RAMFILE                            ;Save character
        CALL [SET RDN]                          ;Set receiver done
        GOTOP [PCI INT CLR]
.ENDIF/FTDDTM

;Here because line is not in DDT mode
RINT30: J[02000]_[W1]                           ;Will become bit RXEN
        SWAP [W1]_[W1]                          ;Make RXEN
        [W5]&[W1]_Y,
        IF CT [IZ] THEN [RINT99]
;Here to put next byte into buffer
        J[RCV TTY PF]_[W1]
        CALL [SET PF RCOVR]
        J[#24B MASK]_RAMFILE ADR
        RAMFILE_[W2],                           ;Get 24 bit mask
        CALL [NXT RX WRD]                       ; Get word for char
        J[0777]_[W1]                            ;Mask for data
        ROL [PMA]_[W2],IX_MX                    ;Byte #ab, b_MN
        ROL [W2]_[W2],                          ;Byte #ab, a_MN
         IF NOT CT [MN IX_MX] THEN [RINT70]
        IF NOT CT [MN] THEN [RINT72]            ;Check for byte 2 or 3
        GOTO [RINT73]
RINT70: SWAP [W3]_[W3]                          ;Enter here for byte 0
        SWAP [W1]_[W1],                         ;Swap mask also
        IF CT [MN] THEN [RINT73]                ;Check for byte 0 or 1
RINT72: #2*[W3]_[W3]                             ;Enter here for byte 2
        #2*[W1]_[W1],J[3]_CTR
RINT74: #4*[W3]_B
        #4*[W1]_B,LOOP [RINT74]                  ;Shift mask also
RINT73: [W1]BAR&[MB]_B                          ;Enter here for byte 3
                                                ; Clear slot for byte
        [W3].OR.[MB]_B,                         ;Add new byte
        CALL [UNMAPPED WRITE]                   ; Save in buffer
        IF NOT CT [UZ] THEN [RINT99]            ;Check for buffer exhausted
RINT93: CALL [SET RDN]                          ;We are done with buffer
        J[LNXRHD]_[W4]                          ;Got clobbered so restore
        [W6]+[W4]_Y,Y_RAMFILE ADR               ;Addr RF copy of current hdr adr
        RAMFILE_[PMA],                          ;Get adr of header
         CALL [CHNG2]                           ; write pointer back
        CALL [GET NXT RX HDR]                   ;Get header for next buffer
        IF CT [UOVR] CALL [CLR RGO]             ;We have now stopped
RINT99: GOTOP [PCI INT CLR]                     ;Dismiss interrupt

;Here because memory error on receive
RINT91: ROR [BIT17]_[W1], J[1]_CTR              ;Need to make a bit 20
RINT92: ROR [W1]_[W1],LOOP [RINT92]             ;Rotate to bit20
        [W1].OR.[W5]_B,                         ;Add rcv mem err flag
         GOTO [RINT93]                          ; and stop transmission

;Here when page fail (=nxm or mem fault) on rcv
RCV TTY PF:
        ROR [BIT17]_[W1],PUSH J[1]_CTR          ;Make a bit 18
        ROR [W1]_[W1],RFCT                      ;Make a bit 20
        [W1].OR.[W5]_B,                         ;Set rcv mem err flag
         CALL [SET RDN]                         ; And flag transmitter stopped
        GOTO [PCI INT CLR]

;Here for a dataset change interrupt for a PCI line
INT DSC:
        CALL [RD PCI SR]                        ; Get status register
        J[0300]_[W2]                            ;Mask for DSD & DCD
        [W2]&[W1]_B,                            ;Leave only new DSD&DCD in W1
        CALL [SWAP W2_W2]                       ;Put mask in LH
        [W2]&[W5]_Q,                            ;Put only DSD & DCD in Q
         CALL [SWAP W1 W1]                      ;Put new status in LH
        Q.XOR.[W1]_F,F_Y,                       ;Check for change
         IF CT [IZ] THEN [IDSC3]
        [W2]BAR&[W5]_B                          ;Clear old status bits
        J[04000]_[W2 RH]                        ;Get bit to make dataset change
        #2*([W2]+[W2 RH])_B                     ;Makes dataset change bit
        [W2].OR.[W5]_Y,                         ;Set bits
         ALU_RAMFILE
IDSC3:  GOTOP [PCI INT CLR]                     ;Dismiss interrupt

SWAP W1_W1:
        SWAP [W1]_[W1],
        RETURN
SWAP W2_W2:
        SWAP [W2]_[W2],
        RETURN

;Here to accumulate CRC for character
; call with    [W1] char
;              [W2] CRC so far
;              [W3] CRC seed
.IF/FTCRC
CRC CALC:
        [W1].XOR.[W2]_F,F_B,
        J[7]_CTR
CRC 2:  [W2]_F,F LRS_[W2] SIO0_MC
         IF CT [MC] THEN [CRC 3]
        LOOP [CRC 2]
        RETURN
CRC 3:  [W3].XOR.[W2]_F,F_B,
         LOOP [CRC 2]
        RETURN
.ENDIF/FTCRC

.TOC 2, "External IO"

IO EFA:
        IF [USER] CALL [CHECK IO OK]            ;Give users MUUOs
        DISPATCH [DISPATCH 2]

TIOE:   [AC-OP]&[MEM-OP]_Y,                     ;Check for need to skip
         IF NOT CT [IZ] THENP [IFETCH],
         SET LOCAL
        [PC]+1_[PC RH],                         ; Skip
         GOTOP [IFETCH]

;TIOEB:

TION:   [AC-OP]&[MEM-OP]_Y,                     ;Check for need to skip
         IF CT [IZ] THEN [IFETCH],
         SET LOCAL
        [PC]+1_[PC RH],                         ; Skip
         GOTOP [IFETCH]

;TIONB:

WRIO:   RAMFILE_[MEM-OP],
        GOTO [WRIO.1]

WRIO.1: CALL [WRIOX]
        SET LOCAL,
         IF NOT CT [UOVR] THENP [IFETCH]
        GOTOP [IO PF]                           ;Win an IO page fail

;Here to to an IO write
; Call with data in [MEM-OP] and adr in [E]
; returns with UOVR if illegal
WRIOX:  [K 7777.-1]&[E]_B,#1_UOVR,              ;Strip extraneous bits
        CALL [VAL IO ADR]                       ; Validate IO address
        [E]_[PMA],START IO WRITE,               ;Put out IO address
         IF CT [MN] THEN [WRIO TTY]
        [MEM-OP]_[MEM-OP],ALU_IO                ;Perform transfer
        #0_UOVR,MEM HOLD,
         IF [NO BUS ERROR] RETURN
.IFNOT/FTCKBP
        IF [NOT MEM EXISTS] THEN [SET UOVR]
        IF [NOT MEM FAULT] RETURN
.ENDIF/FTCKBP
        #1_UOVR,RETURN                           ;Set error flag

;Here to do an IO write to a TTY register
WRIO TTY:
        [E]-[W1]_F,F_Y,
         IF CT [IN IX_MX] RETURN
        RAMFILE_[W3],                           ;Get old contents of word
         IF CT [MZ] THEN [WRIOTM]
        [MEM-OP]_[W5],ALU_RAMFILE,              ;Write word
        #0_UOVR
        [W2]&[E]_F,F_Q_Y,                       ;Test which word was written
        IF CT [IZ] THEN [WRIOTO]                ; Branch for wrote status reg
.IF/FTTTYF
        J[LNXXCHR]_[W2]                         ;Offset for xmt char
        Q-[W2]_F,F_Y,IX_MX                      ;See if wrote xmt char
        [W1]BAR&[W6]_B,                         ;Make adr of line block
         IF CT [IZ] THEN [WRIOT5]
.ENDIF/FTTTYF
        Q+[K -1]_F,F_Q_Y,
        IF CT [IZ] THEN [WRIOT12]
        Q+[K -1]_F,F_Q_Y,
        IF NOT CT [IZ] RETURN
WRIOT12:
        GOTO [SET PCI MODE]                     ;Wrote Synch reg

;Here because wrote status register
WRIOTO:
.IFNOT/FT7PI
        J[6]_[W1]                               ;Mask for PI channel
        [W1]&[MEM-OP]_Y,IX_MX
        ROR [W1]_[W1]:                          ;Make mask for bit 35
        IF NOT CT [MZ] THEN [WRIOT1]
        [W1]&[MEM-OP]_Y,                        ; Check for putting on channel 1
        IF NOT CT [IZ] THEN [MUUO]              ; Putting on chnl 1 illegal
WRIOT1:
.ENDIF/FT7PI
.IF/FTTTYR
        J[04000]_[W1]                           ;Make a bit 23 from this
        ROL [W1]_[W1]                           ;Makes a bit 23
        [W1]&[MEM-OP]_Y,                        ;Check for doing Reset
        IF NOT CT [IZ] THEN [RESET PCI]
.ENDIF/FTTTYR
        J[WRIO TMP]_RAMFILE ADR                 ;Address temp location
        [W5].XOR.[W3]_F,F_B,ALU_RAMFILE         ;Find flags which changed
        S SEL[W3],                              ;Check for transmit enable changed
         IF [B BIT 9] CALL [CHNG TXEN]
        J[BIT7]_RAMFILE ADR                     ;Address a bit 7
        RAMFILE_[W1]                            ;Get a bit 7
        [W1]&[W3]_Y,                            ;Check for RXEN changed
        IF NOT CT [IZ] CALL [CHNG RXEN]
        CALL [SET PCI CR]                       ;Set CR according to status word
        #0_UOVR,                                ;Flag WRIO won
        GOTO [SET PROC REG]                     ; Be sure ints are right

CHNG RXEN:
        J[LNXRHD]_[W4]                          ;Offset for receive header
        [W6]+[W4]_Y,Y_RAMFILE ADR,              ;Address ramfile copy
         #1_UOVR                                ; of current hdr adr
        [W1]&[W5]_Y,                            ;Check for went off or on
         IF NOT CT [IZ] THEN [SET RXEN]
        GOTO [CHNG2]

CHNG TXEN:
        J[0400]_[W1]                            ;Make a bit 9 = CR0
        SWAP [W1]_[W1]                          ;Offset for transmit header
        J[LNXXHD]_[W4]
        [W6]+[W4]_Y,Y_RAMFILE ADR,              ;Address ramfile copy
         #1_UOVR                                 ; of current hdr adr
        [W1]&[W5]_Y,                            ;Check went on or off
        IF NOT CT [IZ] THEN [SET TXEN]
CHNG2: [W6]+[W4]+1_F,F_Y,Y_RAMFILE ADR          ;Address ramfile copy of pointer
        RAMFILE_[MB],                           ;Get ramfile copy of pointer
         CALL [ZERO RAMFILE]                    ;Clear ramfile copy
        [PMA]+1_[PMA],                          ;Make adr of pointer in header
         CALL [UNMAPPED WRITE]
        J[WRIO TMP]_RAMFILE ADR
        RAMFILE_[W3],                           ;Get changed bits back
         RETURN

SET RXEN:
        RAMFILE_[PMA],                          ;Get current header adr
         IF NOT CT [IZ] CALL [GET RX HDR]
        IF CT [UOVR] CALL [CLR RGO]             ;In case lost
        GOTO [RSTWTM]

SET TXEN:
        RAMFILE_[PMA],                          ;Get adr of current header
         IF NOT CT [IZ] CALL [GET RX HDR]
        IF CT [UOVR] CALL [CLR XGO]             ;In case lost
RSTWTM: J[WRIO TMP]_RAMFILE ADR                 ;Address tmp loc again
        RAMFILE_[W3],RETURN                     ;Restore W3 and exit

.IF/FTTTYF
;Here because wrote XMT char word
WRIOT5: CALL [SET PCI TXEN]                     ;Be sure xmtr going
        [W6]_Y,Y_RAMFILE ADR                    ;Address status word
        RAMFILE_[W5],
         GOTO [CLR XDN]                         ;Clear transmit done int flag
.ENDIF/FTTTYF

;Here to write TTYRCV BITS
WRIOTM: [MEM-OP]_Y,ALU_RAMFILE,#0_UOVR,
        RETURN

BSIO:   [AC-OP].OR.[MEM-OP]_B,                  ;Add new bits we want
        GOTOP [WRIO.1]

;BSIOB:

BCIO:   [AC-OP]BAR&[MEM-OP]_B,                  ;Clear bits we do not like
        GOTOP [WRIO.1]

;BCIOB:

.TOC "Trap Handling"

;Here to store nothing
TO NOWHERE:
        SET LOCAL,
        IF [NOT TRAP] THENP [IFETCH]
        ;GOTOP [TRAP]

;Here at end of instruction to see if need to trap
TRAP:   J[0600]_[W1],CLEAR TRAP                 ;Trap flags
        SWAP [W1]_[PMA],SET LOCAL,
         IF [NOT PAGED] THENP [IFETCH]
        [PC FLAGS]&[PMA]_B,                     ;Check for need to do a trap
         IF CT [IZ] THENP [IFETCH]
        PUSH J[010]_CTR
        ROL [PMA]_[PMA],RFCT
        J[0420]_[W1]
        [W1]+[PMA]_B,
        CALL [U!E READ]
        GOTO [IFETCH 4]                         ;Do instruction

U!E READ:
        IF [EXEC] THEN [U!E R2]
        [UPT]+[PMA]_B,MEM START READ,
        GOTO [UNMAPPED READ]
U!E R2: [EPT]+[PMA]_B,MEM START READ,
        GOTO [UNMAPPED READ]

;Here to set overflow and trap 1
SET OV!T1:
        J[04002]_[W1],SET TRAP
        SWAP [W1]_[W1],
         GOTO [#64*W1!PCF]

SET TRAP 1:                                     ;Set trap 1
        J[0200]_[W1],SET TRAP                   ;Bit 28
        SWAP [W1]_[W1],                         ;Becomes a bit 10
         GOTO [W1!PCF]

SET TRAP 2:                                     ;Set trap 2
        J[0400]_[W1],SET TRAP                   ;Bit 27
        SWAP [W1]_[W1],                         ;Becomes bit 9
         GOTO [W1!PCF]

#64*W1!PCF:
        #4*[W1]_B,J[1]_CTR                       ;Shift bits left
SPCF 2: #4*[W1]_B,LOOP [SPCF 2]                  ;Keep shifting bits
W1!PCF: [W1].OR.[PC FLAGS]_B,
        RETURN

.TOC "Interrupt Handling"

;If this is a clock interrupt will return, but may clobber W2-W3
; If not clock will return to IFETCH
CHK INT:
        [K -1]+[TIME]_B,IX_MX,                  ;Assume clock & tick it
        MEM HOLD,                               ; do not mess up memory
        GRANT INTERRUPT,                        ; Grant interrupt
         IF [NOT TIMER FLAG] THENP [SKIP CHAIN]

;Here for an interrupt on level 0 ... clock
        [PI REG]_Y,Y_2914 STATUS,
        MEM HOLD,
         IF NOT CT [MZ] RETURN

;Here once/millisecond
        J[CLK W2]_RAMFILE ADR
        [W2]_RAMFILE
        J[CLK W3]_RAMFILE ADR
        [W3]_RAMFILE
        J[27.]_[TIME]                           ;Restart tick counter
        J[TIME BASE+1]_RAMFILE ADR
        J[4000.]_[W2]                           ;Will add four milliseconds
        [W2]_Q RAMFILE_[W2]                     ;Get timebase from ramfile
        Q+[W2]_F,F_Q_Y,ALU_RAMFILE,             ;Update time base in ramfile
         IF NOT CT [IOVR] THEN [LO12]
        JS[0000]_[W2]
        Q+[W2]_Y,ALU_RAMFILE                    ;With positive sign
        J[TIME BASE]_RAMFILE ADR                ;Address high order part of count
        RAMFILE_[W2]
        [W2]+1_Y,ALU_RAMFILE
LO12:   J[TIME INTERVAL]_RAMFILE ADR
        RAMFILE_[W2],IX_MX
        J[INTERVAL COUNTER]_RAMFILE ADR         ;Address the interval counter
        [W2]_Q RAMFILE_[W2],                    ;Get the interval counter
         IF CT [MZ] THEN [LO15]                 ; No interval = no counter
        [K -1]+[W2]_Y,ALU_RAMFILE,              ;Count this interval
         IF NOT CT [IZ] THEN [LO15]
        Q_Y,ALU_RAMFILE                         ;Reinitialize interval counter
        J[APR FLAGS]_RAMFILE ADR                ;Need to set interval flag in APR
        J[040]_[W2]                             ;Bit for interval
        [W1]_Q RAMFILE_[W2]
        Q.OR.[W2]_[W2],ALU_RAMFILE              ;Save updated APR FLAGS
        SWAP [W2]_[W3]                          ;Get enables
        [W2]&[W3]_Y,IX_MX                       ;Check for flag was enabled
        J[7]_[W3]                               ;Mask for PI level
        [W2]&[W3]_B,                            ;Check for zero PI level
         IF CT [MZ IX_MX] THEN [LO15]           ; If not enabled done
        J[BIT28]_[W2]                           ;Base to index into bit table
         [W2]+[W3]_Y,Y_RAMFILE ADR,             ;Address bit
        IF CT [MZ] THEN [LO15]                  ; If PI level=O done
        RAMFILE_[W3]                            ;Get bit
        J[RF PROC REG]_RAMFILE ADR              ;Address last value of PROC REG
        RAMFILE_[W2]                            ;Get last value of processor reg
        [W2].OR:[W3]_Y,ALU_RAMFILE              ;Save new last value of PROC REG
        [W2].OR.[W3]_Y,ALU_PROC REG             ;Change software interrupts
LO15:   J[CLK W2]_RAMFILE ADR                   ;Where we saved W2
        RAMFILE_[W2]
        J[CLK W3]_RAMFILE ADR                   ;Where we saved W3
        RAMFILE_[W3]
        [PMA]_[PMA],MEM START READ,             ;Restart memory read
         RETURN

;Here if interrupt is not clock
SKIP CHAIN:
        [TIME]+1_[TIME],                        ;Correct time register
         IF [NOT RUN] THENP [SKPC2]
        [K -1]+[PC RH]_B,POP                    ;Back up PC
SKPC2:  SET LOCAL,[PI REG]_[PXCT],POP           ;Save previous level
        #2914 STATUS_Y,Y_[PI REG],POP           ;Get PI REG in case of int
        J[7]_[W6],POP                           ;In case this is PI lvl 1 int
.IF/DEBUG3
        [W6]&[PXCT]_B
FOOEY:  [W6].XOR.[PXCT]_Y,
         IF CT [IZ] THEN [FOOEY]
.ENDIF/DEBUG3
        [W6]&[PI REG]_B,POP                     ;Clear extraneous bits
        IF [PXCT] CALL [SET CURRENT CTXT]
        [W6].XOR.[PI REG]_Y,                    ;Check level
         IF NOT CT [IZ] THEN [SKPC8]            ; If not 1evel 1 not PCI
.IF/DEBUG3
        J[POOP FLAG]_RAMFILE ADR
        RAMFILE_[W1]
POOP:   [W1]_[W1],
         IF NOT CT [IZ] THEN [POOP]
        ONES_F,F_Y,ALU_RAMFILE
.ENDIF/DEBUG3
        LINE #_[W1],POP                         ;In case this is a line int

;Contents of W1 (line # reg) are
;       bits 33-35 =line number
;       bit 31-32 =code, 0-receive, l-transmit, 2-dschange
;       bit 30 = 0
;       bit 29 = invalid
;       bits 0-28 = garbage
        J[0100]_[W2]                            ;Mask for invalid flag
SKPC5:  [W1]&[W2]_Y,                            ;Check for invalid flag
         IF NOT CT [IZ] THEN [SKPC5]            ;If not valid chase skip chain
        [W1]&[W6]_B                             ;Leave only line number
        SWAP [W6]_[W6 LH]                       ;Put line number in LH also
        #2*([W6]+[W6 RH])_B                      ;Makes 4*linel in W6 RH
        [W6]+[W6 RH]_F,                         ;Make 10*line#
         F_Q FJ[LNOSW]_[W6 RH]                  ; adr of first line block
        Q+[W6]_[W6 RH],                         ;Leaves line#,,line block adr
         Y_RAMFILE ADR
        RAMFILE_[W5]                            ;Get status word for line
        J[010]_[W2]                             ;Mask for dispatch
        [W1]&[W2]_Y,                            ;Check for transmit
         IF NOT CT [IZ] THENP [INT XMT]
        J[020]_[W2]                             ;Another mask
        [W1]&[W2]_Y,                            ;Check for rcv or dsc
         IF CT [IZ] THENP [INT RCV]
        GOTOP [INT DSC]


;Here if interrupt is not for a PCI line
SKPC8:  J[BIT36]_[W1]                           ;Bit table
        [W1]-[PI REG]_Y,Y_RAMFILE ADR,          ;Address bit for level
        CALL [RAMFILE_W1]                       ; Get bit for level
        J[PI IN PROG]_RAMFILE ADR
        [W1]_Q RAMFILE_[W1]
        Q.OR.[W1]_Y,ALU_RAMFILE                 ;Add this level also in progress
        J[060]_[E]                              ;New PC is 40+2n
        [E]-[PI REG]_Q,
        J[#23B MASK]_RAMFILE ADR                ; virtual addresses are 23 bits
        Q-[PI REG]_F,RAMFILE_Y,
        F_Q Y_[W5],IF [TOPS20] THEN [SKPC82]
        COMPLEMENT [K -1.0]_F,F_[W5]            ;Smaller address for TOPS10
SKPC82: J[INT HALT]_[W1]                        ; In case we get a page fail
        CALL [SET PF RCOVR]
        Q+[EPT]_[PMA],MEM START READ,           ;Pick up interrupt instruction
        CALL [UNMAPPED READ]
        [MB]_[E],IX_MX                          ;This is adr of XPCW block
        [W5]BAR&[MB]_Y,
         IF CT [MZ IX_MX] THEN [INT HALT]       ; If location is 0 stop
        [PC FLAGS]_[MB]                         ;Save program flags
        ROR [BIT4]_[W1],                        ;Clear user mode
         CALL [W1BAR&FLAGS]
        ROR [W1]_[W1],                          ;Make a bit 6 a prev ctx user
        CALL [W1BAR&FLAGS]
        IF [USER] CALL [W1!PCF]                 ;Set prev ctxt user
        [K 7777.-1]&[PC]_B,SET EXEC,            ;References are now exec
         IF CT [MZ] THEN [SKPC9]                ; Check high order bits
.IF/FT10PAG
        J[0264]_[W1]                            ;JSR instruction
        SWAP [W1]_[W1],CALL [W1 LLS9]           ;Make a JSR instruction
        [K -1.0]&[PC]_Y,IX_MX,                  ;Check for illegal PC
         IF [TOPS20] THEN [INT HALT]            ; JSR is only for TOPS10
        [W1].XOR.[E]_F,F_B,                     ;Check opcode
        IF NOT CT [MZ] THEN [INT HALT]          ; Check illegal PC
        [K -1.0]&[E]_Y,                         ;Check if it was a JSR
         IF NOT CT [IZ] THEN [INT HALT]
        J[PUSHJ FLAGS]_RAMFILE ADR              ;Flags to clear on a JSR
        RAMFILE_[W1],                   ;Get flags to clear
         CALL [W1BAR&FLAGS]
        [PC]_[MB RH],                           ;Add PC
         CALL [MEMORY WRITE]                    ;Do JSR
        ZERO_[W1],
         CALL [SET PF RCOVR]
        [E]+1_[PC RH],SET LOCAL,                ;Set new PC
        GOTOP [IFETCH]
.ENDIF/FT10PAG

INT HALT:
        J[HALT III]_[W1]                        ;Illegal interrupt instruction
        GOTOP [SET HALT CODE]

W1BAR&FLAGS:
        [W1]BAR&[PC FLAGS]_B,
         RETURN

;Here because interrupt instruction is a 23bit virtual address
SKPC9:  [W1]_[W5],                              ;Save bit6
         CALL [MEMORY WRITE]                    ;Save flags in block
        [PC]_[MB],SET GLOBAL,                   ;Save PC in block
         CALL [WRITE NEXT]
        [E]+1_Q_[E],                            ;Read new flags
         SPEC SEL/PAGE TABLE ENTRY,
         CALL [MEMORY READ]
        ROR [BIT4]_[W1],                        ;Make a user mode bit
         CALL [W1BAR&MB_B]
        [W5]BAR&[MB]_B                          ;Clear prev ctxt user
        [W5]&[PC FLAGS]_B                       ;Leave only previous context user
        [MB].OR.[PC FLAGS]_B,                   ;Set new flags
         CALL [READ NEXT]                       ;Read new PC
        ZERO_[W1],                              ;Done with special
         CALL [SET PF RCOVR]                    ; Page fail recovery
        [MB]_[PC],SET LOCAL,                    ;Set new PC
         GOTOP [IFETCH]

W1BAR&MB_B:
        [W1]BAR&[MB]_B,                         ; Force exec mode
         RETURN


.TOC 1, "Memory Operations"
.TOC 2, "Store Instruction Results"

;Store one word in memory, and two ACs (MULB, DIVB)
TO MEM D AC:
        [MEM-OP]_[MB],
        IF [NOT PXCT] THEN [TMDAC4]
        CALL [PXCT STORE 200]
        GOTO [D TO AC.0]
TMDAC4: [K 7777.-1]&[E]_F,F_Q_B,#1_UC,           ;Address paging ram
        SPEC SEL/PAGE TABLE ENTRY,
         CALL [MEM WRITE 1]
        ;GOTO [D TO AC.0]

;Here to store two words in ACs SEL AC+[0] not already selected
D TO AC.0:
        SEL AC+[1]                              ;Point ramfile at AC+1
        [MEM-OP+1]_RAMFILE,                     ;Store AC+1
         GOTO [TO AC.0]

;Store a word in an AC
TO AC.0:
        SEL AC+[0]                              ;Point ramfile at AC

;Store a word in an AC, AC already selected
TO AC:  [MEM-OP]_RAMFILE,SET LOCAL,             ;Write AC
         IF [NOT TRAP] THENP [IFETCH]
        GOTOP [TRAP]

;Here to store two words in ACs SEL AC+[0] already selected
D TO AC:
        [MEM-OP]_RAMFILE,SEL AC+[1]             ;Save first half of result
        [MEM-OP+1]_RAMFILE,SET LOCAL,           ;Save second operand
         IF [NOT TRAP] THEN [IFETCH]
        GOTOP [TRAP]

;Store a word in an AC, AC already selected
AC TO AC:
        [AC-OP]_RAMFILE,                        ;Write AC
         SET LOCAL,
         IF [NOT TRAP] THENP [IFETCH]
        GOTOP [TRAP]

;Here to store to self after having read location
BACK TO SELF:
.IF/FAST
        [PMA]_[PMA],MEM START WRITE,
         IF [AC REF] THEN [TO SELF]
         [MEM-OP]_MEM,                          ;Write data in memory
        IF [AC.EQ.0] THEN [BACK TO MEM 2]
        [MEM-OP]_[MB],ALU_RAMFILE,              ;Write data in AC
        MEM HOLD,
        IF [NO BUS ERROR] THEN [TO NOWHERE]
        ;GOTO (TO SELF]                         ;Try again
.ENDIF/FAST

;Store to self, At already selected
TO SELF:
        IF [AC.EQ.0] THEN [TO MEM]              ;IF AC is zero store mem, else both
.IF/FAST
        [MEM-OP]_RAMFILE,                       ;Store AC
         GOTO [TO MEM]
.ENDIF/FAST

;Store to both

TO BOTH.0:
        SEL AC+[0]                              ;Point ramfile at AC
;Store to both, AC already selected
TO BOTH:
        [MEM-OP]_RAMFILE,                       ;Store AC
        GOTO [TO MEM]

;Store memory data in AC and AC data in memory (EXCH instruction)
TO EACH:
        [MEM-OP]_RAMFILE                        ;Write AC
        [AC-OP]_[MEM-OP]
        ;GOTO [BACK TO MEM]

;Here when fetched word from memory and want to write back updated number
BACK TO MEM:
.IF/FAST
        [PMA]_[PMA],MEM START WRITE,
         IF [NOT AC REF] THEN [BACK TO MEM 1]
        [PMA]_Y,SPEC SEL/VMA,                   ;Address AC
         IF [PXCT] THEN [TO MEM]
        [MEM-OP]_RAMFILE,SET LOCAL,
        IF [NOT TRAP] THENP [IFETCH]
        GOTO [TRAP]
BACK TO MEM 1:
        [MEM-OP]_MEM                            ;Write data
BACK TO MEM 2:
        MEM HOLD,SET LOCAL,
         IF [NO BUS ERROR] THEN [TO NOWHERE]
        ;GOTO [TO MEM]                          ;Try again
.ENDIF/FAST
;Store AC to memory
TO MEM: [MEM-OP]_[MB],                          ;Put data in MB
         IF [PXCT] THEN [TO MEM PXCT]
        [K 7777.-1]&[E]_F,F_Q_B,#1_UC,          ;Address paging ram
         SPEC SEL/PAGE TABLE ENTRY,
         CALL [MEM WRITE 1]
.IF/FAST
        SET LOCAL,
         IF [NOT TRAP] THEN [IFETCH]
        GOTO [TRAP]
.ENDIF/FAST
.IFNOT/FAST
        GOTO [TO NOWHERE]
.ENDIF/FAST
TO MEM PXCT:
        CALL [PXCT STORE 200]                   ;Store data
        GOTOP [TO NOWHERE]

;Store 2 words to memory
D TO MEM:
        [MEM-OP]_[MB],                          ;Put date in right reg
         IF [PXCT] THEN [D TO MEM PXCT]
        [K 7777.-1]&[E]_F,F_Q_B,#1_UC,           ;Address paging ram
         SPEC SEL/PAGE TABLE ENTRY,
         CALL [MEM WRITE 1]
        [MEM-OP+1]_[MB],                        ;copy rest of data to memory
         CALL [WRITE NEXT]
.IF/FAST
        SET LOCAL,
         IF [NOT TRAP] THEN [IFETCH]
        GOTO [TRAP]
.ENDIF/FAST
.IFNOT/FAST
        GOTO [TO NOWHERE]
.ENDIF/FAST

D TO MEM PXCT:
        J[0200]_[PXCT RH]
        CALL [SET PXCT CTXT]
        [K 7777.-1]&[E]_F,F_Q_B, #1_UC,         ;Address paging ram
        SPEC SEL/PAGE TABLE ENTRY,
        CALL [MEM WRITE 1]
        [MEM-OP+1]_[MB],                        ;Copy rest of data to memory
        CALL [WRITE NEXT]
        CALL [SET CURRENT CTXT]
        GOTOP [TO NOWHERE]

;Here to store 4 words in ACs
Q TO AC.0:
        SEL AC+[0]
        [MEM-OP]_RAMFILE,
        SEL AC+[1]
        [MEM-OP+1]_RAMFILE,
        SEL AC+[2]
        [AC-OP]_RAMFILE,
        SEL AC+[3]
        [AC-OP+1]_RAMFILE,
        SET LOCAL,
        IF [NOT TRAP] THENP [IFETCH]
        GOTOP [TRAP]

;Here to clear page table
PAGE TABLE CLEAR:
        J[511.]_CTR,                            ;Want to clear 512 entries
        J[PAGE TABLE-1]_[W1]
CLR RAM:
        [W1]+1_[W1],Y_RAMFILE ADR               ;Address next page table entry
        ZERO_Y,ALU_RAMFILE,
         LOOP [CLR RAM]
        RETURN


.TOC 2, "TOPS20 Page Refill"
;TOPS20 page refill logic
;Call : x&[K 7777.-1]_[E],                      ;Virtual adr to do page refill for
;      SPEC SEL/PAGE TABLE ENTRY                ;Set section flags
;      #1_UC,CALL [PAGE W REFIL]                ;To do refill for a write reference
;      O=UC,CALL [PAGE R REFIL]                 ;To do refill for a read reference
;
;flag usage:
;      uc = T
;      uz = section pointer
;
;reg usage:
;      W1 = Virtual section number
;      W3 = AND of all section and page pointers (for W)

PAGE W REFIL:
        J[MB REFIL]_RAMFILE ADR,#1_UC           ;Address location to save MB
        [MB]_RAMFILE,                           ;Save MB
         GOTO [PR 1]

PAGE R REFIL:
        ; #0_UC
PR 1:
.IF/FT20PAG
.IF/FT10PAG
        IF [TOPS10] THEN [T10PR]
.ENDIF/FT10PAG
        SWAP [E]_[PMA],                         ;Put section number in RH
        IF [ILLEGAL SECTION] THENP [PF X27]
        [K 77]&[PMA]_B,                         ;Strip LH
         IF [EXEC] THEN [PR 2]
        [UPT]+[PMA]_B,GOTO [PR 3]               ;UPT + section # to PMA
PR 2:   [EPT]+[PMA]_B                           ;EPT + section # to PMA
PR 3:   J[ESECT]_[W1]                           ;Get offset for section pointers
        [BIT4]_[W3],#0_UZ                       ;W bit(Mask for AND of pointers)
        [W1]+[PMA]_F,F_Q_B,                     ;EPT(UPT)+sect+ESECT
        MEM START READ,
        CALL [PTR EVAL]                         ; Get page adr from section table
        [MB]_[W2],                              ;Save page number
        CALL [CST UPDATE]                       ;Update CST for page table
        #2*[E]_[W1],PUSH J[3]_CTR               ;Copy virtual address to
        #4*[W1]_B,RFCT                          ;Convert to page number
        SWAP [W1]_[PMA]                         ;Right justifty page number
        [K 777]&[PMA]_B                         ;Make in section page number
        [W4]+[PMA]_B,MEM START READ,            ;Address page table entry
        CALL [PTR EVAL]                         ; and fetch pointer
        [MB]_[W2],#1_UZ,                        ;Update M
        CALL [CST UPDATE]                       ; Update CST for page
        J[1]_[W1]                               ;Mask for M bit
        [MB]&[W1]_Y,IX_MX                       ;Latch M as #0_MZ
        #2*[W3]_Q,                              ;Make a bit 4 if writable
         IF CT [MZ] THEN [PR 6]
        Q.OR.[W3]_[W3]                          ;Add M bit if W
PR 6:   J[BIT2]_RAMFILE ADR,                    ;Bit for valid mapping
         [W3].OR.[W4]_Q                         ;Add W bit
        RAMFILE_[W1]                            ;Get valid bit from ramfile
        Q.OR.[W1]_[MB],                         ;Add valid bit to paging ram word
        IF [USER] CALL [B0!MB]
        [E]_Y,                                  ;Address paging ram location
        SPEC SEL/PAGE TABLE ENTRY
.IF/DEBUGPF
        JS[01776]_[W2]
        ROR [W2]_[W2]
        [MB]&[W2]_Y,
         IF NOT CT [IZ] THEN [HALT PG]
.ENDIF/DEBUGPF
        [MB]_[W1],ALU_RAMFILE,                  ;Fill paging ram
        IF NOT CT [UC] RETURN                   ; If read refill we are done
        J[MB REFIL]_RAMFILE ADR
        RAMFILE_[MB],
         RETURN

;Here to evaluate a section pointer or map pointer
; call: x_Q_[PMA],      ;Physical address of 1st pointer
;        MEM START READ,
;        CALL [PTR EVAL]
; Returns
;        accumulates W in W3
;        page number in MB (maybe also other junk)
;        address in W4

PTR EVAL:
        MEM HOLD,                               ;Get pointer from memory
        CALL [UNMAPPED READ]
        [MB]&[W3]_B                             ;Accumulate W
        #2*[MB]_[W4],IX_MX                      ;latch bitO as MN
        #2*[W4]_[W4],                           ;Copy pointer to W4 and shift it
         IF CT [MN IX_MX] THEN [PF X0]          ; for decode on bits 0,1,2
        #2*[W4]_[W4],
         IF NOT CT [MN IX_MX] THEN [PTE 7]      ;Branch if bits OOx

;Here if bits 0-2 of section pointer are 0
        [K -1.0]BAR&[MB]_Q,                     ;Get SPT index
         IF NOT CT [MN] THEN [PTE 1]            ;branch for 010

;Here if bits 0-2 of section pointer are 011 = indirect pointer
        SWAP [MB]_[W1]                          ;Put offset in RH
        [K 777]&[W1]_B,                         ;Mask off extra bits
         CALL [PTE 1]                           ;Get table address from SPT
        [W4]_[PMA]                              ;Address of indirect table
        [W1]+[PMA]_B,MEM START READ,
         GOTO [PTR EVAL]

;Here if bits 0-2 of section poin~er are 010 = shared pointer
PTE 1:  Q+[SPT]_F,F_Q_[PMA],                    ;Get SPT entry for page map
        MEM START READ
        CALL [UNMAPPED READ]
        ;This word is not included in the W accumulation
        #2*[MB]_[W4],#1_MX,                     ;Copy page address to WJt
        CALL [#4*W4_B]

;Here if bits 0-2 of pointer are OOx
PTE 7:  #4*[W4]_B,
        IF NOT CT [MN] THEN [PF X0]

;Here if bits 0-2 of pointer are 001 = immediate pointer

PTE 8:  SWAP [K 77]_[W1]                        ;Mask for storage medium
        [MB]&[W1]_Y,IX_MX                       ;See if in core or else where
        [E]_[W4 LH],                            ;Add virtual section
         IF NOT CT [MZ] THEN [PF X0]
        #4*[W4]_B                                ;Shift page number to make adr
#4*W4_B: #4*[W4]_B
         RETURN

;Here to update a CST entry
; Call: x_[MB]          ;Physica1 page number for update
;       Call with UC if write reference
;       Call with UZ if want M updated
CST UPDATE:
        J[CST]_RAMFILE ADR
        J[07777]_[PMA]
        [K -1]&[PMA]_F,LLS F_B,                 ;leave 17777 in PMA
         #1_SIO0 #1_QIO0
        [MB]&[PMA]_F,                           ;Leave only page number in Q
         F_Q RAMFILE_[PMA]                      ; Get CST adr in PMA
        Q+[PMA]_[PMA],MEM START READ,           ;Get CST entry for page map
        CALL [UNMAPPED READ]
        J[CSTMASK]_RAMFILE ADR
        [K 7777.-1]BAR&[MB]_Y,IX_MX             ;Check age field
        [MB]_Q RAMFILE_[MB],                    ;Get CSTmask register
         IF CT [MZ] THEN [AGE PF]               ; If age trap page fail
        Q&[MB]_Q,                               ;Mask off bits
        J[CSTDATA]_RAMFILE ADR
        RAMFILE_[MB]
        Q.OR.[MB]_F,F_Q_[MB], ;                 ;Add new bits
         IF NOT CT [UC] THEN [CSTUD8]           ;B ranch if read refill
        [W3]_Y,                                 ;Test W bit
         IF NOT CT [UZ IX_MX] THEN [CSTUD8]
        J[1]_[MB]                               ;Get M bit for CST entry
        Q.OR.[MB]_[MB],                         ;Set M bit
         IF CT [MZ] THEN [PF X0]                ; If not W, page fail
CSTUD8: [PMA]_[PMA],MEM START WRITE,            ;Write updated CST entry
        GOTO [UNMAPPED WRITE]
.ENDIF/FT20PAG


.TOC 2, "TOPS10 Page Refill"

.IF/FT10PAG
T10PR:  [K -1.0]&[E]_Y,                         ;Check for legal section
         IF NOT CT [IZ] THENP [PF X27]
        [K 777]BAR&[E]_F,F_Q                    ;Strip onpage portion
        Q_[W1],PUSH J[3]_CTR                    ;Shift E left 8 places
        #4*[W1]_B,RFCT
        SWAP [W1]_[PMA],                        ;Sign bit  = E bit 26
         IF [USER] THEN [T1PR14]                ; Page #/2 in bits 28-35
        B SEL/E,
         IF [B BIT 18] THEN [T1PR13]
        ROL [PMA]_[W2]                          ;Page # goes to bits 27-35
        J[0340]_[W1]
        [W2]-[W1]_Y,                            ;Check for up to 34OOOO
         IF CT [IN] THEN [T1PR12]
        J[0220]_[W1]                            ;Offset for 340000 in UPT
        [W1]+[PMA]_B,
        GOTO [T1PR14]
T1PR12: J[0600]_[W1]                            ;Offset for 000000 in exec
        [W1]+[PMA]_B
T1PR13: [EPT]+[PMA]_B,MEM START READ,           ;Offset for 4OOOOO in EPT
         CALL [UNMAPPED READ]                   ;Get word from EPT
        GOTO [T1PR15]
T1PR14: [UPT]+[PMA]_B,MEM START READ,           ;Get word from UPT
        CALL [UNMAPPED READ]
T1PR15: [PMA]_Y,IX_MX                           ;Check for odd or even
        IF NOT CT [MN] CALL [SWAP MB_MB]
        J[07777]_[W2]                           ;Want mask for physical page
        [W2]_F,LLS F_B,B SEL/W2,                ;Put 17777 in W2
        #1_SIO0 #1_QIO0
        ZERO_[W1],                              ;Build paging ram word here
        IF [EXEC] THEN [T1PR24]
        J[0002]_[W1]                            ;Bit for user
        SWAP [W1]_[W1]
T1PR24: [MB]_[W1 RH]                            ;Add APWS
        #2*[W1]_[W1]                            ;Put A in bit17
        #2*[W1]_[W1 RH]                         ;Put W in bit18(discard P)
        #4*[W1]_B                               ;Put S in bit17
        [MB]_[W1 RH]                            ;Add page #
        [W2]&[W1 RH]_B,PUSH J[1]_CTR            ;Clear extra bits
        [W1]+[W1 LH]_F,LLS F_B,RFCT             ;Put S in bit 13
        [E]_Y,SPEC SEL/PAGE TABLE ENTRY         ;Address paging ram
        #2*[W1]_[W1],PUSH J[3]_CTR              ;Want to shift left 9
        #4*[W1]_B,IX_MX,RFCT
        [W1]_Y,ALU_RAMFILE,                     ;Write new paging ram word
         IF NOT CT [UC] RETURN
        J[MB REFIL]_RAMFILE ADR                 ;Address where we left MB
        RAMFILE_[MB],RETURN                     ;Restore MB
.ENDIF/FT10PAG

.TOC 2, "Unmapped Memory Read"

; CALL: x_[PMA],MEM START READ
;       returns with data in MB
UNMAPPED READ 0:
        [PMA]_[PMA],MEM START READ
UNMAPPED READ:
        MEM HOLD,
         CHECK INTERRUPTS
        MEM_[MB]                                ;Get contents of memory
        MEM HOLD,
         IF [NO BUS ERROR] RETURN
        ;GOTO [MEM ERR]

;Here on a mem fault
;If soft (ECC correctable error) will save status (even if already
;      latched) set APR flag, SPEC SEL/IW, and return.
;      Will clobber W1&W2
;If RAMFILE_[ME RCOVR] is nonzero will go there with status in W1
;Else will build a page fail code and go to PF XX
MEM ERR:
        J[ME W1]_RAMFILE ADR                    ;Have to save W1
        [W1]_RAMFILE
        J[ME W2]_RAMFILE ADR                    ;Have to save W2
        [W2]_RAMFILE
        [PMA]_[W2],MEM HOLD                     ;Copy offending address
        #4*[W2]_B,MEM HOLD                      ;Put board number in lh
        SWAP [W2]_[W2],MEM HOLD                 ;Put board number in rh
        [K 77]&[W2]_Q,MEM HOLD,
         J[BIT20]_RAMFILE ADR
        RAMFILE_[W2],MEM HOLD                   ;Get 100000
        Q+[W2]_F,F_Q_Y,START IO READ            ;Address memory status reg
        IO TRANSFER,XFER MEM,                   ;Get status from memory
        Y_[W1],ALU_Y/NO,
        M STATUS ENAB/NO                        ;do not change error flags
        [BIT17]_[W1 LH],                        ;Check for NXM
         IF [NOT MEM EXISTS] THEN [MEM NXM]
        [BIT17]+[W1]_B,                         ;1st check Bus fault line
         IF [MEM FAULT] THEN [MEM FAULT]

;Here if we detected parity from bus
.IF/FTCKBP
        [BIT17]+[W1]_B,                         ;Must be a bus parity error
        GOTO [MER05]
.ENDIF/FTCKBP
.IFNOT/FTCKBP
        J[ME W1]_RAMFILE ADR                    ;Where we saved W1
        RAMFILE_[W1]
        J[ME W2]_RAMFILE ADR                    ;Where we saved W2
        RAMFILE_[W2]
        [MB]_[MB],SPEC SEL/IW,                  ;In case part of efa calc
        RETURN
.ENDIF/FTCKBP

;Here because we won a NXM
MEM NXM:
        J[NXM STS]_[W2],Y_RAMFILE ADR           ;Save status as "nxm"
        GOTO [MER10]

;Here when memory complains
MEM FAULT:
.IF/FTSMER
        J[06550]_[W2]
        #4*[W2]_B,CALL [#4*W2_B]
        [W1]&[W2]_Q                             ;Leave only bits we care about
        J[04010]_[W2]                            ;Bits we expect
        #4*[W2]_B,CALL [#4*W2_B]
        Q.XOR.[W2]_F,F_Y,
         IF NOT CT [IZ] THEN [MER05]
        J[APR FLAGS]_RAMFILE ADR
        [K 77]+1_F,F_Q Y_[W2],                  ;Make 100 = SME flag
         RAMFILE_Y
        Q.OR.[W2]_F,F_Q_[W2],
         ALU_RAMFILE
        SWAP [W2]_[W2]
        Q&[W2]_Y,
        IF CT [IZ] THEN [MER04]
;**** add code to make interrupt ****
MER04:  J[SME STS]_[W2],Y_RAMFILE ADR           ;Save status as "soft"
         CALL [MESAV2]                          ;Save status and exit
        J[ME W1]_RAMFILE ADR
        RAMFILE_[W1]
        J[ME W2]_RAMFILE ADR
        RAMFILE_[W2]
        [MB]_Y,SPEC SEL/IW,
        RETURN
.ENDIF/FTSMER
MER05:  J[HME STS]_[W2],Y_RAMFILE ADR,          ;Save status as "hard"
         POP
MER10:  J[ME RCOVR]_RAMFILE ADR,                ;Check for recovery routine
         [W2]_Q,POP
        RAMFILE_[W2],POP                 ;Get recovery routine
        [W2]_Y,IF NOT CT [IZ] THEN Y            ;If there is one do it
.IFNOT/FTPFRMER
        J[PF RCOVR]_RAMFILE ADR                 ;Page fail recovery
        ZERO_Y,ALU_RAMFILE                      ;does not help here
.ENDIF/FTPFRMER
        Q_[W2],Y_RAMFILE ADR,
        CALL [MERSAV]                           ;Save error status
        [BIT17].XOR.[W1]_F,POP,
        FJ[03700]_[W1]                          ;Code for NXM
        [K -1.0]&[W1]_Y,
         IF CT [IZ] THENP [PF XX]
        J[03600]_[W1]                           ;Code for mem err
        GOTOP [PF XX]                           ;Perform a page fail

MERSAV: RAMFILE_Y,IX_MX                 ;See if already latched error
        IF NOT CT [MZ] RETURN                   ;Do not overwrite
MESAV2: [W1]_RAMFILE,                           ;Save status
        CALL [W2+1_RFA]
        [PMA]_RAMFILE,                          ;Save address of losing location
        CALL [W2+1_RFA]
        [MB]_RAMFILE,SPEC SEL/IW,
        RETURN

#4*W2_B: #4*[W2]_B,RETURN

W2+1_RFA:
        [W2]+1_[W2],Y_RAMFILE ADR,              ;Address next ramfile location
        RETURN

.TOC 2, "Memory Read Routine"
; CALL: x_Q_[E],                                ;Put address in E & Q
;       CLEAR LOCAL,SET LOCAL,                  ; Only one please
;       SPEC SEL/PAGE TABLE ENTRY,              ; Address paging entry
;       CALL [MEMORY READ]
; RETURNS with data in MB and with SPEC SEL/IW set
;         paging RAM word is in W1
;         clobbers W2-W4 (if page refill)

;Here to fetch next virtual address
READ NEXT:
        [E]+1_Q_[E RH],
         IF [LOCAL] THEN [MEM READ 0]
        Q_[E],                                  ;Address to read
        SPEC SEL/PAGE TABLE ENTRY,
        GOTO [MEMORY READ]

MEM READ 0:
        [K 7777.-1]&[E]_F,F_Q_B,                ;Address to read
        SPEC SEL/PAGE TABLE ENTRY,
        GOTO [MEMORY READ]

MEMORY READ:
        Q&[K 777]_F,RAMFILE_Y,                  ;Put page entry in W1
        #0_UC IX_MX,
        Y_[W1] F_Q,                             ;Put on page adr in Q
         IF [UNPAGED OR AC] THEN [M R 8]
.IF/DEBUGPF
        JS[01776]_[W2]
        ROR [W2]_[W2]
        [W1]&[W2]_Y,
         IF NOT CT [IZ] THEN [HALT PG]
.ENDIF/DEBUGPF
        Q.OR.[W1]_[PMA],MEM START READ,
        IF [CONTEXT MATCH] THEN [MEM READ 4]
        [K 7777.-1]&[E]_B,#0_UC,                 ;Mask address to 30 bits
         CALL [PAGE R REFIL]
        GOTO [MEM READ 0]

MEM READ 3:
        [E]_[PMA],MEM START READ                ;Address location
MEM READ 4:
        CHECK INTERRUPTS,
        MEM HOLD
        MEM_[MB],SPEC SEL/IW                    ;Read memory into MB & select IW
        [MB]_[MB],MEM HOLD,
         IF [NO BUS ERROR] RETURN
        MEM HOLD,GOTO [MEM ERR]

;Here if reference is unpaged or ac
M R 8: [E]_[PMA],SPEC SEL/VMA,                  ;Address register
        IF [NOT AC REF] THEN [MEM READ 3]
        RAMFILE_[MB],                   ;Read AC into MB & select IW
         IF [ILLEGAL SECTION] THENP [PF X27]
        CHECK INTERRUPTS
        [MB]_Y,SPEC SEL/IW,
        RETURN


.TOC 2, "Unmapped Memory Write Routine"

;CALL:  x_[MB]                                  ;Put data in KB
;       x_[PMA]                                 ;Physical location to write into
;       CALL [UNMAPPED WRITE]

;Here to write memory with contents of MB and then increment PMA
UNMAPPED WRITE NEXT:
        [PMA]+1_[PMA],MEM START WRITE,          ;Give memory address
        GOTO [UNMAPPED WRITE 2]

UNMAPPED WRITE:
        [PMA]_[PMA],                            ;Give memory address to write
        MEM START WRITE

UNMAPPED WRITE 2:
        [MB]_MEM                                ;Write data in memory
        MEM HOLD,
         IF [NO BUS ERROR] RETURN
        MEM HOLD,GOTO [MEM ERR]



.TOC 2, "Memory Write Routine"

;CALL:  x_[E]                                   ;Virtual adr
;       x_[MB]                                  ;Put data in MB
;       CALL [MEMORY WRITE]
;        with GLOBAL/LOCAL flag set,
;        may clobber W1-W5

WRITE NEXT:
        [E]+1_F,F_Q_[E],
        SPEC SEL/PAGE TABLE ENTRY,
        GOTO [MEM WRITE 1]
MEMORY WRITE:
        [K 7777.-1]&[E]_F,F_Q_B,#1_UC,          ;Address paging ram
        SPEC SEL/PAGE TABLE ENTRY,
         IF [NOT PAGED] THEN [M W 8]

MEM WRITE 1:
        Q&[K 777]_Q RAMFILE_[W1],               ;Get paging ram entry
         #1_UC IX_MX,
         IF [UNPAGED OR AC] THEN [M W 8]
.IF/DEBUGPF
        JS[01776]_[W2]
        ROR [W2]_[W2]
        [W1]&[W2]_Y,
         IF NOT CT [IZ] THEN [HALT PG]
.ENDIF/DEBUGPF
.IF/FTADRB
        J[AB WR]_RAMFILE ADR,                   ;Get address to stop on
        Q&[K 7777.-1]_F,F_Q
        RAMFILE_[W2]
        Q.XOR.[W2]_F,F_Y,
         IF CT [IZ] THEN [M W 2]
        J[HALT CODE]_RAMFILE ADR
        J[HALT ADRBRK]_[W2]
        [W2]_RAMFILE,CLEAR RUN
.ENDIF/FTADRB
M W 2:  Q.OR.[W1]_[PMA],
         MEM START WRITE,
         IF [CONTEXT MATCH] THEN [M W 3]
M W 25: [K 7777.-1]&[E]_B,                      ;Mask address to 30 bits
         CALL [PAGE W REFIL]
        GOTO [MEMORY WRITE]

M W 3:  B SEL/W1,MEM HOLD,
         IF [B BIT 3] THEN [M W 5]              ;Check M bit is set
M W XX:
.IF/FT20PAG
        [BIT4]&[W1]_Y,IX_MX,                    ;Check W bit
         IF [TOPS10] THEN [M W PF]
        IF NOT CT [MZ] THEN [M W 25]
;***** clever code here could just call CST UPDATE
.ENDIF/FT20PAG
M W PF: GOTO [PAGE FAIL]
M W 4:  [E]_[PMA],MEM START WRITE
M W 5:  [MB]_MEM                                ;Write memory into MB
        MEM HOLD,
         IF [NO BUS ERROR] RETURN
        MEM HOLD,GOTO [MEM ERR]

;Here if writing AC or unpaged
M W 8: [E]_[PMA],SPEC SEL/VMA,                  ;Address register
         IF [NOT AC REF] THEN [M W 4]           ;Check for unpaged
        IF [ILLEGAL SECTION] THENP [PF X27]
        [MB]_RAMFILE,RETURN                     ;Write AC in RAMFILE


.TOC 2, "Page Fail"



;                              TOPS20                                   TOPS10
;                +-----------------------------------+   +----------------------------------+
;            500 | Page fail word                    |   | Page fail word                   |
;                +-----------------------------------+   +----------------------------------+
;            501 | Page fail flags                   |   | Page fail old flags,,PC          |
;                +-----------------------------------+   +----------------------------------+
;            502 | Page fail old PC                  |   | Page fail new PC                 |
;                +-----------------------------------+   +----------------------------------+
;            503 | Page fail new PC                  |   | Reserved                         |
;                +-----------------------------------+   +----------------------------------+



;Here for an aged page fail
AGE PF:
.IF/FTAGEPF
        J[02100]_[W1]
        GOTOP [PF XX]
.ENDIF/FTAGEPF

;Here for uncoded page fail
PF X0:  ZERO_[W1],
         GOTOP [PAGE FAIL]

;Here for an IO page fail
IO PF:
PF X20: J[02000]_[W1]
         GOTOP [PF XX]

;Here for a Illegal Indirect page fail
PF X24: J[02400]_[W1]
         GOTOP [PF XX]

;Here for an Illegal Section page fail
PF X27: J[02700]_[W1]
         ;GOTOP [PF XX]

PF XX:  SWAP [W1]_[W1],PUSH J[2]_CTR            ;Move code to lh
        #4*[W1]_B,RFCT                           ;Shift 6 places left
        GOTO [PF XX1]

.IF/DEBUGPF
HALT PG:
        ONES_[W1],
         GOTO [SET HALT CODE]
.ENDIF/DEBUGPF

;Here to do a Page fail, with page fail word in W1
PAGE FAIL:
.IF/DEBUGPF
        JS[1]_[W2]                              ;Mask for illegal bits
        ROR [W2]_[W2]
        [W1]&[W2]_Y,
        IF NOT CT [IZ] THEN [HALT PG]
.ENDIF/DEBUGPF
        ROR [BIT4]_[W2],                        ;Make a type-l bit
         IF NOT CT [UC] THEN [PF XX1]
        [W2].OR.[W1]_B                          ;Add T bit
PF XX1: J[037]_[W2]                             ;Build mask
        SWAP [W2]_[W2]
        [W2]&[E LH]_B,
         IF [PXCT] CALL [SET CURRENT CTXT]
        J[PF RCOVR]_RAMFILE ADR,
         [K 7777.-1]BAR&[W1]_Q                  ;Strip mapping info
        Q.OR.[E]_[W1],                          ;Put virtual address in PF wcrd
        IF [NOT PAGED] THENP [PF XX2]
        J[01000]_[W2]                           ;Will become V bit
        SWAP [W2]_[W2],
         CALL [W2.OR.W1]
PF XX2: [W1]_[MB],                              ;Copy page fail word
         IF [USER] CALL [B0!MB]                 ;Add user mode if needed
        RAMFILE_[W2],IX_MX                      ;Get recovery routine adr
        [W2]_Y,
         IF NOT CT [MZ] THEN Y                  ;If there is one do it
        J[PF MER]_[W1]                          ;In case error fetching from UPT
        [K -1]+[PC RH]_B,                       ;Backup the PC
         CALL [SET MER]                         ; Set memory err recovery
        J[PFW]_[PMA]                            ;Get offset into UPT for page fail word
        [UPT]+[PMA]_B,MEM START WRITE,          ;Physical location of word
         CALL [UNMAPPED WRITE]
        [PC FLAGS]_[MB],                        ;Next word is flags
         IF [TOPS20] THEN [PF 34]
        [PC]_[MB RH],GOTO [PF 35]               ;Put PC in rh
PF 34:  [PMA]+1_[PMA],MEM START WRITE,          ;Store flags
         CALL [UNMAPPED WRITE]
        [PC]_[MB]                               ;Next word is PC
PF 35:  [PMA]+1_[PMA],MEM START WRITE,          ;Store PC
         CALL [UNMAPPED WRITE]
PF 40:  [PMA]+1_[PMA],MEM START READ,
         CALL [UNMAPPED READ]                   ;Get new PC
        ZERO_[W1],CALL [SET MER]                 ;Have now passed any errors
        [MB]_[PC],SET EXEC,
         IF [TOPS10] THEN [MB_PC FLAGS]
        ZERO_[PC FLAGS],SET LOCAL,
         GOTO [IFETCH]

B0!MB:  JS[0]_[W1]                              ;Put 400000,,0 in W1
W1!MB:  [W1].OR.[MB]_B,                         ;Set bit
        RETURN

;Here if encounter NXK, bus error, or ECC error
PF MER: J[HALT PFMER]_[W1]
        GOTOP [SET HALT CODE]                   ;Set halt code and quit

SET PF ME RCOVR:
        CALL [SET MER]
        ;GOTO [SET PF RCOVR]
SET PF RCOVR:
        J[PF RCOVR]_RAMFILE ADR                 ;In case errors handling int

W1_RAMFILE:
        [W1]_RAMFILE,
         RETURN

;Here to set memory error recovery location
SET MER:
        J[ME RCOVR]_RAMFILE ADR
        [W1]_Y,ALU_RAMFILE,
        RETURN

.TOC 1, "Dispatch Table"
.TOC 2, "Dispatch Table Field Definitions"

.DCODE

J/=< 0:11>,.ADDRESS,.DEFAULT=<MCE>                      ;1st Dispatch = OPERAND FETCH Dispatch
K/=<12:23>,.ADDRESS,.DEFAULT=<MCE>                      ;2nd Dispatch = INST EXCT Dispatch
L/=<24:35>,.ADDRESS,.DEFAULT=<MCE>                      ;3rd Dispatch = OPERAND STORE Dispatch
M/=<36:47>,.ADDRESS,.DEFAULT=<MCE>                      ;4th Dispatch = final inst dispatch
N/=<48:59>,.ADDRESS,.DEFAULT=<MCE>                      ;5th Dispatch = free
O/=<60:71>,.ADDRESS,.DEFAULT=<MCE>                      ;6th Dispatch = free
P/=<72:83>,.ADDRESS,.DEFAULT=<MCE>                      ;7th Dispatch = 1st half of IO dispatch
Q/=<84:95>,.ADDRESS,.DEFAULT=<MCE>                      ;8th Dispatch = 2nd half of IO dispatch

.TOC 2, "Dispatch Table Macros"

[] [] [] [] [] [] [] [] "J/@1,K/@2,L/@3,M/@4,N/@5,O/@6,P/@7,Q/@8"
[]                      "[@1] [MCE] [MCE] [MCE] [MCE] [MCE] [MUUO] [MCE]"
[]#[]                   "[@1] [MCE] [MCE] [MCE] [MCE] [MCE] [@2] [MCE]"
[]##[]                  "[@1] [MCE] [MCE] [MCE] [MCE] [MCE] [MUUO] [@2]"
[] []                   "[@1] [@2] [MCE] [MCE] [MCE] [MCE] [MUUO] [MCE]"
[] []#[]                "[@1] [@2] [MCE] [MCE] [MCE] [MCE] [@3] [MCE]"
[] []##[]               "[@1] [@2] [MCE] [MCE] [MCE] [MCE] [MUUO] [@3]"
[] [] []                "[@1] [@2] [@3] [MCE] [MCE] [MCE] [MUUO] [MCE]"
[] [] []#[]             "[@1] [@2] [@3] [MCE] [MCE] [MCE] [@4] [MCE]"
[] [] []##[]            "[@1] [@2] [@3] [MCE] [MCE] [MCE] [MUUO] [@4]"
[] [] [] []             "[@1] [@2] [@3] [@4] [MCE] [MCE] [MUUO] [MCE]"
[] [] [] []#[]          "[@1] [@2] [@3] [@4] [MCE] [MCE] [@5] [MCE] "
[] [] [] []##[]         "[@1] [@2] [@3] [@4] [MCE] [MCE] [MUUO] [@5]"


.TOC 2, "Opcodes 000 - 037"

0:
        [MUUO]#[APRID]                                  ;000 70000 Illegal
        [CHK PC SECT] [MCE] [LUUO]                      ;001 70004 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;002 70010 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;003 70014 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[WRAPR]              ;004 70020 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[RDAPR]              ;005 70024 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[SZAPR]              ;006 70030 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[SNAPR]              ;007 70034 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;010 70040 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;011 70044 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;012 70050 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;013 70054 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[WRPI]               ;014 70060 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[RDPI]               ;015 70064 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[SZPI]               ;0l6 70070 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[SNPI]               ;017 70074 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;020 70100 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[RDUBR]              ;021 70104 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[CLRPT]              ;022 70110 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[WRUBR]              ;023 70114 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[WREBR]              ;024 70120 LUUO
        [CHK PC SECT] [MCE] [LUUO]#[RDEBR]              ;025 70124 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;026 70130 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;027 70134 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;030 70140 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;031 70144 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;032 70150 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;033 70154 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;034 70160 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;035 70164 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;036 70170 LUUO
        [CHK PC SECT] [MCE] [LUUO]                      ;037 70174 LUUO

.TOC 2, "Opcodes 040 - 077"
.IF/FT20PAG
        [MUUO]#[RDSPB]                                  ;040 70200 MUUO
        [MUUO]#[RDCSB]                                  ;041 70204 MUUO
        [MUUO]#[RDPUR]                                  ;042 70210 MUUO
        [MUUO]#[RDCSTM]                                 ;043 70214 MUUO
.ENDIF/FT20PAG
.IFNOT/FT20PAG
        [MUUO]                                          ;040 70200 MUUO
        [MUUO]                                          ;041 70204 MUUO
        [MUUO]                                          ;042 70210 MUUO
        [MUUO]                                          ;043 70214 MUUO
.ENDIF/FT20PAG
        [MUUO]#[RDTIM]                                  ;044 70220 MUUO
        [MUUO]#[RDINT]                                  ;045 70224 MUUO
        [MUUO]#[RDHSB]                                  ;046 70230 MUUO
        [MUUO]                                          ;047 70234 MUUO
.IF/FT20PAG
        [MUUO]#[WRSPB]                                  ;050 70240 MUUO
        [MUUO]#[WRCSB]                                  ;051 70244 MUUO
        [MUUO]#[WRPUR]                                  ;052 70250 MUUO
        [MUUO]#[WRCSTM]                                 ;053 70254 MUUO
.ENDIF/FT20PAG
.IFNOT/FT20PAG
        [MUUO]                                          ;050 70240 MUUO
        [MUUO]                                          ;051 70244 MUUO
        [MUUO]                                          ;052 70250 MUUO
        [MUUO]                                          ;053 70254 MUUO
.ENDIF/FT20PAG
        [MUUO]#[WRTIM]                                  ;054 70260 MUUO
        [MUUO]#[WRINT]                                  ;055 70264 MUUO
        [MUUO]#[WRHSB]                                  ;056 70270 MUUO
        [MUUO]                                          ;057 70274 MUUO
        [MUUO]                                          ;060 70300 MUUO
        [MUUO]                                          ;061 70304 MUUO
        [MUUO]                                          ;062 70310 MUUO
        [MUUO]                                          ;063 70314 MUUO
        [MUUO]                                          ;064 70320 MUUO
        [MUUO]                                          ;065 70324 MUUO
        [MUUO]                                          ;066 70330 MUUO
        [MUUO]                                          ;067 70334 MUUO
        [MUUO]                                          ;070 70340 MUUO
        [MUUO]                                          ;071 70344 MUUO
        [MUUO]                                          ;072 70350 MUUO
        [MUUO]                                          ;073 70354 MUUO
        [MUUO]                                          ;074 70360 MUUO
        [MUUO]                                          ;075 70364 MUUO
        [MUUO]                                          ;076 70370 MUUO
        [MUUO]                                          ;077 70374 MUUO
.TOC 2, "Opcodes 100 - 137"
        [MUUO]                                          ;100 70400 MUUO
        [MUUO]                                          ;101 70404 MUUO
        [MUUO]                                          ;102 70410 MUUO
        [MUUO]                                          ;103 70414 MUUO
        [MUUO]                                          ;104 70420 MUUO
        [FETCH AC&I] [CHK PC SECT] [ADJSP] [ADJSP V]    ;105 70424 ADJSP
        [MUUO]                                          ;106 70430 MUUO
        [MUUO]                                          ;107 70434 MUUO
        [MUUO]                                          ;110 70440 DFAD
        [MUUO]                                          ;111 70444 DFSB
        [MUUO]                                          ;112 70450 DFMP
        [MUUO]                                          ;113 70454 DFDV
        [DFETCH AC&MEM] [DADD] [D TO AC.0]              ;114 70460 DADD
        [DFETCH AC&MEM] [DSUB] [D TO AC.0]              ;115 70464 DSUB
        [DFETCH AC&MEM] [DMUL] [Q TO AC.0]              ;116 70470 DMUL
        [DFETCH AC&MEM] [DDIV] [Q TO AC.0]              ;117 70474 DDIV
        [DFETCH MEM] [D TO AC]                          ;120 70500 DMOVE
        [DFETCH MEM] [DMOVNX] [D TO AC.0]               ;121 70504 DMOVN
        [FETCH MEM] [FIX] [IFETCH]                      ;122 70510 FIX
.IF/FTEXTEND
        [EXTEND]                                        ;123 70514 EXTEND
.ENDIF/FTEXTEND
.IFNOT/FTEXTEND
        [MUUO]                                          ;123 70514 EXTEND
.ENDIF/FTEXTEND
        [DFETCH AC] [D TO MEM]                          ;124 70520 DMOVEM
        [DFETCH AC] [DMOVNX] [D TO MEM]                 ;125 70524 DMOVMN
        [FETCH MEM] [FIX] [FIXR]                        ;126 70530 FIXR
        [FETCH MEM] [FLTR] [TO AC]                      ;127 70534 FLTR
        [MUUO]                                          ;130 70540 UFA(obs)
        [MUUO]                                          ;131 70544 DFN(obs)
        [MUUO]                                          ;132 70550 FSC
.IF/FTBYTE
        [FETCH AC&MEM] [ADJBP] [TO NOWHERE] [ADJBP0]    ;133 70554 ADJBP/IBP
        [FETCH MEM(W)] [IP&S SETUP] [IP&S 5] [LDB]      ;134 70560 ILDB
        [FETCH MEM] [P&S SETUP] [MCE] [LDB]             ;135 70564 LDB
        [FETCH AC&MEM(W)] [IP&S SETUP] [IP&S 5] [DPB]   ;136 70570 IDPB
        [FETCH AC&MEM] [P&S SETUP] [MCE] [DPB]          ;137 70574 DPB
.ENDIF/FTBYTE
.IFNOT/FTBYTE
        [MUUO]                                          ;133 70554 ADJBP/IBP
        [MUUO]                                          ;134 70560 ILDB
        [MUUO]                                          ;135 70564 LDB
        [MUUO]                                          ;136 70570 IDPB
        [MUUO]                                          ;137 70574 DPB
.ENDIF/FTBYTE

.TOC 2, "Opcodes 140 - 177"
        [FETCH AC&MEM] [FADX] [TO AC.0]                 ;140 70600 FAD
        [MUUO]                                          ;141 70604 FADL(obs)
        [FETCH AC&MEM(W)] [FADX] [TO MEM]               ;142 70610 FADM
        [FETCH AC&MEM(W)] [FADX] [TO BOTH.0]            ;143 70614 FADB
        [FETCH AC&MEM] [FADRX] [TO AC.0]                ;144 70620 FADR
        [FETCH AC&I] [FADRX] [TO AC.0]                  ;145 70624 FADRI
        [FETCH AC&MEM(W)] [FADRX] [TO MEM]              ;146 70630 FADRM
        [FETCH AC&MEM(W)] [FADRX] [TO BOTH.0]           ;147 70634 FADRB
        [FETCH AC&MEM] [FSBX] [TO AC.0]                 ;150 70640 FSB
        [MUUO]                                          ;151 70644 FSBL(obs)
        [FETCH AC&MEM(W)] [FSBX] [TO MEM]               ;152 70650 FSBM
        [FETCH AC&MEM(W)] [FSBX] [TO BOTH.0]            ;153 70654 FSBB
        [FETCH AC&MEM] [FSBX] [TO AC.0]                 ;154 70660 FSBR
        [FETCH AC&I] [FSBX] [TO AC.0]                   ;155 70664 FSBRI
        [FETCH AC&MEM(W)] [FSBX] [TO MEM]               ;156 70670 FSBRM
        [FETCH AC&MEM(W)] [FSBX] [TO BOTH.0]            ;157 70674 FSBRB
        [FETCH AC&MEM] [FMPX] [TO AC.0]                 ;160 70700 FMP
        [MUUO]                                          ;161 70704 FMPL(Obs)
        [FETCH AC&MEM(W)] [FMPX] [TO MEM]               ;162 70710 FMPM
        [FETCH AC&MEM(W)] [FMPX] [TO BOTH.0]            ;163 70714 FMPB
        [FETCH AC&MEM] [FMPRX] [TO AC.0]                ;164 70720 FMPR
        [FETCH AC&MEM] [FMPRX] [TO AC.0]                ;165 70724 FMPRI
        [FETCH AC&MEM(W)] [FMPRX] [TO MEM]              ;166 70730 FMPRM
        [FETCH AC&MEM(W)] [FMPRX] [TO BOTH.0]           ;167 70734 FMPRB

        [FETCH MEM] [FDVX] [TO AC.0]                    ;170 70740 FDV
        [MUUO]                                          ;171 70744 FDVL(Obs)
        [FETCH AC&MEM(W)] [FDVX] [TO MEM]               ;172 70750 FDVM
        [FETCH AC&MEM(W)] [FDVX] [TO BOTH.0]            ;173 70754 FDVB
        [FETCH AC&MEM] [FDVX] [TO AC.0]                 ;174 70760 FDVR
        [FETCH AC&MEM] [FDVX] [TO AC.0]                 ;175 70764 FDVRI
        [FETCH AC&MEM(W)] [FDVX] [TO MEM]               ;176 70770 FDVRM
        [FETCH AC&MEM(W)] [FDVX] [TO BOTH.0]            ;177 70774 FDVRB

.TOC 2, "Opcodes 200 - 237"
        [FETCH MEM] [TO AC]                             ;200 71000 MOVE
.IF/FAST
        [MOVEI]                                         ;201 71004 MOVEI
.ENDIF/FAST
.IFNOT/FAST
        [FETCHI] [TO AC]                                ;201 71004 MOVEI
.ENDIF/FAST
        [FETCH AC] [TO MEM]                             ;202 71010 MOVEM
        [FETCH MEM(W)] [BACK TO SELF]                   ;203 71014 MOVES
        [FETCH MEM] [MOVSX] [TO AC]                     ;204 71020 MOVS
.IF/FAST
        [MOVSI]                                         ;205 71024 MOVSI
.ENDIF/FAST
.IFNOT/FAST
        [FETCH I] [MOVSI] [TO AC]                       ;205 71024 MOVSI
.ENDIF/FAST
        [FETCH AC] [MOVSX] [TO MEM]                     ;206 71030 MOVSM
        [FETCH AC&MEM(W)] [MOVSX] [BACK TO SELF]        ;207 71034 MOVSS
        [FETCH MEM] [MOVNX] [TO AC]                     ;210 71040 MOVN
        [FETCH I] [MOVNX] [TO AC]                       ;211 71044 MOVNI
        [FETCH AC(MX)] [MOVNX] [TO MEM]                 ;212 71050 MOVNM
        [FETCH MEM(W)] [MOVNX] [BACK TO SELF]           ;213 71054 MOVNS
        [FETCH MEM] [MOVMX] [TO AC]                     ;214 71060 MOVM
.IF/FAST
        [MOVEI]                                         ;215 71064 MOYMI (=MOVEI)
.ENDIF/FAST
.IFNOT/FAST
        [FETCH I] [TO AC]                               ;215 71064 MOYMI (=MOVEI)
.ENDIF/FAST
        [FETCH AC(MX)] [MOVMX] [TO MEM]                 ;216 71070 MOVMM
        [FETCH MEM(W)] [MOVMX] [BACK TO SELF]           ;217 71074 MOVMS
        [FETCH AC&MEM] [MULX] [IMULX] [TO AC.0]         ;220 71100 IMUL
        [FETCH AC&I] [MULX] [IMULX] [TO AC.0]           ;221 71104 IMULI
        [FETCH AC&MEM(W)] [MULX] [IMULX] [BACK TO MEM]  ;222 71110 IMULM
        [FETCH AC&MEM(W)] [MULX] [IMULX] [TO BOTH.0]    ;223 71114 IMULB
        [FETCH AC&MEM] [MULX] [D TO AC]                 ;224 71120 MUL
        [FETCH AC&I] [MULX] [D TO AC]                   ;225 71124 MULI
        [FETCH AC&MEM(W)] [MULX] [BACK TO MEM]          ;226 71130 MULM
        [FETCH AC&MEM(W)] [MULX] [TO MEM D AC]          ;227 71134 MULB
        [FETCH AC&MEM] [IDIVX] [D TO AC.0]              ;230 71140 IDIV
        [FETCH AC&I] [IDIVX] [D TO AC.0]                ;231 71144 IDIVI
        [FETCH AC&MEM(W)] [IDIVX] [BACK TO MEM]         ;232 71150 IDIVM
        [FETCH AC&MEM(W)] [IDIVX] [TO MEM D AC]         ;233 71154 IDIVB
        [FETCH AC&MEM] [DIVX] [D TO AC.0]               ;234 71160 DIV
        [FETCH AC&I] [DIVX] [D TO AC.0]                 ;235 71164 DIVI
        [FETCH AC&MEM(W)] [DIVX] [BACK TO MEM]          ;236 71170 DIVM
        [FETCH AC&MEM(W)] [DIVX] [TO MEM D AC]          ;237 71174 DIVB

.TOC 2, "Opcodes 240 - 277"
        [FETCH AC(MX)] [ASH SETUP] [ASH] [ASHR]         ;240 71200 ASH
        [FETCH AC] [ASH SETUP] [ROT] [ROTR]             ;241 71204 ROT
        [FETCH AC] [ASH SETUP] [LSH] [LSHR]             ;242 71210 LSH
        [FETCH AC(MX)] [JFFO]                           ;243 71214 JFFO
        [DFETCH AC] [ASHC SETUP] [ASHC] [ASHCR]         ;244 71220 ASHC
        [DFETCH AC] [LSHC SETUP] [ROTC] [ROTCR]         ;245 71224 ROTC
        [DFETCH AC] [LSHC SETUP] [LSHC] [LSHCR]         ;246 71230 LSHC
        [MUUO]                                          ;247 71234 MUUO
        [FETCH AC&MEM(W)] [TO EACH]                     ;250 71240 EXCH
.IF/FAST
        [FETCH AC] [BLT] [BLT+1N]                       ;251 71244 BLT
.ENDIF/FAST
.IFNOT/FAST
        [FETCH AC] [BLT]                                ;251 71244 BLT
.ENDIF/FAST
        [FETCH AC] [AOBJX] [JXGE] [TO AC.0]             ;252 71250 AOBJP
        [FETCH AC] [AOBJX] [JXL] [TO AC.0]              ;253 71254 AOBJN
        [JRST] [MCE] [MCE] [IFETCH]                     ;254 71260 JRST
        [JFCL] [MCE] [MCE] [IFETCH]                     ;255 71264 JFCL
        [FETCH MEM] [XCT]                               ;256 71270 XCT
        [MAP]                                           ;257 71274 MAP
        [FETCH AC] [CHK PC SECT] [PUSHJ]                ;260 71300 PUSHJ
        [FETCH AC&MEM] [PUSH]                           ;261 71304 PUSH
        [FETCH AC] [CHK PC SECT] [POP]                  ;262 71310 POP
        [FETCH AC] [CHK PC SECT] [POPJ]                 ;263 71314 POPJ
        [CHK PC SECT] [JSR] [JSR SETUP]                 ;264 71320 JSR
        [CHK PC SECT] [JSP] [JSR SETUP]                 ;265 71324 JSP
        [FETCH AC] [JSA]                                ;266 71330 JSA
        [FETCH AC] [JRA]                                ;267 71334 JRA
        [FETCH AC&MEM] [ADDX] [TO AC]                   ;270 71340 ADD
        [FETCH AC&I] [ADDX] [TO AC]                     ;271 71344 ADDI
        [FETCH AC&MEM(W)] [ADDX] [BACK TO MEM]          ;272 71350 ADDK
        [FETCH AC&MEM(W)] [ADDX] [TO BOTH.0]            ;273 71354 ADDB
        [FETCH AC&MEM] [SUBX] [TO AC]                   ;274 11360 SUB
        [FETCH AC&I] [SUBX] [TO AC]                     ;275 71364 SUBI
        [FETCH AC&MEM(W)] [SUBX] [BACK TO MEM]          ;276 71370 SUBK
        [FETCH AC&MEM(W)] [SUBX] [TO BOTH.0]            ;277 71374 SUBB

.TOC 2, "Opcodes 300 - 337"
        [TO NOWHERE]                                    ;300 71400 CAI
        [FETCH AC&I] [CAX] [SXL] [IFETCH]##[JXA]        ;301 71404 CAIL  JRST 1,
        [FETCH AC&I] [CAX] [SXE] [IFETCH]##[JRSTF]      ;302 71410 CAIE  JRST 2,
        [FETCH AC&I] [CAX] [SXLE] [IFETCH]##[MUUO]      ;303 71414 CAILE JRST 3,
        [FETCH AC&I] [CAX] [SXA] [IFETCH]##[HALT]       ;304 71420 CAIA  JRST 4,
        [FETCH AC&I] [CAX] [SXGE] [IFETCH]##[XJRSTF]    ;305 71424 CAIGE JRST 5,
        [FETCH AC&I] [CAX] [SXN] [IFETCH]##[XJEN]       ;306 71430 CAIN  JRST 6,
        [FETCH AC&I] [CAX] [SXG] [IFETCH]##[XPCW]       ;307 71434 CAIG  JRST 7,
        [FETCH MEM] [IFETCH]##[JRST 10]                 ;310 71440 CAM   JRST 10,
        [FETCH AC&MEM] [CAX] [SXL] [IFETCH]##[MUUO]     ;311 71444 CAML  JRST 11,
        [FETCH AC&MEM] [CAX] [SXE] [IFETCH]##[JEN]      ;312 71450 CAME  JRST 12,
        [FETCH AC&MEM] [CAX] [SXLE] [IFETCH]##[MUUO]    ;313 71454 CAMLE JRST 13,
        [FETCH AC&MEM] [CAX] [SXA] [IFETCH]##[SFM]      ;314 71460 CAMA  JRST 14,
        [FETCH AC&MEM] [CAX] [SXGE] [IFETCH]##[MUUO]    ;315 71464 CAMGE JRST 15,
        [FETCH AC&MEM] [CAX] [SXN] [IFETCH]##[MUUO]     ;316 71470 CAMN  JRST 16,
        [FETCH AC&MEM] [CAX] [SXG] [IFETCH]##[MUUO]     ;317 71474 CAMG  JRST 17,
        [TO NOWHERE]                                    ;320 71500 JUMP
        [FETCH AC(MX)] [JXL] [MCE] [IFETCH]             ;321 71504 JUMPL
        [FETCH AC(MX)] [JXE] [MCE] [IFETCH]             ;322 71510 JUKPE
        [FETCH AC(MX)] [JXLE] [MCE] [IFETCH]            ;323 71514 JUMPLE
        [JXA] [MCE] [MCE] [IFETCH]                      ;324 71520 JUKPA
        [FETCH AC(MX)] [JXGE] [MCE] [IFETCH]            ;325 71524 JUKPGE
        [FETCH AC(MX)] [JXN] [MCE] [IFETCH]             ;326 71530 JUKPN
        [FETCH AC(MX)] [JXG] [MCE] [IFETCH]             ;327 71534 JUKPG
        [FETCH MEM] [SKIPX]                             ;330 7154O SKIP
        [FETCH MEM] [SXL] [MCE] [SKIPX]                 ;331 71544 SKIPL
        [FETCH MEM] [SXE] [MCE] [SKIPX]                 ;332 71550 SKIPE
        [FETCH MEM] [SXLE] [MCE] [SKIPX]                ;333 71554 SKIPLE
        [FETCH MEM] [SXA] [MCE] [SKIPX]                 ;334 71560 SKIPA
        [FETCH MEM] [SXGE] [MCE] [SKIPX]                ;335 71564 SKIPGE
        [FETCH MEM] [SXN] [MCE] [SKIPX]                 ;336 71570 SKIPN
        [FETCH MEM] [SXG] [MCE] [SKIPX]                 ;337 71574 SKIPG

.TOC 2, "Opcodes 340 - 377"
        [FETCH AC] [AOXX] [TO AC]                       ;340 71600 AOJ
        [FETCH AC] [AOXX] [JXL] [TO AC]                 ;341 71604 AOJL
        [FETCH AC] [AOXX] [JXE] [TO AC]                 ;342 71610 AOJE
        [FETCH AC] [AOXX] [JXLE] [TO AC]                ;343 71614 AOJLE
        [FETCH AC] [AOXX] [JXA] [TO AC]                 ;344 71620 AOJA
        [FETCH AC] [AOXX] [JXGE] [TO AC]                ;345 71624 AOJGE
        [FETCH AC] [AOXX] [JXN] [TO AC]                 ;346 71630 AOJN
        [FETCH AC] [AOXX] [JXG] [TO AC]                 ;347 71634 AOJG
        [FETCH MEM(W)] [AOXX] [BACK TO SELF]            ;350 71640 AOS
        [FETCH MEM(W)] [AOXX] [SXL] [BACK TO SELF]      ;351 ji644 AOSL
        [FETCH MEM(W)] [AOXX] [SXE] [BACK TO SELF]      ;352 71650 AOSE
        [FETCH MEM(W)] [AOXX] [SXLE] [BACK TO SELF]     ;353 71654 AOSLE
        [FETCH MEM(W)] [AOXX] [SXA] [BACK TO SELF]      ;354 71660 AOSA
        [FETCH MEM(W)] [AOXX] [SXGE] [BACK TO SELF]     ;355 71664 AOSGE
        [FETCH MEM(W)] [AOXX] [SXN] [BACK TO SELF]      ;356 71670 AOSN
        [FETCH MEM(W)] [AOXX] [SXG] [BACK TO SELF]      ;357 71674 AOSG
        [FETCH AC] [SOXX] [TO AC]                       ;360 71700 SOJ
        [FETCH AC] [SOXX] [JXL] [TO AC]                 ;361 71704 SOJL
        [FETCH AC] [SOXX] [JXE] [TO AC]                 ;362 71710 SOJE
        [FETCH AC] [SOXX] [JXLE] [TO AC]                ;363 71714 SOJLE
        [FETCH AC] [SOXX] [JXA] [TO AC]                 ;364 71720 SOJA
        [FETCH AC] [SOXX] [JXGE] [TO AC]                ;365 71724 SOJGE
        [FETCH AC] [SOXX] [JXN] [TO AC]                 ;366 71730 SOJN
        [FETCH AC] [SOXX] [JXG] [TO AC]                 ;367 71734 SOJG
        [FETCH MEM(W)] [SOXX] [BACK TO SELF]            ;370 71740 SOS
        [FETCH MEM(W)] [SOXX] [SXL] [BACK TO SELF]      ;371 71744 SOSL
        [FETCH MEM(W)] [SOXX] [SXE] [BACK TO SELF]      ;372 71750 SOSE
        [FETCH MEM(W)] [SOXX] [SXLE] [BACK TO SELF]     ;373 71754 SOSLE
        [FETCH MEM(W)] [SOXX] [SXA] [BACK TO SELF]      ;374 71760 SOSA
        [FETCH MEM(W)] [SOXX] [SXGE] [BACK TO SELF]     ;375 71764 SOSGE
        [FETCH MEM(W)] [SOXX] [SXN] [BACK TO SELF]      ;376 71770 SOSN
        [FETCH MEM(W)] [SOXX] [SXG] [BACK TO SELF]      ;377 71774 SOSG

.TOC 2, "Opcodes 400 - 437"
        [SETZX] [TO AC]                                 ;400 72000 SETZ
        [SETZX] [TO AC]                                 ;401 72004 SETZI
        [SETZX] [TO MEM]                                ;402 72010 SETZM
        [SETZX] [TO BOTH]                               ;403 72014 SETZB
        [FETCH AC&MEM] [ANDX] [TO AC]                   ;404 72020 AND
        [FETCH AC&I] [ANDX] [TO AC]                     ;405 72024 ANDI
        [FETCH AC&MEM(W)] [ANDX] [BACK TO MEM]          ;406 72030 ANDM
        [FETCH AC&MEM(W)] [ANDX] [TO BOTH]              ;407 72034 ANDB
        [FETCH AC&MEM] [ANDCAX] [TO AC]                 ;410 72040 ANDCA
        [FETCH AC&I] [ANDCAX] [TO AC]                   ;411 72044 ANDCAI
        [FETCH AC&MEM(W)] [ANDCAX] [BACK TO MEM]        ;412 72050 ANDCAM
        [FETCH AC&MEM(W)] [ANDCAX] [TO BOTH]            ;413 72054 ANDCAB
        [FETCH MEM] [TO AC]                             ;414 72060 SETM
        [XMOVEI] [MCE] [TO AC]                          ;415 72064 SETMI XMOVEI
        [FETCH MEM(W)] [BACK TO MEM]                    ;416 72070 SETMM
        [FETCH MEM(W)] [TO BOTH]                        ;417 72074 SETMB
        [FETCH AC&MEM] [ANDCMX] [TO AC]                 ;420 72100 ANDCM
        [FETCH AC&I] [ANDCMX] [TO AC]                   ;421 72104 ANDCMI
        [FETCH AC&MEM(W)] [ANDCMX] [BACK TO MEM]        ;422 72110 ANDCMM
        [FETCH AC&MEM(W)] [ANDCMX] [TO BOTH]            ;423 72114 ANDCMB
        [TO NOWHERE]                                    ;424 72120 SETA (no-op)
        [TO NOWHERE]                                    ;425 72124 SETAI (no-op)
        [FETCH AC] [TO MEM]                             ;426 72130 SETAM (= MOVEM)
        [FETCH AC] [TO MEM]                             ;427 72134 SETAB (= MOVEM)
        [FETCH AC&MEM] [XORX] [TO AC]                   ;430 72140 XOR
        [FETCH AC&I] [XORX] [TO AC]                     ;431 72144 XORI
        [FETCH AC&MEM(W)] [XORX] [BACK TO MEM]          ;432 72150 XORM
        [FETCH AC&MEM(W)] [XORX] [TO BOTH]              ;433 72154 XORB
        [FETCH AC&MEM] [IORX] [TO AC]                   ;434 72160 IOR
        [FETCH AC&I] [IORX] [TO AC]                     ;435 72164 IORI
        [FETCH AC&MEM(W)] [IORX] [BACK TO MEM]          ;436 72170 10RM
        [FETCH AC&MEM(W)] [IORX] [TO BOTH]              ;437 72174 IORB

.TOC 2, "Opcodes 440 - 477"
        [FETCH AC&MEM] [ANDCBX] [TO AC]                 ;440 72200 ANDCB
        [FETCH AC&I] [ANDCBX] [TO AC]                   ;441 72204 ANDCBI
        [FETCH AC&MEM(W)] [ANDCBX] [BACK TO MEM]        ;442 72210 ANDCBM
        [FETCH AC&MEM(W)] [ANDCBX] [TO BOTH]            ;443 72214 ANDCBB
        [FETCH AC&MEM] [EQVX] [TO AC]                   ;444 72220 EQV
        [FETCH AC&I] [EQVX] [TO AC]                     ;445 72224 EQVI
        [FETCH AC&MEM(W)] [EQVX] [BACK TO MEM]          ;446 72230 EQVM
        [FETCH AC&MEM(W)] [EQVX] [TO BOTH]              ;447 72234 EQVB
        [FETCH AC] [SETCAX] [TO AC]                     ;450 72240 SETCA
        [FETCH AC] [SETCAX] [TO AC]                     ;451 72244 SETCAI
        [FETCH AC] [SETCAX] [TO MEM]                    ;452 72250 SETCAM
        [FETCH AC] [SETCAX] [TO BOTH]                   ;453 72254 SETCAB
        [FETCH AC&MEM] [ORCAX] [TO AC]                  ;454 72260 ORCA
        [FETCH AC&I] [ORCAX] [TO AC]                    ;455 72264 ORCAI
        [FETCH AC&MEM(W)] [ORCAX] [BACK TO MEM]         ;456 72270 ORCAM
        [FETCH AC&MEM(W)] [ORCAX] [TO BOTH]             ;457 72274 ORCAB
        [FETCH MEM] [SETCMX] [TO AC]                    ;460 72300 SETCM
        [FETCH I] [SETCMX] [TO AC]                      ;461 72304 SETCMI
        [FETCH MEM(W)] [SETCMX] [BACK TO MEM]           ;462 72310 SETCMM
        [FETCH MEM(W)] [SETCMX] [TO BOTH]               ;463 72314 SETCMB
        [FETCH AC&MEM] [ORCMX] [TO AC]                  ;464 72320 ORCM
        [FETCH AC&I] [ORCMX] [TO AC]                    ;465 72324 ORCMI
        [FETCH AC&MEM(W)] [ORCMX] [BACK TO MEM]         ;466 72330 ORCMM
        [FETCH AC&MEM(W)] [ORCMX] [TO BOTH]             ;467 72334 ORCMB
        [FETCH AC&MEM] [ORCBX] [TO AC]                  ;470 72340 ORCB
        [FETCH AC&I] [ORCBX] [TO AC]                    ;471 72344 ORCBI
        [FETCH AC&MEM(W)] [ORCBX] [BACK TO MEM]         ;472 72350 ORCBM
        [FETCH AC&MEM(W)] [ORCBX] [TO BOTH]             ;473 72354 ORCBB
        [SETOX] [TO AC]                                 ;474 72360 SETO
        [SETOX] [TO AC]                                 ;475 72364 SETOI
        [SETOX] [TO MEM]                                ;476 72370 SETOM
        [SETOX] [TO BOTH]                               ;477 72374 SETOB

.TOC 2, "Opcodes 500 - 537"
        [FETCH AC&MEM] [HLL] [TO AC]                    ;500 72400 HLL
        [FETCH AC] [XHLLI] [TO AC.0]                    ;501 72404 HLLI XHLLI
        [FETCH AC&MEM(W)] [HLLM] [TO MEM]               ;502 72410 HLLM
        [FETCH MEM(W)] [BACK TO SELF]                   ;503 72414 HLLS
        [FETCH AC&MEM] [HRL] [AC TO AC]                 ;504 72420 HRL
        [FETCH AC&I] [HRL] [AC TO AC]                   ;505 72424 HRLI
        [FETCH AC&MEM(W)] [HRLM] [TO MEM]               ;506 72430 HRLM
        [FETCH AC&MEM(W)] [HRLS] [BACK TO SELF]         ;507 72434 HRLS
        [FETCH MEM] [HLLZX] [MCE] [TO AC]               ;510 72440 HLLZ
        [FETCH I] [HLLZX] [MCE] [TO AC]                 ;511 72444 HLLZI
        [FETCH AC] [HLLZX] [MCE] [TO MEM]               ;512 72450 HLLZM
        [FETCH MEM(W)] [HLLZX] [MCE] [BACK TO SELF]     ;513 72454 HLLZS
        [FETCH MEM] [MOVSX] [HLLZX] [TO AC]             ;514 72460 HRLZ
.IF/FAST
        [MOVSI]                                         ;515 72464 HRLZI
.ENDIF/FAST
.IFNOT/FAST
        [FETCH I] [MOVSX] [HLLZX] [TO AC]               ;515 72464 HRLZI
.ENDIF/FAST
        [FETCH AC] [MOVSX] [HLLZX] [TO MEM]             ;516 72470 HRLZM
        [FETCH MEM(W)] [MOVSX] [HLLZX] [BACK TO SELF]   ;517 72474 HRLZS
        [FETCH MEM] [HLLOX] [MCE] [TO AC]               ;520 72500 HLLO
        [FETCH I] [HLLOX] [MCE] [TO AC]                 ;521 72504 HLLOI
        [FETCH AC] [HLLOX] [MCE] [TO MEM]               ;522 72510 HLLOM
        [FETCH MEM(W)] [HLLOX] [MCE] [BACK TO SELF]     ;523 72514 HLLOS
        [FETCH MEM] [MOVSX] [HLLOX] [TO AC]             ;524 72520 HRLO
        [FETCH I] [MOVSX] [HLLOX] [TO AC]               ;525 72524 HRLOI
        [FETCH AC] [MOVSX] [HLLOX] [TO MEM]             ;526 72530 HRLOM
        [FETCH MEM(W)] [MOVSX] [HLLOX] [BACK TO SELF]   ;527 72534 HRlOS
        [FETCH MEM] [HLLEX] [MCE] [TO AC]               ;530 72540 HLLE
        [FETCH I] [HLLEX] [MCE] [TO AC]                 ;531 72544 HLLEI
        [FETCH AC(MX)] [HLLEX] [MCE] [TO MEM]           ;532 72550 HLLEM
        [FETCH MEM(W)] [HLLEX] [MCE] [BACK TO SELF]     ;533 72554 HLLES
        [FETCH MEM] [MOVSX] [HRLEX] [TO AC]             ;534 72560 HRLE
        [FETCH I] [MOVSX] [HRLEX] [TO AC]               ;535 72564 HRLEI
        [FETCH AC(MX)] [MOVSX] [HRLEX] [TO MEM]         ;536 72570 HRLEM
        [FETCH MEM(W)] [MOVSX] [HRLEX] [BACK TO SELF]   ;537 72574 HRLES

.TOC 2, "Opcodes 540 - 577"
        [FETCH AC&MEM] [HRR] [TO AC]                    ;540 72600 HRR
        [FETCH AC&I] [HRR] [TO AC]                      ;541 72604 HRRI
        [FETCH AC&MEM(W)] [HRRM] [TO MEM]               ;542 72610 HRRM
        [FETCH MEM(W)] [BACK TO SELF]                   ;543 72614 HRRS
        [FETCH AC&MEM] [HLR] [AC TO AC]                 ;544 72620 HLR
        [FETCH AC&I] [HLR] [AC TO AC]                   ;545 72624 HLRI
        [FETCH AC&MEM(W)] [HLRM] [TO MEM]               ;546 72630 HLRM
        [FETCH AC&MEM(W)] [HLRS] [BACK TO SELF]         ;547 72634 HLRS

        [FETCH MEM] [HRRZX] [MCE] [TO AC]               ;550 72640 HRRZ
.IF/FAST
        [MOVEI]                                         ;551 72644 HRRZI
.ENDIF/FAST
.IFNOT/FAST
        [FETCH I] [HRRZX] [MCE] [TO AC]                 ;551 72644 HRRZI
.ENDIF/FAST
        [FETCH AC] [HRRZX] [MCE] [TO MEM]               ;552 72650 HRRZM
        [FETCH MEM(W)] [HRRZX] [MCE] [BACK TO SELF]     ;553 72654 HRRZS
        [FETCH MEM] [MOVSX] [HRRZX] [TO AC]             ;554 72660 HlRZ
        [FETCH I] [MOVSX] [HRRZX] [TO AC]               ;555 72664 HlRZI
        [FETCH AC] [MOVSX] [HRRZX] [TO MEM]             ;556 72610 HLRZM
        [FETCH MEM(W)] [MOVSX] [HRRZX] [BACK TO SELF]   ;557 72614 HLRZS
        [FETCH MEM] [HRROX] [MCE] [TO AC]               ;560 72700 HRRO
        [FETCH I] [HRROX] [MCE] [TO AC]                 ;561 72704 HRROI
        [FETCH AC] [HRROX] [MCE] [TO MEM]               ;562 72710 HRROM
        [FETCH MEM(W)] [HRROX] [MCE] [BACK TO SELF]     ;563 72714 HRROS
        [FETCH MEM] [MOVSX] [HRROX] [TO AC]             ;564 72720 HLRO
        [FETCH I] [MOVSX] [HRROX] [TO AC]               ;565 72724 HLROI
        [FETCH AC] [MOVSX] [HRROX] [TO MEM]             ;566 12730 HLROM
        [FETCH MEM(W)] [MOVSX] [HRROX] [BACK TO SELF]   ;567 72734 HLROS
        [FETCH MEM] [HRREX] [MCE] [TO AC]               ;570 72740 HRRE
        [FETCH I] [HRREX] [MCE] [TO AC]                 ;571 72744 HRREI
        [FETCH AC(MX)] [HRREX] [MCE] [TO MEM]           ;572 72750 HRREM
        [FETCH MEM(W)] [HRREX] [MCE] [BACK TO SELF]     ;573 72754 HRRES
        [FETCH MEM] [MOVSX] [HRREX] [TO AC]             ;574 72760 HLRE
        [FETCH I] [MOVSX] [HRREX] [TO AC]               ;575 72764 HLREI
        [FETCH AC(MX)] [MOVSX] [HRREX] [TO MEM]         ;576 72770 HLREM
        [FETCH MEM(W)] [MOVSX] [HRREX] [BACK TO SELF]   ;577 72774 HLRES

.TOC 2, "Opcodes 600 - 637"
        [TO NOWHERE]                                    ;600 73000 TRN
        [TO NOWHERE]                                    ;601 73004 TLN
        [TRX] [TXE] [IFETCH]                            ;602 73010 TRNE
        [TLX] [TXE] [IFETCH]                            ;603 73014 TLNE
        [TRX] [TXA] [IFETCH]                            ;604 73020 TRNA
        [TLX] [TXA] [IFETCH]                            ;605 73024 TLNA
        [TRX] [TXN] [IFETCH]                            ;606 73030 TRNN
        [TLX] [TXN] [IFETCH]                            ;607 73034 TLNN
        [TDX] [IFETCH]                                  ;610 73040 TDN
        [TSX] [IFETCH]                                  ;611 73044 TSN
        [TDX] [TXE] [IFETCH]                            ;612 73050 TDNE
        [TSX] [TXE] [IFETCH]                            ;613 73054 TSNE
        [TDX] [TXA] [IFETCH]                            ;614 73060 TDNA
        [TSX] [TXA] [IFETCH]                            ;615 73064 TSNA
        [TDX] [TXN] [IFETCH]                            ;616 73070 TDNN
        [TSX] [TXN] [IFETCH]                            ;617 73074 TSNN
        [TRX] [TXZ]                                     ;620 73100 TRZ
        [TLX] [TXZ]                                     ;621 73104 TLZ
        [TRX] [TXE] [TXZ]                               ;622 73110 TRZE
        [TLX] [TXE] [TXZ]                               ;623 73114 TLZE
        [TRX] [TXA] [TXZ]                               ;624 73120 TRZA
        [TLX] [TXA] [TXZ]                               ;625 73124 TLZA
        [TRX] [TXN] [TXZ]                               ;626 73130 TRZN
        [TLX] [TXN] [TXZ]                               ;627 73134 TLZN
        [TDX] [TXZ]                                     ;630 73140 TDZ
        [TSX] [TXZ]                                     ;631 73144 TSZ
        [TDX] [TXE] [TXZ]                               ;632 73150 TDZE
        [TSX] [TXE] [TXZ]                               ;633 73154 TSZE
        [TDX] [TXA] [TXZ]                               ;634 73160 TDZA
        [TSX] [TXA] [TXZ]                               ;635 73164 TSZA
        [TDX] [TXN] [TXZ]                               ;636 73170 TDZN
        [TSX] [TXN] [TXZ]                               ;637 73174 TSZN

.TOC 2, "Opcodes 640 - 677"
        [TRX] [TXC]                                     ;640 73200 TRC
        [TLX] [TXC]                                     ;641 73204 TLC
        [TRX] [TXE] [TXC]                               ;642 73210 TRCE
        [TLX] [TXE] [TXC]                               ;643 73214 TLCE
        [TRX] [TXA] [TXC]                               ;644 73220 TRCA
        [TLX] [TXA] [TXC]                               ;645 73224 TLCA
        [TRX] [TXN] [TXC]                               ;646 73230 TRCN
        [TLX] [TXN] [TXC]                               ;647 73234 TLCN
        [TDX] [TXC]                                     ;650 73240 TDC
        [TSX] [TXC]                                     ;651 73244 TSC
        [TDX] [TXE] [TXC]                               ;652 73250 TDCE
        [TSX] [TXE] [TXC]                               ;653 73254 TSCE
        [TDX] [TXA] [TXC]                               ;654 73260 TDCA
        [TSX] [TXA] [TXC]                               ;655 73264 TSCA
        [TDX] [TXN] [TXC]                               ;656 73270 TDCN
        [TSX] [TXN] [TXC]                               ;651 73274 TSCN
        [TRX] [TXO]                                     ;660 73300 TRO
        [TLX] [TXO]                                     ;661 73304 TLO
        [TRX] [TXE] [TXO]                               ;662 73310 TROE
        [TLX] [TXE] [TXO]                               ;663 73314 TLOE
        [TRX] [TXA] [TXO]                               ;664 73310 TROA
        [TLX] [TXA] [TXO]                               ;665 73324 TLOA
        [TRX] [TXN] [TXO]                               ;666 73330 TRON
        [TLX] [TXN] [TXO]                               ;667 73334 TLON
        [TDX] [TXO]                                     ;670 73340 TDO
        [TSX] [TXO]                                     ;671 73344 TSO
        [TDX] [TXE] [TXO]                               ;672 73350 TDOE
        [TSX] [TXE] [TXO]                               ;673 73354 TSOE
        [TDX] [TXA] [TXO]                               ;674 73360 TDOA
        [TSX] [TXA] [TXO]                               ;675 73364 TSOA
        [TDX] [TXN] [TXO]                               ;676 73370 TDON
        [TSX] [TXN] [TXO]                               ;677 73374 TSON

.TOC 2, "Opcodes 700 - 737"
        [IO]                                            ;700 73400 IO
        [IO]                                            ;701 73404 IO
        [IO]                                            ;702 73410 IO
        [IO]                                            ;703 73414 IO
        [IO]                                            ;704 73420 IO
        [IO]                                            ;705 73424 IO
        [IO]                                            ;706 73430 IO
        [IO]                                            ;707 73434 IO
        [IO EFA] [FETCH AC&IO] [TIOE]                   ;710 73440 TIOE
        [IO EFA] [FETCH AC&IO] [TION]                   ;711 73444 TION
        [IO EFA] [FETCH IO] [TO AC]                     ;712 73450 RDIO
        [IO EFA] [WRIO]                                 ;713 73454 WRIO
        [IO EFA] [FETCH AC&IO] [BSIO]                   ;714 73460 BSIO
        [IO EFA] [FETCH AC&IO] [BCIO]                   ;715 73464 BCIO
        [IO]                                            ;716 73470 IO
        [IO]                                            ;717 73474 IO
        [MUUO]                                          ;720 73500 TIOEB
        [MUUO]                                          ;721 73504 TIONB
.IF/DEBUGTTY
        [RDTTY]                                         ;722 73510 RDIOB
.ENDIF/DEBUGTTY
.IFNOT/DEBUGTTY
        [MUUO]                                          ;722 73510 RDIOB
.ENDIF/DEBUGTTY
        [MUUO]                                          ;723 73514 WRIOB
        [MUUO]                                          ;724 73520 BSIOB
        [MUUO]                                          ;725 73524 BCIOB
        [IO]                                            ;726 73530 IO
        [IO]                                            ;727 73530 IO
        [IO]                                            ;730 73530 IO
        [IO]                                            ;731 73530 IO
        [IO]                                            ;732 73530 IO
        [IO]                                            ;733 73530 IO
        [IO]                                            ;734 73530 IO
        [IO]                                            ;735 73530 IO
        [IO]                                            ;736 73530 IO
        [IO]                                            ;737 73530 IO

.TOC 2, "Opcodes 740 - 777"
.IF/FTCIS
        [CIS SETUP] [MOVC]                              ;740 73740 IO
        [CIS SETUP] [CMPC]                              ;741 73744 IO
        [CIS SETUP] [MOVCV]                             ;742 73610 IO
        [CIS SETUP] [CMPCV]                             ;743 73614 IO
        [CIS SETUP] [CMPND]                             ;744 73620 IO
        [CIS SETUP] [ADDND]                             ;745 73624 IO
        [CIS SETUP] [SUBND]                             ;746 73630 IO
        [CIS SETUP] [MOVND]                             ;747 73634 IO
        [CIS SETUP] [CVTNDB]                            ;750 73640 IO
        [CIS SETUP] [CMPP]                              ;751 73644 IO
        [CIS SETUP] [ADDP]                              ;752 73650 IO
        [CIS SETUP] [SUBP]                              ;753 73654 IO
        [CIS SETUP] [MOVP]                              ;754 73660 IO
        [CIS SETUP] [CHOP]                              ;755 73664 IO
.ENDIF/FTCIS
.IFNOT/FTCIS
        [IO 4]                                          ;740 73600 IO
        [IO 4]                                          ;741 73604 IO
        [IO 4]                                          ;742 736IO IO
        [IO 4]                                          ;743 73614 IO
        [IO 4]                                          ;744 73620 IO
        [IO 4]                                          ;745 73624 IO
        [IO 4]                                          ;746 73630 IO
        [IO 4]                                          ;747 73634 IO
        [IO 4]                                          ;750 73640 IO
        [IO 4]                                          ;751 73644 IO
        [IO 4]                                          ;752 73650 IO
        [IO 4]                                          ;753 73654 IO
        [IO 4]                                          ;754 73660 IO
        [IO 4]                                          ;755 73664 IO
.ENDIF/FTCIS
        [IO 4]                                          ;756 73670 IO
        [IO 4]                                          ;757 73674 IO
        [IO 4]                                          ;760 73700 IO
        [IO 4]                                          ;761 73704 IO
        [IO 4]                                          ;762 73110 IO
        [IO 4]                                          ;763 73714 IO
        [IO 4]                                          ;764 73720 IO
        [IO 4]                                          ;765 73724 IO
        [IO 4]                                          ;766 73730 IO
        [IO 4]                                          ;767 73734 IO
        [IO 4]                                          ;770 73740 IO
        [IO 4]                                          ;771 73744 IO
        [IO 4]                                          ;772 73750 IO
        [IO 4]                                          ;773 73754 IO
        [IO 4]                                          ;774 73760 IO
        [IO 4]                                          ;775 73764 IO
        [IO 4]                                          ;776 73770 IO
        [IO 4]                                          ;777 73774 IO

;END OF FILE

